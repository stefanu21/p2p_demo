/*
 * Generated by gdbus-codegen 2.48.2. DO NOT EDIT.
 *
 * The license of this code is the same as for the source it was derived from.
 */

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif

#include "wpa_interface.h"

#include <string.h>
#ifdef G_OS_UNIX
#  include <gio/gunixfdlist.h>
#endif

typedef struct
{
  GDBusArgInfo parent_struct;
  gboolean use_gvariant;
} _ExtendedGDBusArgInfo;

typedef struct
{
  GDBusMethodInfo parent_struct;
  const gchar *signal_name;
  gboolean pass_fdlist;
} _ExtendedGDBusMethodInfo;

typedef struct
{
  GDBusSignalInfo parent_struct;
  const gchar *signal_name;
} _ExtendedGDBusSignalInfo;

typedef struct
{
  GDBusPropertyInfo parent_struct;
  const gchar *hyphen_name;
  gboolean use_gvariant;
} _ExtendedGDBusPropertyInfo;

typedef struct
{
  GDBusInterfaceInfo parent_struct;
  const gchar *hyphen_name;
} _ExtendedGDBusInterfaceInfo;

typedef struct
{
  const _ExtendedGDBusPropertyInfo *info;
  guint prop_id;
  GValue orig_value; /* the value before the change */
} ChangedProperty;

static void
_changed_property_free (ChangedProperty *data)
{
  g_value_unset (&data->orig_value);
  g_free (data);
}

static gboolean
_g_strv_equal0 (gchar **a, gchar **b)
{
  gboolean ret = FALSE;
  guint n;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  if (g_strv_length (a) != g_strv_length (b))
    goto out;
  for (n = 0; a[n] != NULL; n++)
    if (g_strcmp0 (a[n], b[n]) != 0)
      goto out;
  ret = TRUE;
out:
  return ret;
}

static gboolean
_g_variant_equal0 (GVariant *a, GVariant *b)
{
  gboolean ret = FALSE;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  ret = g_variant_equal (a, b);
out:
  return ret;
}

G_GNUC_UNUSED static gboolean
_g_value_equal (const GValue *a, const GValue *b)
{
  gboolean ret = FALSE;
  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
  switch (G_VALUE_TYPE (a))
    {
      case G_TYPE_BOOLEAN:
        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
        break;
      case G_TYPE_UCHAR:
        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
        break;
      case G_TYPE_INT:
        ret = (g_value_get_int (a) == g_value_get_int (b));
        break;
      case G_TYPE_UINT:
        ret = (g_value_get_uint (a) == g_value_get_uint (b));
        break;
      case G_TYPE_INT64:
        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
        break;
      case G_TYPE_UINT64:
        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
        break;
      case G_TYPE_DOUBLE:
        {
          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */
          gdouble da = g_value_get_double (a);
          gdouble db = g_value_get_double (b);
          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;
        }
        break;
      case G_TYPE_STRING:
        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
        break;
      case G_TYPE_VARIANT:
        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
        break;
      default:
        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
        else
          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
        break;
    }
  return ret;
}

/* ------------------------------------------------------------------------
 * Code for interface org.freedesktop.DBus.Introspectable
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:wpainterfaceOrgFreedesktopDBusIntrospectable
 * @title: wpainterfaceOrgFreedesktopDBusIntrospectable
 * @short_description: Generated C code for the org.freedesktop.DBus.Introspectable D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-freedesktop-DBus-Introspectable.top_of_page">org.freedesktop.DBus.Introspectable</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.freedesktop.DBus.Introspectable ---- */

static const _ExtendedGDBusArgInfo _wpa_interface_org_freedesktop_dbus_introspectable_method_info_introspect_OUT_ARG_data =
{
  {
    -1,
    (gchar *) "data",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_org_freedesktop_dbus_introspectable_method_info_introspect_OUT_ARG_pointers[] =
{
  &_wpa_interface_org_freedesktop_dbus_introspectable_method_info_introspect_OUT_ARG_data,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_org_freedesktop_dbus_introspectable_method_info_introspect =
{
  {
    -1,
    (gchar *) "Introspect",
    NULL,
    (GDBusArgInfo **) &_wpa_interface_org_freedesktop_dbus_introspectable_method_info_introspect_OUT_ARG_pointers,
    NULL
  },
  "handle-introspect",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _wpa_interface_org_freedesktop_dbus_introspectable_method_info_pointers[] =
{
  &_wpa_interface_org_freedesktop_dbus_introspectable_method_info_introspect,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _wpa_interface_org_freedesktop_dbus_introspectable_interface_info =
{
  {
    -1,
    (gchar *) "org.freedesktop.DBus.Introspectable",
    (GDBusMethodInfo **) &_wpa_interface_org_freedesktop_dbus_introspectable_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "org-freedesktop-dbus-introspectable",
};


/**
 * wpa_interface_org_freedesktop_dbus_introspectable_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-DBus-Introspectable.top_of_page">org.freedesktop.DBus.Introspectable</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
wpa_interface_org_freedesktop_dbus_introspectable_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_wpa_interface_org_freedesktop_dbus_introspectable_interface_info.parent_struct;
}

/**
 * wpa_interface_org_freedesktop_dbus_introspectable_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #wpainterfaceOrgFreedesktopDBusIntrospectable interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
wpa_interface_org_freedesktop_dbus_introspectable_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * wpainterfaceOrgFreedesktopDBusIntrospectable:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus-Introspectable.top_of_page">org.freedesktop.DBus.Introspectable</link>.
 */

/**
 * wpainterfaceOrgFreedesktopDBusIntrospectableIface:
 * @parent_iface: The parent interface.
 * @handle_introspect: Handler for the #wpainterfaceOrgFreedesktopDBusIntrospectable::handle-introspect signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus-Introspectable.top_of_page">org.freedesktop.DBus.Introspectable</link>.
 */

typedef wpainterfaceOrgFreedesktopDBusIntrospectableIface wpainterfaceOrgFreedesktopDBusIntrospectableInterface;
G_DEFINE_INTERFACE (wpainterfaceOrgFreedesktopDBusIntrospectable, wpa_interface_org_freedesktop_dbus_introspectable, G_TYPE_OBJECT);

static void
wpa_interface_org_freedesktop_dbus_introspectable_default_init (wpainterfaceOrgFreedesktopDBusIntrospectableIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * wpainterfaceOrgFreedesktopDBusIntrospectable::handle-introspect:
   * @object: A #wpainterfaceOrgFreedesktopDBusIntrospectable.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus-Introspectable.Introspect">Introspect()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_org_freedesktop_dbus_introspectable_complete_introspect() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-introspect",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceOrgFreedesktopDBusIntrospectableIface, handle_introspect),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

}

/**
 * wpa_interface_org_freedesktop_dbus_introspectable_call_introspect:
 * @proxy: A #wpainterfaceOrgFreedesktopDBusIntrospectableProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus-Introspectable.Introspect">Introspect()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_org_freedesktop_dbus_introspectable_call_introspect_finish() to get the result of the operation.
 *
 * See wpa_interface_org_freedesktop_dbus_introspectable_call_introspect_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_org_freedesktop_dbus_introspectable_call_introspect (
    wpainterfaceOrgFreedesktopDBusIntrospectable *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Introspect",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_org_freedesktop_dbus_introspectable_call_introspect_finish:
 * @proxy: A #wpainterfaceOrgFreedesktopDBusIntrospectableProxy.
 * @out_data: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_org_freedesktop_dbus_introspectable_call_introspect().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_org_freedesktop_dbus_introspectable_call_introspect().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_org_freedesktop_dbus_introspectable_call_introspect_finish (
    wpainterfaceOrgFreedesktopDBusIntrospectable *proxy,
    gchar **out_data,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_data);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_org_freedesktop_dbus_introspectable_call_introspect_sync:
 * @proxy: A #wpainterfaceOrgFreedesktopDBusIntrospectableProxy.
 * @out_data: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus-Introspectable.Introspect">Introspect()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_org_freedesktop_dbus_introspectable_call_introspect() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_org_freedesktop_dbus_introspectable_call_introspect_sync (
    wpainterfaceOrgFreedesktopDBusIntrospectable *proxy,
    gchar **out_data,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Introspect",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_data);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_org_freedesktop_dbus_introspectable_complete_introspect:
 * @object: A #wpainterfaceOrgFreedesktopDBusIntrospectable.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @data: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus-Introspectable.Introspect">Introspect()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_org_freedesktop_dbus_introspectable_complete_introspect (
    wpainterfaceOrgFreedesktopDBusIntrospectable *object,
    GDBusMethodInvocation *invocation,
    const gchar *data)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   data));
}

/* ------------------------------------------------------------------------ */

/**
 * wpainterfaceOrgFreedesktopDBusIntrospectableProxy:
 *
 * The #wpainterfaceOrgFreedesktopDBusIntrospectableProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * wpainterfaceOrgFreedesktopDBusIntrospectableProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #wpainterfaceOrgFreedesktopDBusIntrospectableProxy.
 */

struct _wpainterfaceOrgFreedesktopDBusIntrospectableProxyPrivate
{
  GData *qdata;
};

static void wpa_interface_org_freedesktop_dbus_introspectable_proxy_iface_init (wpainterfaceOrgFreedesktopDBusIntrospectableIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (wpainterfaceOrgFreedesktopDBusIntrospectableProxy, wpa_interface_org_freedesktop_dbus_introspectable_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (wpainterfaceOrgFreedesktopDBusIntrospectableProxy)
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE, wpa_interface_org_freedesktop_dbus_introspectable_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (wpainterfaceOrgFreedesktopDBusIntrospectableProxy, wpa_interface_org_freedesktop_dbus_introspectable_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE, wpa_interface_org_freedesktop_dbus_introspectable_proxy_iface_init));

#endif
static void
wpa_interface_org_freedesktop_dbus_introspectable_proxy_finalize (GObject *object)
{
  wpainterfaceOrgFreedesktopDBusIntrospectableProxy *proxy = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (wpa_interface_org_freedesktop_dbus_introspectable_proxy_parent_class)->finalize (object);
}

static void
wpa_interface_org_freedesktop_dbus_introspectable_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
wpa_interface_org_freedesktop_dbus_introspectable_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
wpa_interface_org_freedesktop_dbus_introspectable_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_wpa_interface_org_freedesktop_dbus_introspectable_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
wpa_interface_org_freedesktop_dbus_introspectable_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  wpainterfaceOrgFreedesktopDBusIntrospectableProxy *proxy = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_org_freedesktop_dbus_introspectable_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_org_freedesktop_dbus_introspectable_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
wpa_interface_org_freedesktop_dbus_introspectable_proxy_init (wpainterfaceOrgFreedesktopDBusIntrospectableProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = wpa_interface_org_freedesktop_dbus_introspectable_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_PROXY, wpainterfaceOrgFreedesktopDBusIntrospectableProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), wpa_interface_org_freedesktop_dbus_introspectable_interface_info ());
}

static void
wpa_interface_org_freedesktop_dbus_introspectable_proxy_class_init (wpainterfaceOrgFreedesktopDBusIntrospectableProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = wpa_interface_org_freedesktop_dbus_introspectable_proxy_finalize;
  gobject_class->get_property = wpa_interface_org_freedesktop_dbus_introspectable_proxy_get_property;
  gobject_class->set_property = wpa_interface_org_freedesktop_dbus_introspectable_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = wpa_interface_org_freedesktop_dbus_introspectable_proxy_g_signal;
  proxy_class->g_properties_changed = wpa_interface_org_freedesktop_dbus_introspectable_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (wpainterfaceOrgFreedesktopDBusIntrospectableProxyPrivate));
#endif
}

static void
wpa_interface_org_freedesktop_dbus_introspectable_proxy_iface_init (wpainterfaceOrgFreedesktopDBusIntrospectableIface *iface)
{
}

/**
 * wpa_interface_org_freedesktop_dbus_introspectable_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus-Introspectable.top_of_page">org.freedesktop.DBus.Introspectable</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_finish() to get the result of the operation.
 *
 * See wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
wpa_interface_org_freedesktop_dbus_introspectable_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.DBus.Introspectable", NULL);
}

/**
 * wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_org_freedesktop_dbus_introspectable_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with wpa_interface_org_freedesktop_dbus_introspectable_proxy_new().
 *
 * Returns: (transfer full) (type wpainterfaceOrgFreedesktopDBusIntrospectableProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceOrgFreedesktopDBusIntrospectable *
wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE (ret);
  else
    return NULL;
}

/**
 * wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus-Introspectable.top_of_page">org.freedesktop.DBus.Introspectable</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_org_freedesktop_dbus_introspectable_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type wpainterfaceOrgFreedesktopDBusIntrospectableProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceOrgFreedesktopDBusIntrospectable *
wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.DBus.Introspectable", NULL);
  if (ret != NULL)
    return WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE (ret);
  else
    return NULL;
}


/**
 * wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like wpa_interface_org_freedesktop_dbus_introspectable_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.DBus.Introspectable", NULL);
}

/**
 * wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type wpainterfaceOrgFreedesktopDBusIntrospectableProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceOrgFreedesktopDBusIntrospectable *
wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE (ret);
  else
    return NULL;
}

/**
 * wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type wpainterfaceOrgFreedesktopDBusIntrospectableProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceOrgFreedesktopDBusIntrospectable *
wpa_interface_org_freedesktop_dbus_introspectable_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.DBus.Introspectable", NULL);
  if (ret != NULL)
    return WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * wpainterfaceOrgFreedesktopDBusIntrospectableSkeleton:
 *
 * The #wpainterfaceOrgFreedesktopDBusIntrospectableSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * wpainterfaceOrgFreedesktopDBusIntrospectableSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #wpainterfaceOrgFreedesktopDBusIntrospectableSkeleton.
 */

struct _wpainterfaceOrgFreedesktopDBusIntrospectableSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_wpa_interface_org_freedesktop_dbus_introspectable_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  wpainterfaceOrgFreedesktopDBusIntrospectableSkeleton *skeleton = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_wpa_interface_org_freedesktop_dbus_introspectable_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  wpainterfaceOrgFreedesktopDBusIntrospectableSkeleton *skeleton = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_org_freedesktop_dbus_introspectable_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_wpa_interface_org_freedesktop_dbus_introspectable_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  wpainterfaceOrgFreedesktopDBusIntrospectableSkeleton *skeleton = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_org_freedesktop_dbus_introspectable_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _wpa_interface_org_freedesktop_dbus_introspectable_skeleton_vtable =
{
  _wpa_interface_org_freedesktop_dbus_introspectable_skeleton_handle_method_call,
  _wpa_interface_org_freedesktop_dbus_introspectable_skeleton_handle_get_property,
  _wpa_interface_org_freedesktop_dbus_introspectable_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
wpa_interface_org_freedesktop_dbus_introspectable_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return wpa_interface_org_freedesktop_dbus_introspectable_interface_info ();
}

static GDBusInterfaceVTable *
wpa_interface_org_freedesktop_dbus_introspectable_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_wpa_interface_org_freedesktop_dbus_introspectable_skeleton_vtable;
}

static GVariant *
wpa_interface_org_freedesktop_dbus_introspectable_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  wpainterfaceOrgFreedesktopDBusIntrospectableSkeleton *skeleton = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_wpa_interface_org_freedesktop_dbus_introspectable_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _wpa_interface_org_freedesktop_dbus_introspectable_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _wpa_interface_org_freedesktop_dbus_introspectable_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _wpa_interface_org_freedesktop_dbus_introspectable_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.DBus.Introspectable", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
wpa_interface_org_freedesktop_dbus_introspectable_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void wpa_interface_org_freedesktop_dbus_introspectable_skeleton_iface_init (wpainterfaceOrgFreedesktopDBusIntrospectableIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (wpainterfaceOrgFreedesktopDBusIntrospectableSkeleton, wpa_interface_org_freedesktop_dbus_introspectable_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (wpainterfaceOrgFreedesktopDBusIntrospectableSkeleton)
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE, wpa_interface_org_freedesktop_dbus_introspectable_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (wpainterfaceOrgFreedesktopDBusIntrospectableSkeleton, wpa_interface_org_freedesktop_dbus_introspectable_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE, wpa_interface_org_freedesktop_dbus_introspectable_skeleton_iface_init));

#endif
static void
wpa_interface_org_freedesktop_dbus_introspectable_skeleton_finalize (GObject *object)
{
  wpainterfaceOrgFreedesktopDBusIntrospectableSkeleton *skeleton = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (wpa_interface_org_freedesktop_dbus_introspectable_skeleton_parent_class)->finalize (object);
}

static void
wpa_interface_org_freedesktop_dbus_introspectable_skeleton_init (wpainterfaceOrgFreedesktopDBusIntrospectableSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = wpa_interface_org_freedesktop_dbus_introspectable_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_SKELETON, wpainterfaceOrgFreedesktopDBusIntrospectableSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
wpa_interface_org_freedesktop_dbus_introspectable_skeleton_class_init (wpainterfaceOrgFreedesktopDBusIntrospectableSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = wpa_interface_org_freedesktop_dbus_introspectable_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = wpa_interface_org_freedesktop_dbus_introspectable_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = wpa_interface_org_freedesktop_dbus_introspectable_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = wpa_interface_org_freedesktop_dbus_introspectable_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = wpa_interface_org_freedesktop_dbus_introspectable_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (wpainterfaceOrgFreedesktopDBusIntrospectableSkeletonPrivate));
#endif
}

static void
wpa_interface_org_freedesktop_dbus_introspectable_skeleton_iface_init (wpainterfaceOrgFreedesktopDBusIntrospectableIface *iface)
{
}

/**
 * wpa_interface_org_freedesktop_dbus_introspectable_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus-Introspectable.top_of_page">org.freedesktop.DBus.Introspectable</link>.
 *
 * Returns: (transfer full) (type wpainterfaceOrgFreedesktopDBusIntrospectableSkeleton): The skeleton object.
 */
wpainterfaceOrgFreedesktopDBusIntrospectable *
wpa_interface_org_freedesktop_dbus_introspectable_skeleton_new (void)
{
  return WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE (g_object_new (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_INTROSPECTABLE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.freedesktop.DBus.Properties
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:wpainterfaceOrgFreedesktopDBusProperties
 * @title: wpainterfaceOrgFreedesktopDBusProperties
 * @short_description: Generated C code for the org.freedesktop.DBus.Properties D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-freedesktop-DBus-Properties.top_of_page">org.freedesktop.DBus.Properties</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.freedesktop.DBus.Properties ---- */

static const _ExtendedGDBusArgInfo _wpa_interface_org_freedesktop_dbus_properties_method_info_get_IN_ARG_interface =
{
  {
    -1,
    (gchar *) "interface",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_org_freedesktop_dbus_properties_method_info_get_IN_ARG_propname =
{
  {
    -1,
    (gchar *) "propname",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_org_freedesktop_dbus_properties_method_info_get_IN_ARG_pointers[] =
{
  &_wpa_interface_org_freedesktop_dbus_properties_method_info_get_IN_ARG_interface,
  &_wpa_interface_org_freedesktop_dbus_properties_method_info_get_IN_ARG_propname,
  NULL
};

static const _ExtendedGDBusArgInfo _wpa_interface_org_freedesktop_dbus_properties_method_info_get_OUT_ARG_value =
{
  {
    -1,
    (gchar *) "value",
    (gchar *) "v",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_org_freedesktop_dbus_properties_method_info_get_OUT_ARG_pointers[] =
{
  &_wpa_interface_org_freedesktop_dbus_properties_method_info_get_OUT_ARG_value,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_org_freedesktop_dbus_properties_method_info_get =
{
  {
    -1,
    (gchar *) "Get",
    (GDBusArgInfo **) &_wpa_interface_org_freedesktop_dbus_properties_method_info_get_IN_ARG_pointers,
    (GDBusArgInfo **) &_wpa_interface_org_freedesktop_dbus_properties_method_info_get_OUT_ARG_pointers,
    NULL
  },
  "handle-get",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_org_freedesktop_dbus_properties_method_info_get_all_IN_ARG_interface =
{
  {
    -1,
    (gchar *) "interface",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_org_freedesktop_dbus_properties_method_info_get_all_IN_ARG_pointers[] =
{
  &_wpa_interface_org_freedesktop_dbus_properties_method_info_get_all_IN_ARG_interface,
  NULL
};

static const _ExtendedGDBusArgInfo _wpa_interface_org_freedesktop_dbus_properties_method_info_get_all_OUT_ARG_props =
{
  {
    -1,
    (gchar *) "props",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_org_freedesktop_dbus_properties_method_info_get_all_OUT_ARG_pointers[] =
{
  &_wpa_interface_org_freedesktop_dbus_properties_method_info_get_all_OUT_ARG_props,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_org_freedesktop_dbus_properties_method_info_get_all =
{
  {
    -1,
    (gchar *) "GetAll",
    (GDBusArgInfo **) &_wpa_interface_org_freedesktop_dbus_properties_method_info_get_all_IN_ARG_pointers,
    (GDBusArgInfo **) &_wpa_interface_org_freedesktop_dbus_properties_method_info_get_all_OUT_ARG_pointers,
    NULL
  },
  "handle-get-all",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_org_freedesktop_dbus_properties_method_info_set_IN_ARG_interface =
{
  {
    -1,
    (gchar *) "interface",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_org_freedesktop_dbus_properties_method_info_set_IN_ARG_propname =
{
  {
    -1,
    (gchar *) "propname",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_org_freedesktop_dbus_properties_method_info_set_IN_ARG_value =
{
  {
    -1,
    (gchar *) "value",
    (gchar *) "v",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_org_freedesktop_dbus_properties_method_info_set_IN_ARG_pointers[] =
{
  &_wpa_interface_org_freedesktop_dbus_properties_method_info_set_IN_ARG_interface,
  &_wpa_interface_org_freedesktop_dbus_properties_method_info_set_IN_ARG_propname,
  &_wpa_interface_org_freedesktop_dbus_properties_method_info_set_IN_ARG_value,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_org_freedesktop_dbus_properties_method_info_set =
{
  {
    -1,
    (gchar *) "Set",
    (GDBusArgInfo **) &_wpa_interface_org_freedesktop_dbus_properties_method_info_set_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-set",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _wpa_interface_org_freedesktop_dbus_properties_method_info_pointers[] =
{
  &_wpa_interface_org_freedesktop_dbus_properties_method_info_get,
  &_wpa_interface_org_freedesktop_dbus_properties_method_info_get_all,
  &_wpa_interface_org_freedesktop_dbus_properties_method_info_set,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _wpa_interface_org_freedesktop_dbus_properties_interface_info =
{
  {
    -1,
    (gchar *) "org.freedesktop.DBus.Properties",
    (GDBusMethodInfo **) &_wpa_interface_org_freedesktop_dbus_properties_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "org-freedesktop-dbus-properties",
};


/**
 * wpa_interface_org_freedesktop_dbus_properties_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-freedesktop-DBus-Properties.top_of_page">org.freedesktop.DBus.Properties</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
wpa_interface_org_freedesktop_dbus_properties_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_wpa_interface_org_freedesktop_dbus_properties_interface_info.parent_struct;
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #wpainterfaceOrgFreedesktopDBusProperties interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
wpa_interface_org_freedesktop_dbus_properties_override_properties (GObjectClass *klass, guint property_id_begin)
{
  return property_id_begin - 1;
}



/**
 * wpainterfaceOrgFreedesktopDBusProperties:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus-Properties.top_of_page">org.freedesktop.DBus.Properties</link>.
 */

/**
 * wpainterfaceOrgFreedesktopDBusPropertiesIface:
 * @parent_iface: The parent interface.
 * @handle_get: Handler for the #wpainterfaceOrgFreedesktopDBusProperties::handle-get signal.
 * @handle_get_all: Handler for the #wpainterfaceOrgFreedesktopDBusProperties::handle-get-all signal.
 * @handle_set: Handler for the #wpainterfaceOrgFreedesktopDBusProperties::handle-set signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus-Properties.top_of_page">org.freedesktop.DBus.Properties</link>.
 */

typedef wpainterfaceOrgFreedesktopDBusPropertiesIface wpainterfaceOrgFreedesktopDBusPropertiesInterface;
G_DEFINE_INTERFACE (wpainterfaceOrgFreedesktopDBusProperties, wpa_interface_org_freedesktop_dbus_properties, G_TYPE_OBJECT);

static void
wpa_interface_org_freedesktop_dbus_properties_default_init (wpainterfaceOrgFreedesktopDBusPropertiesIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * wpainterfaceOrgFreedesktopDBusProperties::handle-get:
   * @object: A #wpainterfaceOrgFreedesktopDBusProperties.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_interface: Argument passed by remote caller.
   * @arg_propname: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus-Properties.Get">Get()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_org_freedesktop_dbus_properties_complete_get() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceOrgFreedesktopDBusPropertiesIface, handle_get),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * wpainterfaceOrgFreedesktopDBusProperties::handle-get-all:
   * @object: A #wpainterfaceOrgFreedesktopDBusProperties.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_interface: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus-Properties.GetAll">GetAll()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_org_freedesktop_dbus_properties_complete_get_all() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-all",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceOrgFreedesktopDBusPropertiesIface, handle_get_all),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * wpainterfaceOrgFreedesktopDBusProperties::handle-set:
   * @object: A #wpainterfaceOrgFreedesktopDBusProperties.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_interface: Argument passed by remote caller.
   * @arg_propname: Argument passed by remote caller.
   * @arg_value: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-freedesktop-DBus-Properties.Set">Set()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_org_freedesktop_dbus_properties_complete_set() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceOrgFreedesktopDBusPropertiesIface, handle_set),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    4,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_VARIANT);

}

/**
 * wpa_interface_org_freedesktop_dbus_properties_call_get:
 * @proxy: A #wpainterfaceOrgFreedesktopDBusPropertiesProxy.
 * @arg_interface: Argument to pass with the method invocation.
 * @arg_propname: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus-Properties.Get">Get()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_org_freedesktop_dbus_properties_call_get_finish() to get the result of the operation.
 *
 * See wpa_interface_org_freedesktop_dbus_properties_call_get_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_org_freedesktop_dbus_properties_call_get (
    wpainterfaceOrgFreedesktopDBusProperties *proxy,
    const gchar *arg_interface,
    const gchar *arg_propname,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Get",
    g_variant_new ("(ss)",
                   arg_interface,
                   arg_propname),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_call_get_finish:
 * @proxy: A #wpainterfaceOrgFreedesktopDBusPropertiesProxy.
 * @out_value: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_org_freedesktop_dbus_properties_call_get().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_org_freedesktop_dbus_properties_call_get().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_org_freedesktop_dbus_properties_call_get_finish (
    wpainterfaceOrgFreedesktopDBusProperties *proxy,
    GVariant **out_value,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@v)",
                 out_value);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_call_get_sync:
 * @proxy: A #wpainterfaceOrgFreedesktopDBusPropertiesProxy.
 * @arg_interface: Argument to pass with the method invocation.
 * @arg_propname: Argument to pass with the method invocation.
 * @out_value: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus-Properties.Get">Get()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_org_freedesktop_dbus_properties_call_get() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_org_freedesktop_dbus_properties_call_get_sync (
    wpainterfaceOrgFreedesktopDBusProperties *proxy,
    const gchar *arg_interface,
    const gchar *arg_propname,
    GVariant **out_value,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Get",
    g_variant_new ("(ss)",
                   arg_interface,
                   arg_propname),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@v)",
                 out_value);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_call_get_all:
 * @proxy: A #wpainterfaceOrgFreedesktopDBusPropertiesProxy.
 * @arg_interface: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus-Properties.GetAll">GetAll()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_org_freedesktop_dbus_properties_call_get_all_finish() to get the result of the operation.
 *
 * See wpa_interface_org_freedesktop_dbus_properties_call_get_all_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_org_freedesktop_dbus_properties_call_get_all (
    wpainterfaceOrgFreedesktopDBusProperties *proxy,
    const gchar *arg_interface,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetAll",
    g_variant_new ("(s)",
                   arg_interface),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_call_get_all_finish:
 * @proxy: A #wpainterfaceOrgFreedesktopDBusPropertiesProxy.
 * @out_props: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_org_freedesktop_dbus_properties_call_get_all().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_org_freedesktop_dbus_properties_call_get_all().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_org_freedesktop_dbus_properties_call_get_all_finish (
    wpainterfaceOrgFreedesktopDBusProperties *proxy,
    GVariant **out_props,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@a{sv})",
                 out_props);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_call_get_all_sync:
 * @proxy: A #wpainterfaceOrgFreedesktopDBusPropertiesProxy.
 * @arg_interface: Argument to pass with the method invocation.
 * @out_props: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus-Properties.GetAll">GetAll()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_org_freedesktop_dbus_properties_call_get_all() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_org_freedesktop_dbus_properties_call_get_all_sync (
    wpainterfaceOrgFreedesktopDBusProperties *proxy,
    const gchar *arg_interface,
    GVariant **out_props,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetAll",
    g_variant_new ("(s)",
                   arg_interface),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@a{sv})",
                 out_props);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_call_set:
 * @proxy: A #wpainterfaceOrgFreedesktopDBusPropertiesProxy.
 * @arg_interface: Argument to pass with the method invocation.
 * @arg_propname: Argument to pass with the method invocation.
 * @arg_value: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus-Properties.Set">Set()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_org_freedesktop_dbus_properties_call_set_finish() to get the result of the operation.
 *
 * See wpa_interface_org_freedesktop_dbus_properties_call_set_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_org_freedesktop_dbus_properties_call_set (
    wpainterfaceOrgFreedesktopDBusProperties *proxy,
    const gchar *arg_interface,
    const gchar *arg_propname,
    GVariant *arg_value,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Set",
    g_variant_new ("(ss@v)",
                   arg_interface,
                   arg_propname,
                   arg_value),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_call_set_finish:
 * @proxy: A #wpainterfaceOrgFreedesktopDBusPropertiesProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_org_freedesktop_dbus_properties_call_set().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_org_freedesktop_dbus_properties_call_set().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_org_freedesktop_dbus_properties_call_set_finish (
    wpainterfaceOrgFreedesktopDBusProperties *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_call_set_sync:
 * @proxy: A #wpainterfaceOrgFreedesktopDBusPropertiesProxy.
 * @arg_interface: Argument to pass with the method invocation.
 * @arg_propname: Argument to pass with the method invocation.
 * @arg_value: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-freedesktop-DBus-Properties.Set">Set()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_org_freedesktop_dbus_properties_call_set() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_org_freedesktop_dbus_properties_call_set_sync (
    wpainterfaceOrgFreedesktopDBusProperties *proxy,
    const gchar *arg_interface,
    const gchar *arg_propname,
    GVariant *arg_value,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Set",
    g_variant_new ("(ss@v)",
                   arg_interface,
                   arg_propname,
                   arg_value),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_complete_get:
 * @object: A #wpainterfaceOrgFreedesktopDBusProperties.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @value: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus-Properties.Get">Get()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_org_freedesktop_dbus_properties_complete_get (
    wpainterfaceOrgFreedesktopDBusProperties *object,
    GDBusMethodInvocation *invocation,
    GVariant *value)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(@v)",
                   value));
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_complete_get_all:
 * @object: A #wpainterfaceOrgFreedesktopDBusProperties.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @props: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus-Properties.GetAll">GetAll()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_org_freedesktop_dbus_properties_complete_get_all (
    wpainterfaceOrgFreedesktopDBusProperties *object,
    GDBusMethodInvocation *invocation,
    GVariant *props)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(@a{sv})",
                   props));
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_complete_set:
 * @object: A #wpainterfaceOrgFreedesktopDBusProperties.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-freedesktop-DBus-Properties.Set">Set()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_org_freedesktop_dbus_properties_complete_set (
    wpainterfaceOrgFreedesktopDBusProperties *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * wpainterfaceOrgFreedesktopDBusPropertiesProxy:
 *
 * The #wpainterfaceOrgFreedesktopDBusPropertiesProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * wpainterfaceOrgFreedesktopDBusPropertiesProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #wpainterfaceOrgFreedesktopDBusPropertiesProxy.
 */

struct _wpainterfaceOrgFreedesktopDBusPropertiesProxyPrivate
{
  GData *qdata;
};

static void wpa_interface_org_freedesktop_dbus_properties_proxy_iface_init (wpainterfaceOrgFreedesktopDBusPropertiesIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (wpainterfaceOrgFreedesktopDBusPropertiesProxy, wpa_interface_org_freedesktop_dbus_properties_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (wpainterfaceOrgFreedesktopDBusPropertiesProxy)
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES, wpa_interface_org_freedesktop_dbus_properties_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (wpainterfaceOrgFreedesktopDBusPropertiesProxy, wpa_interface_org_freedesktop_dbus_properties_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES, wpa_interface_org_freedesktop_dbus_properties_proxy_iface_init));

#endif
static void
wpa_interface_org_freedesktop_dbus_properties_proxy_finalize (GObject *object)
{
  wpainterfaceOrgFreedesktopDBusPropertiesProxy *proxy = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_PROPERTIES_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (wpa_interface_org_freedesktop_dbus_properties_proxy_parent_class)->finalize (object);
}

static void
wpa_interface_org_freedesktop_dbus_properties_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
wpa_interface_org_freedesktop_dbus_properties_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
}

static void
wpa_interface_org_freedesktop_dbus_properties_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_wpa_interface_org_freedesktop_dbus_properties_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
wpa_interface_org_freedesktop_dbus_properties_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  wpainterfaceOrgFreedesktopDBusPropertiesProxy *proxy = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_PROPERTIES_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_org_freedesktop_dbus_properties_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_org_freedesktop_dbus_properties_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
wpa_interface_org_freedesktop_dbus_properties_proxy_init (wpainterfaceOrgFreedesktopDBusPropertiesProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = wpa_interface_org_freedesktop_dbus_properties_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES_PROXY, wpainterfaceOrgFreedesktopDBusPropertiesProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), wpa_interface_org_freedesktop_dbus_properties_interface_info ());
}

static void
wpa_interface_org_freedesktop_dbus_properties_proxy_class_init (wpainterfaceOrgFreedesktopDBusPropertiesProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = wpa_interface_org_freedesktop_dbus_properties_proxy_finalize;
  gobject_class->get_property = wpa_interface_org_freedesktop_dbus_properties_proxy_get_property;
  gobject_class->set_property = wpa_interface_org_freedesktop_dbus_properties_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = wpa_interface_org_freedesktop_dbus_properties_proxy_g_signal;
  proxy_class->g_properties_changed = wpa_interface_org_freedesktop_dbus_properties_proxy_g_properties_changed;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (wpainterfaceOrgFreedesktopDBusPropertiesProxyPrivate));
#endif
}

static void
wpa_interface_org_freedesktop_dbus_properties_proxy_iface_init (wpainterfaceOrgFreedesktopDBusPropertiesIface *iface)
{
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus-Properties.top_of_page">org.freedesktop.DBus.Properties</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_org_freedesktop_dbus_properties_proxy_new_finish() to get the result of the operation.
 *
 * See wpa_interface_org_freedesktop_dbus_properties_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
wpa_interface_org_freedesktop_dbus_properties_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.DBus.Properties", NULL);
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_org_freedesktop_dbus_properties_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with wpa_interface_org_freedesktop_dbus_properties_proxy_new().
 *
 * Returns: (transfer full) (type wpainterfaceOrgFreedesktopDBusPropertiesProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceOrgFreedesktopDBusProperties *
wpa_interface_org_freedesktop_dbus_properties_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_PROPERTIES (ret);
  else
    return NULL;
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus-Properties.top_of_page">org.freedesktop.DBus.Properties</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_org_freedesktop_dbus_properties_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type wpainterfaceOrgFreedesktopDBusPropertiesProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceOrgFreedesktopDBusProperties *
wpa_interface_org_freedesktop_dbus_properties_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.freedesktop.DBus.Properties", NULL);
  if (ret != NULL)
    return WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_PROPERTIES (ret);
  else
    return NULL;
}


/**
 * wpa_interface_org_freedesktop_dbus_properties_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like wpa_interface_org_freedesktop_dbus_properties_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_org_freedesktop_dbus_properties_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See wpa_interface_org_freedesktop_dbus_properties_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
wpa_interface_org_freedesktop_dbus_properties_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.DBus.Properties", NULL);
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_org_freedesktop_dbus_properties_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with wpa_interface_org_freedesktop_dbus_properties_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type wpainterfaceOrgFreedesktopDBusPropertiesProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceOrgFreedesktopDBusProperties *
wpa_interface_org_freedesktop_dbus_properties_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_PROPERTIES (ret);
  else
    return NULL;
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like wpa_interface_org_freedesktop_dbus_properties_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_org_freedesktop_dbus_properties_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type wpainterfaceOrgFreedesktopDBusPropertiesProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceOrgFreedesktopDBusProperties *
wpa_interface_org_freedesktop_dbus_properties_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.freedesktop.DBus.Properties", NULL);
  if (ret != NULL)
    return WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_PROPERTIES (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * wpainterfaceOrgFreedesktopDBusPropertiesSkeleton:
 *
 * The #wpainterfaceOrgFreedesktopDBusPropertiesSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * wpainterfaceOrgFreedesktopDBusPropertiesSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #wpainterfaceOrgFreedesktopDBusPropertiesSkeleton.
 */

struct _wpainterfaceOrgFreedesktopDBusPropertiesSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_wpa_interface_org_freedesktop_dbus_properties_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  wpainterfaceOrgFreedesktopDBusPropertiesSkeleton *skeleton = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_PROPERTIES_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_wpa_interface_org_freedesktop_dbus_properties_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  wpainterfaceOrgFreedesktopDBusPropertiesSkeleton *skeleton = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_PROPERTIES_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_org_freedesktop_dbus_properties_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_wpa_interface_org_freedesktop_dbus_properties_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  wpainterfaceOrgFreedesktopDBusPropertiesSkeleton *skeleton = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_PROPERTIES_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_org_freedesktop_dbus_properties_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _wpa_interface_org_freedesktop_dbus_properties_skeleton_vtable =
{
  _wpa_interface_org_freedesktop_dbus_properties_skeleton_handle_method_call,
  _wpa_interface_org_freedesktop_dbus_properties_skeleton_handle_get_property,
  _wpa_interface_org_freedesktop_dbus_properties_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
wpa_interface_org_freedesktop_dbus_properties_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return wpa_interface_org_freedesktop_dbus_properties_interface_info ();
}

static GDBusInterfaceVTable *
wpa_interface_org_freedesktop_dbus_properties_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_wpa_interface_org_freedesktop_dbus_properties_skeleton_vtable;
}

static GVariant *
wpa_interface_org_freedesktop_dbus_properties_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  wpainterfaceOrgFreedesktopDBusPropertiesSkeleton *skeleton = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_PROPERTIES_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_wpa_interface_org_freedesktop_dbus_properties_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _wpa_interface_org_freedesktop_dbus_properties_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _wpa_interface_org_freedesktop_dbus_properties_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _wpa_interface_org_freedesktop_dbus_properties_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.freedesktop.DBus.Properties", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
wpa_interface_org_freedesktop_dbus_properties_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void wpa_interface_org_freedesktop_dbus_properties_skeleton_iface_init (wpainterfaceOrgFreedesktopDBusPropertiesIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (wpainterfaceOrgFreedesktopDBusPropertiesSkeleton, wpa_interface_org_freedesktop_dbus_properties_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (wpainterfaceOrgFreedesktopDBusPropertiesSkeleton)
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES, wpa_interface_org_freedesktop_dbus_properties_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (wpainterfaceOrgFreedesktopDBusPropertiesSkeleton, wpa_interface_org_freedesktop_dbus_properties_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES, wpa_interface_org_freedesktop_dbus_properties_skeleton_iface_init));

#endif
static void
wpa_interface_org_freedesktop_dbus_properties_skeleton_finalize (GObject *object)
{
  wpainterfaceOrgFreedesktopDBusPropertiesSkeleton *skeleton = WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_PROPERTIES_SKELETON (object);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (wpa_interface_org_freedesktop_dbus_properties_skeleton_parent_class)->finalize (object);
}

static void
wpa_interface_org_freedesktop_dbus_properties_skeleton_init (wpainterfaceOrgFreedesktopDBusPropertiesSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = wpa_interface_org_freedesktop_dbus_properties_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES_SKELETON, wpainterfaceOrgFreedesktopDBusPropertiesSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
}

static void
wpa_interface_org_freedesktop_dbus_properties_skeleton_class_init (wpainterfaceOrgFreedesktopDBusPropertiesSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = wpa_interface_org_freedesktop_dbus_properties_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = wpa_interface_org_freedesktop_dbus_properties_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = wpa_interface_org_freedesktop_dbus_properties_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = wpa_interface_org_freedesktop_dbus_properties_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = wpa_interface_org_freedesktop_dbus_properties_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (wpainterfaceOrgFreedesktopDBusPropertiesSkeletonPrivate));
#endif
}

static void
wpa_interface_org_freedesktop_dbus_properties_skeleton_iface_init (wpainterfaceOrgFreedesktopDBusPropertiesIface *iface)
{
}

/**
 * wpa_interface_org_freedesktop_dbus_properties_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-freedesktop-DBus-Properties.top_of_page">org.freedesktop.DBus.Properties</link>.
 *
 * Returns: (transfer full) (type wpainterfaceOrgFreedesktopDBusPropertiesSkeleton): The skeleton object.
 */
wpainterfaceOrgFreedesktopDBusProperties *
wpa_interface_org_freedesktop_dbus_properties_skeleton_new (void)
{
  return WPA_INTERFACE_ORG_FREEDESKTOP_DBUS_PROPERTIES (g_object_new (WPA_INTERFACE_TYPE_ORG_FREEDESKTOP_DBUS_PROPERTIES_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface fi.w1.wpa_supplicant1.Interface
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:wpainterfaceFiW1Wpa_supplicant1Interface
 * @title: wpainterfaceFiW1Wpa_supplicant1Interface
 * @short_description: Generated C code for the fi.w1.wpa_supplicant1.Interface D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface.top_of_page">fi.w1.wpa_supplicant1.Interface</link> D-Bus interface in C.
 */

/* ---- Introspection data for fi.w1.wpa_supplicant1.Interface ---- */

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_scan_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_scan_IN_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_scan_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_scan =
{
  {
    -1,
    (gchar *) "Scan",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_scan_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-scan",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_signal_poll_OUT_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_signal_poll_OUT_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_signal_poll_OUT_ARG_args,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_signal_poll =
{
  {
    -1,
    (gchar *) "SignalPoll",
    NULL,
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_signal_poll_OUT_ARG_pointers,
    NULL
  },
  "handle-signal-poll",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_disconnect =
{
  {
    -1,
    (gchar *) "Disconnect",
    NULL,
    NULL,
    NULL
  },
  "handle-disconnect",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_network_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_network_IN_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_network_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_network_OUT_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_network_OUT_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_network_OUT_ARG_path,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_network =
{
  {
    -1,
    (gchar *) "AddNetwork",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_network_IN_ARG_pointers,
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_network_OUT_ARG_pointers,
    NULL
  },
  "handle-add-network",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_reassociate =
{
  {
    -1,
    (gchar *) "Reassociate",
    NULL,
    NULL,
    NULL
  },
  "handle-reassociate",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_reattach =
{
  {
    -1,
    (gchar *) "Reattach",
    NULL,
    NULL,
    NULL
  },
  "handle-reattach",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_reconnect =
{
  {
    -1,
    (gchar *) "Reconnect",
    NULL,
    NULL,
    NULL
  },
  "handle-reconnect",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_network_IN_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_network_IN_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_network_IN_ARG_path,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_network =
{
  {
    -1,
    (gchar *) "RemoveNetwork",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_network_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-remove-network",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_all_networks =
{
  {
    -1,
    (gchar *) "RemoveAllNetworks",
    NULL,
    NULL,
    NULL
  },
  "handle-remove-all-networks",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_select_network_IN_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_select_network_IN_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_select_network_IN_ARG_path,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_select_network =
{
  {
    -1,
    (gchar *) "SelectNetwork",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_select_network_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-select-network",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_network_reply_IN_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_network_reply_IN_ARG_field =
{
  {
    -1,
    (gchar *) "field",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_network_reply_IN_ARG_value =
{
  {
    -1,
    (gchar *) "value",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_network_reply_IN_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_network_reply_IN_ARG_path,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_network_reply_IN_ARG_field,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_network_reply_IN_ARG_value,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_network_reply =
{
  {
    -1,
    (gchar *) "NetworkReply",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_network_reply_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-network-reply",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_blob_IN_ARG_name =
{
  {
    -1,
    (gchar *) "name",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_blob_IN_ARG_data =
{
  {
    -1,
    (gchar *) "data",
    (gchar *) "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_blob_IN_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_blob_IN_ARG_name,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_blob_IN_ARG_data,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_blob =
{
  {
    -1,
    (gchar *) "AddBlob",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_blob_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-add-blob",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_get_blob_IN_ARG_name =
{
  {
    -1,
    (gchar *) "name",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_get_blob_IN_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_get_blob_IN_ARG_name,
  NULL
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_get_blob_OUT_ARG_data =
{
  {
    -1,
    (gchar *) "data",
    (gchar *) "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_get_blob_OUT_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_get_blob_OUT_ARG_data,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_get_blob =
{
  {
    -1,
    (gchar *) "GetBlob",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_get_blob_IN_ARG_pointers,
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_get_blob_OUT_ARG_pointers,
    NULL
  },
  "handle-get-blob",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_blob_IN_ARG_name =
{
  {
    -1,
    (gchar *) "name",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_blob_IN_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_blob_IN_ARG_name,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_blob =
{
  {
    -1,
    (gchar *) "RemoveBlob",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_blob_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-remove-blob",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_set_pkcs11_engine_and_module_path_IN_ARG_pkcs11_engine_path =
{
  {
    -1,
    (gchar *) "pkcs11_engine_path",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_set_pkcs11_engine_and_module_path_IN_ARG_pkcs11_module_path =
{
  {
    -1,
    (gchar *) "pkcs11_module_path",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_set_pkcs11_engine_and_module_path_IN_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_set_pkcs11_engine_and_module_path_IN_ARG_pkcs11_engine_path,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_set_pkcs11_engine_and_module_path_IN_ARG_pkcs11_module_path,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_set_pkcs11_engine_and_module_path =
{
  {
    -1,
    (gchar *) "SetPKCS11EngineAndModulePath",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_set_pkcs11_engine_and_module_path_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-set-pkcs11-engine-and-module-path",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_flush_bss_IN_ARG_age =
{
  {
    -1,
    (gchar *) "age",
    (gchar *) "u",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_flush_bss_IN_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_flush_bss_IN_ARG_age,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_flush_bss =
{
  {
    -1,
    (gchar *) "FlushBSS",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_flush_bss_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-flush-bss",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_subscribe_probe_req =
{
  {
    -1,
    (gchar *) "SubscribeProbeReq",
    NULL,
    NULL,
    NULL
  },
  "handle-subscribe-probe-req",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_unsubscribe_probe_req =
{
  {
    -1,
    (gchar *) "UnsubscribeProbeReq",
    NULL,
    NULL,
    NULL
  },
  "handle-unsubscribe-probe-req",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_eaplogoff =
{
  {
    -1,
    (gchar *) "EAPLogoff",
    NULL,
    NULL,
    NULL
  },
  "handle-eaplogoff",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_eaplogon =
{
  {
    -1,
    (gchar *) "EAPLogon",
    NULL,
    NULL,
    NULL
  },
  "handle-eaplogon",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_add_IN_ARG_frame_id =
{
  {
    -1,
    (gchar *) "frame_id",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_add_IN_ARG_ielems =
{
  {
    -1,
    (gchar *) "ielems",
    (gchar *) "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_add_IN_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_add_IN_ARG_frame_id,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_add_IN_ARG_ielems,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_add =
{
  {
    -1,
    (gchar *) "VendorElemAdd",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_add_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-vendor-elem-add",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_get_IN_ARG_frame_id =
{
  {
    -1,
    (gchar *) "frame_id",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_get_IN_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_get_IN_ARG_frame_id,
  NULL
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_get_OUT_ARG_ielems =
{
  {
    -1,
    (gchar *) "ielems",
    (gchar *) "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_get_OUT_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_get_OUT_ARG_ielems,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_get =
{
  {
    -1,
    (gchar *) "VendorElemGet",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_get_IN_ARG_pointers,
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_get_OUT_ARG_pointers,
    NULL
  },
  "handle-vendor-elem-get",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_rem_IN_ARG_frame_id =
{
  {
    -1,
    (gchar *) "frame_id",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_rem_IN_ARG_ielems =
{
  {
    -1,
    (gchar *) "ielems",
    (gchar *) "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_rem_IN_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_rem_IN_ARG_frame_id,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_rem_IN_ARG_ielems,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_rem =
{
  {
    -1,
    (gchar *) "VendorElemRem",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_rem_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-vendor-elem-rem",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_save_config =
{
  {
    -1,
    (gchar *) "SaveConfig",
    NULL,
    NULL,
    NULL
  },
  "handle-save-config",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_abort_scan =
{
  {
    -1,
    (gchar *) "AbortScan",
    NULL,
    NULL,
    NULL
  },
  "handle-abort-scan",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_scan,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_signal_poll,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_disconnect,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_network,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_reassociate,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_reattach,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_reconnect,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_network,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_all_networks,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_select_network,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_network_reply,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_add_blob,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_get_blob,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_remove_blob,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_set_pkcs11_engine_and_module_path,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_flush_bss,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_subscribe_probe_req,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_unsubscribe_probe_req,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_eaplogoff,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_eaplogon,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_add,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_get,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_vendor_elem_rem,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_save_config,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_abort_scan,
  NULL
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_scan_done_ARG_success =
{
  {
    -1,
    (gchar *) "success",
    (gchar *) "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_scan_done_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_scan_done_ARG_success,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_scan_done =
{
  {
    -1,
    (gchar *) "ScanDone",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_scan_done_ARG_pointers,
    NULL
  },
  "scan-done"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssadded_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssadded_ARG_properties =
{
  {
    -1,
    (gchar *) "properties",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssadded_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssadded_ARG_path,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssadded_ARG_properties,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssadded =
{
  {
    -1,
    (gchar *) "BSSAdded",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssadded_ARG_pointers,
    NULL
  },
  "bssadded"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssremoved_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssremoved_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssremoved_ARG_path,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssremoved =
{
  {
    -1,
    (gchar *) "BSSRemoved",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssremoved_ARG_pointers,
    NULL
  },
  "bssremoved"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_blob_added_ARG_name =
{
  {
    -1,
    (gchar *) "name",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_blob_added_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_blob_added_ARG_name,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_blob_added =
{
  {
    -1,
    (gchar *) "BlobAdded",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_blob_added_ARG_pointers,
    NULL
  },
  "blob-added"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_blob_removed_ARG_name =
{
  {
    -1,
    (gchar *) "name",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_blob_removed_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_blob_removed_ARG_name,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_blob_removed =
{
  {
    -1,
    (gchar *) "BlobRemoved",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_blob_removed_ARG_pointers,
    NULL
  },
  "blob-removed"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_added_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_added_ARG_properties =
{
  {
    -1,
    (gchar *) "properties",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_added_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_added_ARG_path,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_added_ARG_properties,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_added =
{
  {
    -1,
    (gchar *) "NetworkAdded",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_added_ARG_pointers,
    NULL
  },
  "network-added"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_removed_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_removed_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_removed_ARG_path,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_removed =
{
  {
    -1,
    (gchar *) "NetworkRemoved",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_removed_ARG_pointers,
    NULL
  },
  "network-removed"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_selected_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_selected_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_selected_ARG_path,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_selected =
{
  {
    -1,
    (gchar *) "NetworkSelected",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_selected_ARG_pointers,
    NULL
  },
  "network-selected"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_properties_changed_ARG_properties =
{
  {
    -1,
    (gchar *) "properties",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_properties_changed_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_properties_changed_ARG_properties,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_properties_changed =
{
  {
    -1,
    (gchar *) "PropertiesChanged",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_properties_changed_ARG_pointers,
    NULL
  },
  "properties-changed"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_probe_request_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_probe_request_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_probe_request_ARG_args,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_probe_request =
{
  {
    -1,
    (gchar *) "ProbeRequest",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_probe_request_ARG_pointers,
    NULL
  },
  "probe-request"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_certification_ARG_certification =
{
  {
    -1,
    (gchar *) "certification",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_certification_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_certification_ARG_certification,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_certification =
{
  {
    -1,
    (gchar *) "Certification",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_certification_ARG_pointers,
    NULL
  },
  "certification"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_eap_ARG_status =
{
  {
    -1,
    (gchar *) "status",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_eap_ARG_parameter =
{
  {
    -1,
    (gchar *) "parameter",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_eap_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_eap_ARG_status,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_eap_ARG_parameter,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_eap =
{
  {
    -1,
    (gchar *) "EAP",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_eap_ARG_pointers,
    NULL
  },
  "eap"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_sta_authorized_ARG_name =
{
  {
    -1,
    (gchar *) "name",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_sta_authorized_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_sta_authorized_ARG_name,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_sta_authorized =
{
  {
    -1,
    (gchar *) "StaAuthorized",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_sta_authorized_ARG_pointers,
    NULL
  },
  "sta-authorized"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_sta_deauthorized_ARG_name =
{
  {
    -1,
    (gchar *) "name",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_sta_deauthorized_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_sta_deauthorized_ARG_name,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_sta_deauthorized =
{
  {
    -1,
    (gchar *) "StaDeauthorized",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_sta_deauthorized_ARG_pointers,
    NULL
  },
  "sta-deauthorized"
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_request_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_request_ARG_field =
{
  {
    -1,
    (gchar *) "field",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_request_ARG_text =
{
  {
    -1,
    (gchar *) "text",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_request_ARG_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_request_ARG_path,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_request_ARG_field,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_request_ARG_text,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_request =
{
  {
    -1,
    (gchar *) "NetworkRequest",
    (GDBusArgInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_request_ARG_pointers,
    NULL
  },
  "network-request"
};

static const _ExtendedGDBusSignalInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_scan_done,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssadded,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_bssremoved,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_blob_added,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_blob_removed,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_added,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_removed,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_selected,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_properties_changed,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_probe_request,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_certification,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_eap,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_sta_authorized,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_sta_deauthorized,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_network_request,
  NULL
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_capabilities =
{
  {
    -1,
    (gchar *) "Capabilities",
    (gchar *) "a{sv}",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "capabilities",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_state =
{
  {
    -1,
    (gchar *) "State",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "state",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_scanning =
{
  {
    -1,
    (gchar *) "Scanning",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "scanning",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ap_scan =
{
  {
    -1,
    (gchar *) "ApScan",
    (gchar *) "u",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ap-scan",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_bssexpire_age =
{
  {
    -1,
    (gchar *) "BSSExpireAge",
    (gchar *) "u",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "bssexpire-age",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_bssexpire_count =
{
  {
    -1,
    (gchar *) "BSSExpireCount",
    (gchar *) "u",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "bssexpire-count",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_country =
{
  {
    -1,
    (gchar *) "Country",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "country",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ifname =
{
  {
    -1,
    (gchar *) "Ifname",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "ifname",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_driver =
{
  {
    -1,
    (gchar *) "Driver",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "driver",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_bridge_ifname =
{
  {
    -1,
    (gchar *) "BridgeIfname",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "bridge-ifname",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_config_file =
{
  {
    -1,
    (gchar *) "ConfigFile",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "config-file",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_current_bss =
{
  {
    -1,
    (gchar *) "CurrentBSS",
    (gchar *) "o",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "current-bss",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_current_network =
{
  {
    -1,
    (gchar *) "CurrentNetwork",
    (gchar *) "o",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "current-network",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_current_auth_mode =
{
  {
    -1,
    (gchar *) "CurrentAuthMode",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "current-auth-mode",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_blobs =
{
  {
    -1,
    (gchar *) "Blobs",
    (gchar *) "a{say}",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "blobs",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_bsss =
{
  {
    -1,
    (gchar *) "BSSs",
    (gchar *) "ao",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "bsss",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_networks =
{
  {
    -1,
    (gchar *) "Networks",
    (gchar *) "ao",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "networks",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_fast_reauth =
{
  {
    -1,
    (gchar *) "FastReauth",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "fast-reauth",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_scan_interval =
{
  {
    -1,
    (gchar *) "ScanInterval",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "scan-interval",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pkcs11_engine_path =
{
  {
    -1,
    (gchar *) "PKCS11EnginePath",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "pkcs11-engine-path",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pkcs11_module_path =
{
  {
    -1,
    (gchar *) "PKCS11ModulePath",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "pkcs11-module-path",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_disconnect_reason =
{
  {
    -1,
    (gchar *) "DisconnectReason",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "disconnect-reason",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_assoc_status_code =
{
  {
    -1,
    (gchar *) "AssocStatusCode",
    (gchar *) "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "assoc-status-code",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ctrl_interface =
{
  {
    -1,
    (gchar *) "CtrlInterface",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ctrl-interface",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ctrl_interface_group =
{
  {
    -1,
    (gchar *) "CtrlInterfaceGroup",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ctrl-interface-group",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_eapol_version =
{
  {
    -1,
    (gchar *) "EapolVersion",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "eapol-version",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_bgscan =
{
  {
    -1,
    (gchar *) "Bgscan",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "bgscan",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_disable_scan_offload =
{
  {
    -1,
    (gchar *) "DisableScanOffload",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "disable-scan-offload",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_opensc_engine_path =
{
  {
    -1,
    (gchar *) "OpenscEnginePath",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "opensc-engine-path",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_openssl_ciphers =
{
  {
    -1,
    (gchar *) "OpensslCiphers",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "openssl-ciphers",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pcsc_reader =
{
  {
    -1,
    (gchar *) "PcscReader",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "pcsc-reader",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pcsc_pin =
{
  {
    -1,
    (gchar *) "PcscPin",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "pcsc-pin",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_external_sim =
{
  {
    -1,
    (gchar *) "ExternalSim",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "external-sim",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_driver_param =
{
  {
    -1,
    (gchar *) "DriverParam",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "driver-param",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_dot11_rsnaconfig_pmklifetime =
{
  {
    -1,
    (gchar *) "Dot11RSNAConfigPMKLifetime",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "dot11-rsnaconfig-pmklifetime",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_dot11_rsnaconfig_pmkreauth_threshold =
{
  {
    -1,
    (gchar *) "Dot11RSNAConfigPMKReauthThreshold",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "dot11-rsnaconfig-pmkreauth-threshold",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_dot11_rsnaconfig_satimeout =
{
  {
    -1,
    (gchar *) "Dot11RSNAConfigSATimeout",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "dot11-rsnaconfig-satimeout",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_update_config =
{
  {
    -1,
    (gchar *) "UpdateConfig",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "update-config",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_uuid =
{
  {
    -1,
    (gchar *) "Uuid",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "uuid",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_auto_uuid =
{
  {
    -1,
    (gchar *) "AutoUuid",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "auto-uuid",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_device_name =
{
  {
    -1,
    (gchar *) "DeviceName",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "device-name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_manufacturer =
{
  {
    -1,
    (gchar *) "Manufacturer",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "manufacturer",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_model_name =
{
  {
    -1,
    (gchar *) "ModelName",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "model-name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_model_number =
{
  {
    -1,
    (gchar *) "ModelNumber",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "model-number",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_serial_number =
{
  {
    -1,
    (gchar *) "SerialNumber",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "serial-number",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_device_type =
{
  {
    -1,
    (gchar *) "DeviceType",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "device-type",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_os_version =
{
  {
    -1,
    (gchar *) "OsVersion",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "os-version",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_config_methods =
{
  {
    -1,
    (gchar *) "ConfigMethods",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "config-methods",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_cred_processing =
{
  {
    -1,
    (gchar *) "WpsCredProcessing",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "wps-cred-processing",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_vendor_ext_m1 =
{
  {
    -1,
    (gchar *) "WpsVendorExtM1",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "wps-vendor-ext-m1",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_sec_device_type =
{
  {
    -1,
    (gchar *) "SecDeviceType",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "sec-device-type",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_listen_reg_class =
{
  {
    -1,
    (gchar *) "P2pListenRegClass",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-listen-reg-class",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_listen_channel =
{
  {
    -1,
    (gchar *) "P2pListenChannel",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-listen-channel",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_oper_reg_class =
{
  {
    -1,
    (gchar *) "P2pOperRegClass",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-oper-reg-class",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_oper_channel =
{
  {
    -1,
    (gchar *) "P2pOperChannel",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-oper-channel",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_go_intent =
{
  {
    -1,
    (gchar *) "P2pGoIntent",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-go-intent",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_ssid_postfix =
{
  {
    -1,
    (gchar *) "P2pSsidPostfix",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-ssid-postfix",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_persistent_reconnect =
{
  {
    -1,
    (gchar *) "PersistentReconnect",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "persistent-reconnect",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_intra_bss =
{
  {
    -1,
    (gchar *) "P2pIntraBss",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-intra-bss",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_group_idle =
{
  {
    -1,
    (gchar *) "P2pGroupIdle",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-group-idle",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_go_freq_change_policy =
{
  {
    -1,
    (gchar *) "P2pGoFreqChangePolicy",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-go-freq-change-policy",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_passphrase_len =
{
  {
    -1,
    (gchar *) "P2pPassphraseLen",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-passphrase-len",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_pref_chan =
{
  {
    -1,
    (gchar *) "P2pPrefChan",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-pref-chan",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_no_go_freq =
{
  {
    -1,
    (gchar *) "P2pNoGoFreq",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-no-go-freq",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_add_cli_chan =
{
  {
    -1,
    (gchar *) "P2pAddCliChan",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-add-cli-chan",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_optimize_listen_chan =
{
  {
    -1,
    (gchar *) "P2pOptimizeListenChan",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-optimize-listen-chan",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_go_ht40 =
{
  {
    -1,
    (gchar *) "P2pGoHt40",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-go-ht40",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_go_vht =
{
  {
    -1,
    (gchar *) "P2pGoVht",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-go-vht",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_disabled =
{
  {
    -1,
    (gchar *) "P2pDisabled",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-disabled",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_go_ctwindow =
{
  {
    -1,
    (gchar *) "P2pGoCtwindow",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-go-ctwindow",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_no_group_iface =
{
  {
    -1,
    (gchar *) "P2pNoGroupIface",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-no-group-iface",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_ignore_shared_freq =
{
  {
    -1,
    (gchar *) "P2pIgnoreSharedFreq",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-ignore-shared-freq",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ip_addr_go =
{
  {
    -1,
    (gchar *) "IpAddrGo",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ip-addr-go",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ip_addr_mask =
{
  {
    -1,
    (gchar *) "IpAddrMask",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ip-addr-mask",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ip_addr_start =
{
  {
    -1,
    (gchar *) "IpAddrStart",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ip-addr-start",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ip_addr_end =
{
  {
    -1,
    (gchar *) "IpAddrEnd",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ip-addr-end",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_cli_probe =
{
  {
    -1,
    (gchar *) "P2pCliProbe",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-cli-probe",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_bss_max_count =
{
  {
    -1,
    (gchar *) "BssMaxCount",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "bss-max-count",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_filter_ssids =
{
  {
    -1,
    (gchar *) "FilterSsids",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "filter-ssids",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_filter_rssi =
{
  {
    -1,
    (gchar *) "FilterRssi",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "filter-rssi",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_max_num_sta =
{
  {
    -1,
    (gchar *) "MaxNumSta",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "max-num-sta",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_disassoc_low_ack =
{
  {
    -1,
    (gchar *) "DisassocLowAck",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "disassoc-low-ack",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_interworking =
{
  {
    -1,
    (gchar *) "Interworking",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "interworking",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_hessid =
{
  {
    -1,
    (gchar *) "Hessid",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "hessid",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_access_network_type =
{
  {
    -1,
    (gchar *) "AccessNetworkType",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "access-network-type",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_go_interworking =
{
  {
    -1,
    (gchar *) "GoInterworking",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "go-interworking",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_go_access_network_type =
{
  {
    -1,
    (gchar *) "GoAccessNetworkType",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "go-access-network-type",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_go_internet =
{
  {
    -1,
    (gchar *) "GoInternet",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "go-internet",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_go_venue_group =
{
  {
    -1,
    (gchar *) "GoVenueGroup",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "go-venue-group",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_go_venue_type =
{
  {
    -1,
    (gchar *) "GoVenueType",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "go-venue-type",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pbc_in_m1 =
{
  {
    -1,
    (gchar *) "PbcInM1",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "pbc-in-m1",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_autoscan =
{
  {
    -1,
    (gchar *) "Autoscan",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "autoscan",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_nfc_dev_pw_id =
{
  {
    -1,
    (gchar *) "WpsNfcDevPwId",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "wps-nfc-dev-pw-id",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_nfc_dh_pubkey =
{
  {
    -1,
    (gchar *) "WpsNfcDhPubkey",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "wps-nfc-dh-pubkey",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_nfc_dh_privkey =
{
  {
    -1,
    (gchar *) "WpsNfcDhPrivkey",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "wps-nfc-dh-privkey",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_nfc_dev_pw =
{
  {
    -1,
    (gchar *) "WpsNfcDevPw",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "wps-nfc-dev-pw",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ext_password_backend =
{
  {
    -1,
    (gchar *) "ExtPasswordBackend",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ext-password-backend",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_go_max_inactivity =
{
  {
    -1,
    (gchar *) "P2pGoMaxInactivity",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-go-max-inactivity",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_auto_interworking =
{
  {
    -1,
    (gchar *) "AutoInterworking",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "auto-interworking",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_okc =
{
  {
    -1,
    (gchar *) "Okc",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "okc",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pmf =
{
  {
    -1,
    (gchar *) "Pmf",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "pmf",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_sae_groups =
{
  {
    -1,
    (gchar *) "SaeGroups",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "sae-groups",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_dtim_period =
{
  {
    -1,
    (gchar *) "DtimPeriod",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "dtim-period",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_beacon_int =
{
  {
    -1,
    (gchar *) "BeaconInt",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "beacon-int",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ap_vendor_elements =
{
  {
    -1,
    (gchar *) "ApVendorElements",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ap-vendor-elements",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ignore_old_scan_res =
{
  {
    -1,
    (gchar *) "IgnoreOldScanRes",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ignore-old-scan-res",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_freq_list =
{
  {
    -1,
    (gchar *) "FreqList",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "freq-list",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_scan_cur_freq =
{
  {
    -1,
    (gchar *) "ScanCurFreq",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "scan-cur-freq",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_sched_scan_interval =
{
  {
    -1,
    (gchar *) "SchedScanInterval",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "sched-scan-interval",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_sched_scan_start_delay =
{
  {
    -1,
    (gchar *) "SchedScanStartDelay",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "sched-scan-start-delay",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_tdls_external_control =
{
  {
    -1,
    (gchar *) "TdlsExternalControl",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "tdls-external-control",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_osu_dir =
{
  {
    -1,
    (gchar *) "OsuDir",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "osu-dir",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wowlan_triggers =
{
  {
    -1,
    (gchar *) "WowlanTriggers",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "wowlan-triggers",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_search_delay =
{
  {
    -1,
    (gchar *) "P2pSearchDelay",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2p-search-delay",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_mac_addr =
{
  {
    -1,
    (gchar *) "MacAddr",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "mac-addr",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_rand_addr_lifetime =
{
  {
    -1,
    (gchar *) "RandAddrLifetime",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "rand-addr-lifetime",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_preassoc_mac_addr =
{
  {
    -1,
    (gchar *) "PreassocMacAddr",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "preassoc-mac-addr",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_key_mgmt_offload =
{
  {
    -1,
    (gchar *) "KeyMgmtOffload",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "key-mgmt-offload",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_passive_scan =
{
  {
    -1,
    (gchar *) "PassiveScan",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "passive-scan",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_reassoc_same_bss_optim =
{
  {
    -1,
    (gchar *) "ReassocSameBssOptim",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "reassoc-same-bss-optim",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_priority =
{
  {
    -1,
    (gchar *) "WpsPriority",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "wps-priority",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_cert_in_cb =
{
  {
    -1,
    (gchar *) "CertInCb",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "cert-in-cb",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wpa_rsc_relaxation =
{
  {
    -1,
    (gchar *) "WpaRscRelaxation",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "wpa-rsc-relaxation",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_sched_scan_plans =
{
  {
    -1,
    (gchar *) "SchedScanPlans",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "sched-scan-plans",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_gas_address3 =
{
  {
    -1,
    (gchar *) "GasAddress3",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "gas-address3",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ftm_responder =
{
  {
    -1,
    (gchar *) "FtmResponder",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ftm-responder",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ftm_initiator =
{
  {
    -1,
    (gchar *) "FtmInitiator",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ftm-initiator",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_gas_rand_addr_lifetime =
{
  {
    -1,
    (gchar *) "GasRandAddrLifetime",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "gas-rand-addr-lifetime",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_gas_rand_mac_addr =
{
  {
    -1,
    (gchar *) "GasRandMacAddr",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "gas-rand-mac-addr",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_dpp_config_processing =
{
  {
    -1,
    (gchar *) "DppConfigProcessing",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "dpp-config-processing",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pointers[] =
{
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_capabilities,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_state,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_scanning,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ap_scan,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_bssexpire_age,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_bssexpire_count,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_country,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ifname,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_driver,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_bridge_ifname,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_config_file,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_current_bss,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_current_network,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_current_auth_mode,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_blobs,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_bsss,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_networks,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_fast_reauth,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_scan_interval,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pkcs11_engine_path,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pkcs11_module_path,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_disconnect_reason,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_assoc_status_code,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ctrl_interface,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ctrl_interface_group,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_eapol_version,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_bgscan,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_disable_scan_offload,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_opensc_engine_path,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_openssl_ciphers,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pcsc_reader,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pcsc_pin,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_external_sim,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_driver_param,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_dot11_rsnaconfig_pmklifetime,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_dot11_rsnaconfig_pmkreauth_threshold,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_dot11_rsnaconfig_satimeout,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_update_config,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_uuid,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_auto_uuid,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_device_name,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_manufacturer,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_model_name,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_model_number,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_serial_number,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_device_type,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_os_version,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_config_methods,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_cred_processing,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_vendor_ext_m1,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_sec_device_type,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_listen_reg_class,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_listen_channel,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_oper_reg_class,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_oper_channel,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_go_intent,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_ssid_postfix,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_persistent_reconnect,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_intra_bss,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_group_idle,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_go_freq_change_policy,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_passphrase_len,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_pref_chan,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_no_go_freq,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_add_cli_chan,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_optimize_listen_chan,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_go_ht40,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_go_vht,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_disabled,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_go_ctwindow,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_no_group_iface,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_ignore_shared_freq,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ip_addr_go,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ip_addr_mask,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ip_addr_start,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ip_addr_end,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_cli_probe,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_bss_max_count,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_filter_ssids,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_filter_rssi,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_max_num_sta,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_disassoc_low_ack,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_interworking,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_hessid,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_access_network_type,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_go_interworking,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_go_access_network_type,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_go_internet,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_go_venue_group,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_go_venue_type,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pbc_in_m1,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_autoscan,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_nfc_dev_pw_id,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_nfc_dh_pubkey,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_nfc_dh_privkey,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_nfc_dev_pw,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ext_password_backend,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_go_max_inactivity,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_auto_interworking,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_okc,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pmf,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_sae_groups,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_dtim_period,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_beacon_int,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ap_vendor_elements,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ignore_old_scan_res,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_freq_list,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_scan_cur_freq,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_sched_scan_interval,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_sched_scan_start_delay,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_tdls_external_control,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_osu_dir,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wowlan_triggers,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_p2p_search_delay,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_mac_addr,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_rand_addr_lifetime,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_preassoc_mac_addr,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_key_mgmt_offload,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_passive_scan,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_reassoc_same_bss_optim,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wps_priority,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_cert_in_cb,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_wpa_rsc_relaxation,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_sched_scan_plans,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_gas_address3,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ftm_responder,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_ftm_initiator,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_gas_rand_addr_lifetime,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_gas_rand_mac_addr,
  &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_dpp_config_processing,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info =
{
  {
    -1,
    (gchar *) "fi.w1.wpa_supplicant1.Interface",
    (GDBusMethodInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_method_info_pointers,
    (GDBusSignalInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_signal_info_pointers,
    (GDBusPropertyInfo **) &_wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pointers,
    NULL
  },
  "fi-w1-wpa-supplicant1-interface",
};


/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface.top_of_page">fi.w1.wpa_supplicant1.Interface</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info.parent_struct;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #wpainterfaceFiW1Wpa_supplicant1Interface interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
wpa_interface_fi_w1_wpa_supplicant1_interface_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "capabilities");
  g_object_class_override_property (klass, property_id_begin++, "state");
  g_object_class_override_property (klass, property_id_begin++, "scanning");
  g_object_class_override_property (klass, property_id_begin++, "ap-scan");
  g_object_class_override_property (klass, property_id_begin++, "bssexpire-age");
  g_object_class_override_property (klass, property_id_begin++, "bssexpire-count");
  g_object_class_override_property (klass, property_id_begin++, "country");
  g_object_class_override_property (klass, property_id_begin++, "ifname");
  g_object_class_override_property (klass, property_id_begin++, "driver");
  g_object_class_override_property (klass, property_id_begin++, "bridge-ifname");
  g_object_class_override_property (klass, property_id_begin++, "config-file");
  g_object_class_override_property (klass, property_id_begin++, "current-bss");
  g_object_class_override_property (klass, property_id_begin++, "current-network");
  g_object_class_override_property (klass, property_id_begin++, "current-auth-mode");
  g_object_class_override_property (klass, property_id_begin++, "blobs");
  g_object_class_override_property (klass, property_id_begin++, "bsss");
  g_object_class_override_property (klass, property_id_begin++, "networks");
  g_object_class_override_property (klass, property_id_begin++, "fast-reauth");
  g_object_class_override_property (klass, property_id_begin++, "scan-interval");
  g_object_class_override_property (klass, property_id_begin++, "pkcs11-engine-path");
  g_object_class_override_property (klass, property_id_begin++, "pkcs11-module-path");
  g_object_class_override_property (klass, property_id_begin++, "disconnect-reason");
  g_object_class_override_property (klass, property_id_begin++, "assoc-status-code");
  g_object_class_override_property (klass, property_id_begin++, "ctrl-interface");
  g_object_class_override_property (klass, property_id_begin++, "ctrl-interface-group");
  g_object_class_override_property (klass, property_id_begin++, "eapol-version");
  g_object_class_override_property (klass, property_id_begin++, "bgscan");
  g_object_class_override_property (klass, property_id_begin++, "disable-scan-offload");
  g_object_class_override_property (klass, property_id_begin++, "opensc-engine-path");
  g_object_class_override_property (klass, property_id_begin++, "openssl-ciphers");
  g_object_class_override_property (klass, property_id_begin++, "pcsc-reader");
  g_object_class_override_property (klass, property_id_begin++, "pcsc-pin");
  g_object_class_override_property (klass, property_id_begin++, "external-sim");
  g_object_class_override_property (klass, property_id_begin++, "driver-param");
  g_object_class_override_property (klass, property_id_begin++, "dot11-rsnaconfig-pmklifetime");
  g_object_class_override_property (klass, property_id_begin++, "dot11-rsnaconfig-pmkreauth-threshold");
  g_object_class_override_property (klass, property_id_begin++, "dot11-rsnaconfig-satimeout");
  g_object_class_override_property (klass, property_id_begin++, "update-config");
  g_object_class_override_property (klass, property_id_begin++, "uuid");
  g_object_class_override_property (klass, property_id_begin++, "auto-uuid");
  g_object_class_override_property (klass, property_id_begin++, "device-name");
  g_object_class_override_property (klass, property_id_begin++, "manufacturer");
  g_object_class_override_property (klass, property_id_begin++, "model-name");
  g_object_class_override_property (klass, property_id_begin++, "model-number");
  g_object_class_override_property (klass, property_id_begin++, "serial-number");
  g_object_class_override_property (klass, property_id_begin++, "device-type");
  g_object_class_override_property (klass, property_id_begin++, "os-version");
  g_object_class_override_property (klass, property_id_begin++, "config-methods");
  g_object_class_override_property (klass, property_id_begin++, "wps-cred-processing");
  g_object_class_override_property (klass, property_id_begin++, "wps-vendor-ext-m1");
  g_object_class_override_property (klass, property_id_begin++, "sec-device-type");
  g_object_class_override_property (klass, property_id_begin++, "p2p-listen-reg-class");
  g_object_class_override_property (klass, property_id_begin++, "p2p-listen-channel");
  g_object_class_override_property (klass, property_id_begin++, "p2p-oper-reg-class");
  g_object_class_override_property (klass, property_id_begin++, "p2p-oper-channel");
  g_object_class_override_property (klass, property_id_begin++, "p2p-go-intent");
  g_object_class_override_property (klass, property_id_begin++, "p2p-ssid-postfix");
  g_object_class_override_property (klass, property_id_begin++, "persistent-reconnect");
  g_object_class_override_property (klass, property_id_begin++, "p2p-intra-bss");
  g_object_class_override_property (klass, property_id_begin++, "p2p-group-idle");
  g_object_class_override_property (klass, property_id_begin++, "p2p-go-freq-change-policy");
  g_object_class_override_property (klass, property_id_begin++, "p2p-passphrase-len");
  g_object_class_override_property (klass, property_id_begin++, "p2p-pref-chan");
  g_object_class_override_property (klass, property_id_begin++, "p2p-no-go-freq");
  g_object_class_override_property (klass, property_id_begin++, "p2p-add-cli-chan");
  g_object_class_override_property (klass, property_id_begin++, "p2p-optimize-listen-chan");
  g_object_class_override_property (klass, property_id_begin++, "p2p-go-ht40");
  g_object_class_override_property (klass, property_id_begin++, "p2p-go-vht");
  g_object_class_override_property (klass, property_id_begin++, "p2p-disabled");
  g_object_class_override_property (klass, property_id_begin++, "p2p-go-ctwindow");
  g_object_class_override_property (klass, property_id_begin++, "p2p-no-group-iface");
  g_object_class_override_property (klass, property_id_begin++, "p2p-ignore-shared-freq");
  g_object_class_override_property (klass, property_id_begin++, "ip-addr-go");
  g_object_class_override_property (klass, property_id_begin++, "ip-addr-mask");
  g_object_class_override_property (klass, property_id_begin++, "ip-addr-start");
  g_object_class_override_property (klass, property_id_begin++, "ip-addr-end");
  g_object_class_override_property (klass, property_id_begin++, "p2p-cli-probe");
  g_object_class_override_property (klass, property_id_begin++, "bss-max-count");
  g_object_class_override_property (klass, property_id_begin++, "filter-ssids");
  g_object_class_override_property (klass, property_id_begin++, "filter-rssi");
  g_object_class_override_property (klass, property_id_begin++, "max-num-sta");
  g_object_class_override_property (klass, property_id_begin++, "disassoc-low-ack");
  g_object_class_override_property (klass, property_id_begin++, "interworking");
  g_object_class_override_property (klass, property_id_begin++, "hessid");
  g_object_class_override_property (klass, property_id_begin++, "access-network-type");
  g_object_class_override_property (klass, property_id_begin++, "go-interworking");
  g_object_class_override_property (klass, property_id_begin++, "go-access-network-type");
  g_object_class_override_property (klass, property_id_begin++, "go-internet");
  g_object_class_override_property (klass, property_id_begin++, "go-venue-group");
  g_object_class_override_property (klass, property_id_begin++, "go-venue-type");
  g_object_class_override_property (klass, property_id_begin++, "pbc-in-m1");
  g_object_class_override_property (klass, property_id_begin++, "autoscan");
  g_object_class_override_property (klass, property_id_begin++, "wps-nfc-dev-pw-id");
  g_object_class_override_property (klass, property_id_begin++, "wps-nfc-dh-pubkey");
  g_object_class_override_property (klass, property_id_begin++, "wps-nfc-dh-privkey");
  g_object_class_override_property (klass, property_id_begin++, "wps-nfc-dev-pw");
  g_object_class_override_property (klass, property_id_begin++, "ext-password-backend");
  g_object_class_override_property (klass, property_id_begin++, "p2p-go-max-inactivity");
  g_object_class_override_property (klass, property_id_begin++, "auto-interworking");
  g_object_class_override_property (klass, property_id_begin++, "okc");
  g_object_class_override_property (klass, property_id_begin++, "pmf");
  g_object_class_override_property (klass, property_id_begin++, "sae-groups");
  g_object_class_override_property (klass, property_id_begin++, "dtim-period");
  g_object_class_override_property (klass, property_id_begin++, "beacon-int");
  g_object_class_override_property (klass, property_id_begin++, "ap-vendor-elements");
  g_object_class_override_property (klass, property_id_begin++, "ignore-old-scan-res");
  g_object_class_override_property (klass, property_id_begin++, "freq-list");
  g_object_class_override_property (klass, property_id_begin++, "scan-cur-freq");
  g_object_class_override_property (klass, property_id_begin++, "sched-scan-interval");
  g_object_class_override_property (klass, property_id_begin++, "sched-scan-start-delay");
  g_object_class_override_property (klass, property_id_begin++, "tdls-external-control");
  g_object_class_override_property (klass, property_id_begin++, "osu-dir");
  g_object_class_override_property (klass, property_id_begin++, "wowlan-triggers");
  g_object_class_override_property (klass, property_id_begin++, "p2p-search-delay");
  g_object_class_override_property (klass, property_id_begin++, "mac-addr");
  g_object_class_override_property (klass, property_id_begin++, "rand-addr-lifetime");
  g_object_class_override_property (klass, property_id_begin++, "preassoc-mac-addr");
  g_object_class_override_property (klass, property_id_begin++, "key-mgmt-offload");
  g_object_class_override_property (klass, property_id_begin++, "passive-scan");
  g_object_class_override_property (klass, property_id_begin++, "reassoc-same-bss-optim");
  g_object_class_override_property (klass, property_id_begin++, "wps-priority");
  g_object_class_override_property (klass, property_id_begin++, "cert-in-cb");
  g_object_class_override_property (klass, property_id_begin++, "wpa-rsc-relaxation");
  g_object_class_override_property (klass, property_id_begin++, "sched-scan-plans");
  g_object_class_override_property (klass, property_id_begin++, "gas-address3");
  g_object_class_override_property (klass, property_id_begin++, "ftm-responder");
  g_object_class_override_property (klass, property_id_begin++, "ftm-initiator");
  g_object_class_override_property (klass, property_id_begin++, "gas-rand-addr-lifetime");
  g_object_class_override_property (klass, property_id_begin++, "gas-rand-mac-addr");
  g_object_class_override_property (klass, property_id_begin++, "dpp-config-processing");
  return property_id_begin - 1;
}



/**
 * wpainterfaceFiW1Wpa_supplicant1Interface:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface.top_of_page">fi.w1.wpa_supplicant1.Interface</link>.
 */

/**
 * wpainterfaceFiW1Wpa_supplicant1InterfaceIface:
 * @parent_iface: The parent interface.
 * @handle_abort_scan: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-abort-scan signal.
 * @handle_add_blob: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-add-blob signal.
 * @handle_add_network: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-add-network signal.
 * @handle_disconnect: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-disconnect signal.
 * @handle_eaplogoff: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-eaplogoff signal.
 * @handle_eaplogon: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-eaplogon signal.
 * @handle_flush_bss: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-flush-bss signal.
 * @handle_get_blob: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-get-blob signal.
 * @handle_network_reply: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-network-reply signal.
 * @handle_reassociate: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-reassociate signal.
 * @handle_reattach: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-reattach signal.
 * @handle_reconnect: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-reconnect signal.
 * @handle_remove_all_networks: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-remove-all-networks signal.
 * @handle_remove_blob: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-remove-blob signal.
 * @handle_remove_network: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-remove-network signal.
 * @handle_save_config: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-save-config signal.
 * @handle_scan: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-scan signal.
 * @handle_select_network: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-select-network signal.
 * @handle_set_pkcs11_engine_and_module_path: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-set-pkcs11-engine-and-module-path signal.
 * @handle_signal_poll: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-signal-poll signal.
 * @handle_subscribe_probe_req: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-subscribe-probe-req signal.
 * @handle_unsubscribe_probe_req: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-unsubscribe-probe-req signal.
 * @handle_vendor_elem_add: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-vendor-elem-add signal.
 * @handle_vendor_elem_get: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-vendor-elem-get signal.
 * @handle_vendor_elem_rem: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::handle-vendor-elem-rem signal.
 * @get_access_network_type: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:access-network-type property.
 * @get_ap_scan: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:ap-scan property.
 * @get_ap_vendor_elements: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:ap-vendor-elements property.
 * @get_assoc_status_code: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:assoc-status-code property.
 * @get_auto_interworking: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:auto-interworking property.
 * @get_auto_uuid: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:auto-uuid property.
 * @get_autoscan: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:autoscan property.
 * @get_beacon_int: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:beacon-int property.
 * @get_bgscan: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:bgscan property.
 * @get_blobs: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:blobs property.
 * @get_bridge_ifname: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:bridge-ifname property.
 * @get_bss_max_count: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:bss-max-count property.
 * @get_bssexpire_age: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:bssexpire-age property.
 * @get_bssexpire_count: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:bssexpire-count property.
 * @get_bsss: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:bsss property.
 * @get_capabilities: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:capabilities property.
 * @get_cert_in_cb: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:cert-in-cb property.
 * @get_config_file: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:config-file property.
 * @get_config_methods: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:config-methods property.
 * @get_country: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:country property.
 * @get_ctrl_interface: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:ctrl-interface property.
 * @get_ctrl_interface_group: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:ctrl-interface-group property.
 * @get_current_auth_mode: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:current-auth-mode property.
 * @get_current_bss: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:current-bss property.
 * @get_current_network: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:current-network property.
 * @get_device_name: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:device-name property.
 * @get_device_type: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:device-type property.
 * @get_disable_scan_offload: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:disable-scan-offload property.
 * @get_disassoc_low_ack: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:disassoc-low-ack property.
 * @get_disconnect_reason: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:disconnect-reason property.
 * @get_dot11_rsnaconfig_pmklifetime: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:dot11-rsnaconfig-pmklifetime property.
 * @get_dot11_rsnaconfig_pmkreauth_threshold: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:dot11-rsnaconfig-pmkreauth-threshold property.
 * @get_dot11_rsnaconfig_satimeout: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:dot11-rsnaconfig-satimeout property.
 * @get_dpp_config_processing: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:dpp-config-processing property.
 * @get_driver: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:driver property.
 * @get_driver_param: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:driver-param property.
 * @get_dtim_period: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:dtim-period property.
 * @get_eapol_version: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:eapol-version property.
 * @get_ext_password_backend: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:ext-password-backend property.
 * @get_external_sim: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:external-sim property.
 * @get_fast_reauth: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:fast-reauth property.
 * @get_filter_rssi: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:filter-rssi property.
 * @get_filter_ssids: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:filter-ssids property.
 * @get_freq_list: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:freq-list property.
 * @get_ftm_initiator: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:ftm-initiator property.
 * @get_ftm_responder: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:ftm-responder property.
 * @get_gas_address3: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:gas-address3 property.
 * @get_gas_rand_addr_lifetime: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:gas-rand-addr-lifetime property.
 * @get_gas_rand_mac_addr: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:gas-rand-mac-addr property.
 * @get_go_access_network_type: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:go-access-network-type property.
 * @get_go_internet: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:go-internet property.
 * @get_go_interworking: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:go-interworking property.
 * @get_go_venue_group: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:go-venue-group property.
 * @get_go_venue_type: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:go-venue-type property.
 * @get_hessid: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:hessid property.
 * @get_ifname: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:ifname property.
 * @get_ignore_old_scan_res: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:ignore-old-scan-res property.
 * @get_interworking: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:interworking property.
 * @get_ip_addr_end: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:ip-addr-end property.
 * @get_ip_addr_go: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:ip-addr-go property.
 * @get_ip_addr_mask: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:ip-addr-mask property.
 * @get_ip_addr_start: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:ip-addr-start property.
 * @get_key_mgmt_offload: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:key-mgmt-offload property.
 * @get_mac_addr: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:mac-addr property.
 * @get_manufacturer: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:manufacturer property.
 * @get_max_num_sta: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:max-num-sta property.
 * @get_model_name: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:model-name property.
 * @get_model_number: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:model-number property.
 * @get_networks: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:networks property.
 * @get_okc: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:okc property.
 * @get_opensc_engine_path: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:opensc-engine-path property.
 * @get_openssl_ciphers: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:openssl-ciphers property.
 * @get_os_version: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:os-version property.
 * @get_osu_dir: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:osu-dir property.
 * @get_p2p_add_cli_chan: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-add-cli-chan property.
 * @get_p2p_cli_probe: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-cli-probe property.
 * @get_p2p_disabled: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-disabled property.
 * @get_p2p_go_ctwindow: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-go-ctwindow property.
 * @get_p2p_go_freq_change_policy: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-go-freq-change-policy property.
 * @get_p2p_go_ht40: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-go-ht40 property.
 * @get_p2p_go_intent: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-go-intent property.
 * @get_p2p_go_max_inactivity: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-go-max-inactivity property.
 * @get_p2p_go_vht: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-go-vht property.
 * @get_p2p_group_idle: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-group-idle property.
 * @get_p2p_ignore_shared_freq: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-ignore-shared-freq property.
 * @get_p2p_intra_bss: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-intra-bss property.
 * @get_p2p_listen_channel: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-listen-channel property.
 * @get_p2p_listen_reg_class: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-listen-reg-class property.
 * @get_p2p_no_go_freq: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-no-go-freq property.
 * @get_p2p_no_group_iface: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-no-group-iface property.
 * @get_p2p_oper_channel: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-oper-channel property.
 * @get_p2p_oper_reg_class: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-oper-reg-class property.
 * @get_p2p_optimize_listen_chan: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-optimize-listen-chan property.
 * @get_p2p_passphrase_len: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-passphrase-len property.
 * @get_p2p_pref_chan: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-pref-chan property.
 * @get_p2p_search_delay: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-search-delay property.
 * @get_p2p_ssid_postfix: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:p2p-ssid-postfix property.
 * @get_passive_scan: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:passive-scan property.
 * @get_pbc_in_m1: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:pbc-in-m1 property.
 * @get_pcsc_pin: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:pcsc-pin property.
 * @get_pcsc_reader: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:pcsc-reader property.
 * @get_persistent_reconnect: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:persistent-reconnect property.
 * @get_pkcs11_engine_path: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:pkcs11-engine-path property.
 * @get_pkcs11_module_path: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:pkcs11-module-path property.
 * @get_pmf: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:pmf property.
 * @get_preassoc_mac_addr: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:preassoc-mac-addr property.
 * @get_rand_addr_lifetime: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:rand-addr-lifetime property.
 * @get_reassoc_same_bss_optim: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:reassoc-same-bss-optim property.
 * @get_sae_groups: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:sae-groups property.
 * @get_scan_cur_freq: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:scan-cur-freq property.
 * @get_scan_interval: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:scan-interval property.
 * @get_scanning: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:scanning property.
 * @get_sched_scan_interval: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:sched-scan-interval property.
 * @get_sched_scan_plans: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:sched-scan-plans property.
 * @get_sched_scan_start_delay: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:sched-scan-start-delay property.
 * @get_sec_device_type: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:sec-device-type property.
 * @get_serial_number: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:serial-number property.
 * @get_state: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:state property.
 * @get_tdls_external_control: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:tdls-external-control property.
 * @get_update_config: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:update-config property.
 * @get_uuid: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:uuid property.
 * @get_wowlan_triggers: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:wowlan-triggers property.
 * @get_wpa_rsc_relaxation: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:wpa-rsc-relaxation property.
 * @get_wps_cred_processing: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:wps-cred-processing property.
 * @get_wps_nfc_dev_pw: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:wps-nfc-dev-pw property.
 * @get_wps_nfc_dev_pw_id: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:wps-nfc-dev-pw-id property.
 * @get_wps_nfc_dh_privkey: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:wps-nfc-dh-privkey property.
 * @get_wps_nfc_dh_pubkey: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:wps-nfc-dh-pubkey property.
 * @get_wps_priority: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:wps-priority property.
 * @get_wps_vendor_ext_m1: Getter for the #wpainterfaceFiW1Wpa_supplicant1Interface:wps-vendor-ext-m1 property.
 * @blob_added: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::blob-added signal.
 * @blob_removed: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::blob-removed signal.
 * @bssadded: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::bssadded signal.
 * @bssremoved: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::bssremoved signal.
 * @certification: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::certification signal.
 * @eap: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::eap signal.
 * @network_added: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::network-added signal.
 * @network_removed: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::network-removed signal.
 * @network_request: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::network-request signal.
 * @network_selected: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::network-selected signal.
 * @probe_request: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::probe-request signal.
 * @properties_changed: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::properties-changed signal.
 * @scan_done: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::scan-done signal.
 * @sta_authorized: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::sta-authorized signal.
 * @sta_deauthorized: Handler for the #wpainterfaceFiW1Wpa_supplicant1Interface::sta-deauthorized signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface.top_of_page">fi.w1.wpa_supplicant1.Interface</link>.
 */

typedef wpainterfaceFiW1Wpa_supplicant1InterfaceIface wpainterfaceFiW1Wpa_supplicant1InterfaceInterface;
G_DEFINE_INTERFACE (wpainterfaceFiW1Wpa_supplicant1Interface, wpa_interface_fi_w1_wpa_supplicant1_interface, G_TYPE_OBJECT);

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_default_init (wpainterfaceFiW1Wpa_supplicant1InterfaceIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-scan:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Scan">Scan()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_scan() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-scan",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_scan),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-signal-poll:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SignalPoll">SignalPoll()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_signal_poll() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-signal-poll",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_signal_poll),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-disconnect:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Disconnect">Disconnect()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_disconnect() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-disconnect",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_disconnect),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-add-network:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.AddNetwork">AddNetwork()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_add_network() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-add-network",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_add_network),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-reassociate:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Reassociate">Reassociate()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_reassociate() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-reassociate",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_reassociate),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-reattach:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Reattach">Reattach()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_reattach() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-reattach",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_reattach),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-reconnect:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Reconnect">Reconnect()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_reconnect() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-reconnect",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_reconnect),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-remove-network:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_path: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.RemoveNetwork">RemoveNetwork()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_remove_network() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-remove-network",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_remove_network),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-remove-all-networks:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.RemoveAllNetworks">RemoveAllNetworks()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_remove_all_networks() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-remove-all-networks",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_remove_all_networks),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-select-network:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_path: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SelectNetwork">SelectNetwork()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_select_network() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-select-network",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_select_network),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-network-reply:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_path: Argument passed by remote caller.
   * @arg_field: Argument passed by remote caller.
   * @arg_value: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.NetworkReply">NetworkReply()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_network_reply() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-network-reply",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_network_reply),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    4,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-add-blob:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_name: Argument passed by remote caller.
   * @arg_data: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.AddBlob">AddBlob()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_add_blob() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-add-blob",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_add_blob),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-get-blob:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_name: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.GetBlob">GetBlob()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_get_blob() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-blob",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_get_blob),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-remove-blob:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_name: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.RemoveBlob">RemoveBlob()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_remove_blob() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-remove-blob",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_remove_blob),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-set-pkcs11-engine-and-module-path:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_pkcs11_engine_path: Argument passed by remote caller.
   * @arg_pkcs11_module_path: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SetPKCS11EngineAndModulePath">SetPKCS11EngineAndModulePath()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_set_pkcs11_engine_and_module_path() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-set-pkcs11-engine-and-module-path",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_set_pkcs11_engine_and_module_path),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-flush-bss:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_age: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.FlushBSS">FlushBSS()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_flush_bss() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-flush-bss",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_flush_bss),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UINT);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-subscribe-probe-req:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SubscribeProbeReq">SubscribeProbeReq()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_subscribe_probe_req() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-subscribe-probe-req",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_subscribe_probe_req),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-unsubscribe-probe-req:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.UnsubscribeProbeReq">UnsubscribeProbeReq()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_unsubscribe_probe_req() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-unsubscribe-probe-req",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_unsubscribe_probe_req),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-eaplogoff:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.EAPLogoff">EAPLogoff()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_eaplogoff() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-eaplogoff",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_eaplogoff),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-eaplogon:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.EAPLogon">EAPLogon()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_eaplogon() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-eaplogon",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_eaplogon),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-vendor-elem-add:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_frame_id: Argument passed by remote caller.
   * @arg_ielems: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.VendorElemAdd">VendorElemAdd()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_vendor_elem_add() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-vendor-elem-add",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_vendor_elem_add),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-vendor-elem-get:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_frame_id: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.VendorElemGet">VendorElemGet()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_vendor_elem_get() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-vendor-elem-get",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_vendor_elem_get),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-vendor-elem-rem:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_frame_id: Argument passed by remote caller.
   * @arg_ielems: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.VendorElemRem">VendorElemRem()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_vendor_elem_rem() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-vendor-elem-rem",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_vendor_elem_rem),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-save-config:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SaveConfig">SaveConfig()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_save_config() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-save-config",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_save_config),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::handle-abort-scan:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.AbortScan">AbortScan()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_fi_w1_wpa_supplicant1_interface_complete_abort_scan() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-abort-scan",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, handle_abort_scan),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::scan-done:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_success: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.ScanDone">"ScanDone"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("scan-done",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, scan_done),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_BOOLEAN);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::bssadded:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_path: Argument.
   * @arg_properties: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.BSSAdded">"BSSAdded"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("bssadded",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, bssadded),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_VARIANT);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::bssremoved:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_path: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.BSSRemoved">"BSSRemoved"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("bssremoved",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, bssremoved),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::blob-added:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_name: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.BlobAdded">"BlobAdded"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("blob-added",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, blob_added),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::blob-removed:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_name: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.BlobRemoved">"BlobRemoved"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("blob-removed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, blob_removed),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::network-added:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_path: Argument.
   * @arg_properties: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.NetworkAdded">"NetworkAdded"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("network-added",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, network_added),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_VARIANT);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::network-removed:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_path: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.NetworkRemoved">"NetworkRemoved"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("network-removed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, network_removed),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::network-selected:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_path: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.NetworkSelected">"NetworkSelected"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("network-selected",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, network_selected),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::properties-changed:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_properties: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.PropertiesChanged">"PropertiesChanged"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("properties-changed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, properties_changed),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_VARIANT);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::probe-request:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_args: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.ProbeRequest">"ProbeRequest"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("probe-request",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, probe_request),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_VARIANT);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::certification:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_certification: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.Certification">"Certification"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("certification",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, certification),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_VARIANT);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::eap:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_status: Argument.
   * @arg_parameter: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.EAP">"EAP"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("eap",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, eap),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::sta-authorized:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_name: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.StaAuthorized">"StaAuthorized"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("sta-authorized",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, sta_authorized),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::sta-deauthorized:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_name: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.StaDeauthorized">"StaDeauthorized"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("sta-deauthorized",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, sta_deauthorized),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface::network-request:
   * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
   * @arg_path: Argument.
   * @arg_field: Argument.
   * @arg_text: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.NetworkRequest">"NetworkRequest"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("network-request",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceFiW1Wpa_supplicant1InterfaceIface, network_request),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    3, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);

  /* GObject properties for D-Bus properties: */
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:capabilities:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Capabilities">"Capabilities"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("capabilities", "Capabilities", "Capabilities", G_VARIANT_TYPE ("a{sv}"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:state:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.State">"State"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("state", "State", "State", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:scanning:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Scanning">"Scanning"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("scanning", "Scanning", "Scanning", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:ap-scan:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ApScan">"ApScan"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uint ("ap-scan", "ApScan", "ApScan", 0, G_MAXUINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:bssexpire-age:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BSSExpireAge">"BSSExpireAge"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uint ("bssexpire-age", "BSSExpireAge", "BSSExpireAge", 0, G_MAXUINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:bssexpire-count:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BSSExpireCount">"BSSExpireCount"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uint ("bssexpire-count", "BSSExpireCount", "BSSExpireCount", 0, G_MAXUINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:country:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Country">"Country"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("country", "Country", "Country", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:ifname:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Ifname">"Ifname"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ifname", "Ifname", "Ifname", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:driver:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Driver">"Driver"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("driver", "Driver", "Driver", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:bridge-ifname:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BridgeIfname">"BridgeIfname"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("bridge-ifname", "BridgeIfname", "BridgeIfname", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:config-file:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ConfigFile">"ConfigFile"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("config-file", "ConfigFile", "ConfigFile", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:current-bss:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CurrentBSS">"CurrentBSS"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("current-bss", "CurrentBSS", "CurrentBSS", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:current-network:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CurrentNetwork">"CurrentNetwork"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("current-network", "CurrentNetwork", "CurrentNetwork", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:current-auth-mode:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CurrentAuthMode">"CurrentAuthMode"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("current-auth-mode", "CurrentAuthMode", "CurrentAuthMode", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:blobs:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Blobs">"Blobs"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("blobs", "Blobs", "Blobs", G_VARIANT_TYPE ("a{say}"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:bsss:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BSSs">"BSSs"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("bsss", "BSSs", "BSSs", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:networks:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Networks">"Networks"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("networks", "Networks", "Networks", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:fast-reauth:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FastReauth">"FastReauth"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("fast-reauth", "FastReauth", "FastReauth", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:scan-interval:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ScanInterval">"ScanInterval"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("scan-interval", "ScanInterval", "ScanInterval", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:pkcs11-engine-path:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PKCS11EnginePath">"PKCS11EnginePath"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("pkcs11-engine-path", "PKCS11EnginePath", "PKCS11EnginePath", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:pkcs11-module-path:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PKCS11ModulePath">"PKCS11ModulePath"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("pkcs11-module-path", "PKCS11ModulePath", "PKCS11ModulePath", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:disconnect-reason:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DisconnectReason">"DisconnectReason"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("disconnect-reason", "DisconnectReason", "DisconnectReason", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:assoc-status-code:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AssocStatusCode">"AssocStatusCode"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("assoc-status-code", "AssocStatusCode", "AssocStatusCode", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:ctrl-interface:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CtrlInterface">"CtrlInterface"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ctrl-interface", "CtrlInterface", "CtrlInterface", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:ctrl-interface-group:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CtrlInterfaceGroup">"CtrlInterfaceGroup"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ctrl-interface-group", "CtrlInterfaceGroup", "CtrlInterfaceGroup", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:eapol-version:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.EapolVersion">"EapolVersion"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("eapol-version", "EapolVersion", "EapolVersion", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:bgscan:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Bgscan">"Bgscan"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("bgscan", "Bgscan", "Bgscan", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:disable-scan-offload:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DisableScanOffload">"DisableScanOffload"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("disable-scan-offload", "DisableScanOffload", "DisableScanOffload", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:opensc-engine-path:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OpenscEnginePath">"OpenscEnginePath"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("opensc-engine-path", "OpenscEnginePath", "OpenscEnginePath", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:openssl-ciphers:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OpensslCiphers">"OpensslCiphers"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("openssl-ciphers", "OpensslCiphers", "OpensslCiphers", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:pcsc-reader:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PcscReader">"PcscReader"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("pcsc-reader", "PcscReader", "PcscReader", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:pcsc-pin:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PcscPin">"PcscPin"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("pcsc-pin", "PcscPin", "PcscPin", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:external-sim:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ExternalSim">"ExternalSim"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("external-sim", "ExternalSim", "ExternalSim", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:driver-param:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DriverParam">"DriverParam"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("driver-param", "DriverParam", "DriverParam", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:dot11-rsnaconfig-pmklifetime:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Dot11RSNAConfigPMKLifetime">"Dot11RSNAConfigPMKLifetime"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("dot11-rsnaconfig-pmklifetime", "Dot11RSNAConfigPMKLifetime", "Dot11RSNAConfigPMKLifetime", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:dot11-rsnaconfig-pmkreauth-threshold:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Dot11RSNAConfigPMKReauthThreshold">"Dot11RSNAConfigPMKReauthThreshold"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("dot11-rsnaconfig-pmkreauth-threshold", "Dot11RSNAConfigPMKReauthThreshold", "Dot11RSNAConfigPMKReauthThreshold", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:dot11-rsnaconfig-satimeout:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Dot11RSNAConfigSATimeout">"Dot11RSNAConfigSATimeout"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("dot11-rsnaconfig-satimeout", "Dot11RSNAConfigSATimeout", "Dot11RSNAConfigSATimeout", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:update-config:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.UpdateConfig">"UpdateConfig"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("update-config", "UpdateConfig", "UpdateConfig", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:uuid:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Uuid">"Uuid"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("uuid", "Uuid", "Uuid", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:auto-uuid:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AutoUuid">"AutoUuid"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("auto-uuid", "AutoUuid", "AutoUuid", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:device-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DeviceName">"DeviceName"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("device-name", "DeviceName", "DeviceName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:manufacturer:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Manufacturer">"Manufacturer"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("manufacturer", "Manufacturer", "Manufacturer", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:model-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ModelName">"ModelName"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("model-name", "ModelName", "ModelName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:model-number:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ModelNumber">"ModelNumber"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("model-number", "ModelNumber", "ModelNumber", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:serial-number:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SerialNumber">"SerialNumber"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("serial-number", "SerialNumber", "SerialNumber", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:device-type:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DeviceType">"DeviceType"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("device-type", "DeviceType", "DeviceType", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:os-version:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OsVersion">"OsVersion"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("os-version", "OsVersion", "OsVersion", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:config-methods:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ConfigMethods">"ConfigMethods"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("config-methods", "ConfigMethods", "ConfigMethods", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:wps-cred-processing:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsCredProcessing">"WpsCredProcessing"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("wps-cred-processing", "WpsCredProcessing", "WpsCredProcessing", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:wps-vendor-ext-m1:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsVendorExtM1">"WpsVendorExtM1"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("wps-vendor-ext-m1", "WpsVendorExtM1", "WpsVendorExtM1", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:sec-device-type:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SecDeviceType">"SecDeviceType"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("sec-device-type", "SecDeviceType", "SecDeviceType", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-listen-reg-class:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pListenRegClass">"P2pListenRegClass"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-listen-reg-class", "P2pListenRegClass", "P2pListenRegClass", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-listen-channel:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pListenChannel">"P2pListenChannel"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-listen-channel", "P2pListenChannel", "P2pListenChannel", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-oper-reg-class:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pOperRegClass">"P2pOperRegClass"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-oper-reg-class", "P2pOperRegClass", "P2pOperRegClass", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-oper-channel:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pOperChannel">"P2pOperChannel"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-oper-channel", "P2pOperChannel", "P2pOperChannel", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-go-intent:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoIntent">"P2pGoIntent"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-go-intent", "P2pGoIntent", "P2pGoIntent", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-ssid-postfix:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pSsidPostfix">"P2pSsidPostfix"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-ssid-postfix", "P2pSsidPostfix", "P2pSsidPostfix", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:persistent-reconnect:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PersistentReconnect">"PersistentReconnect"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("persistent-reconnect", "PersistentReconnect", "PersistentReconnect", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-intra-bss:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pIntraBss">"P2pIntraBss"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-intra-bss", "P2pIntraBss", "P2pIntraBss", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-group-idle:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGroupIdle">"P2pGroupIdle"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-group-idle", "P2pGroupIdle", "P2pGroupIdle", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-go-freq-change-policy:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoFreqChangePolicy">"P2pGoFreqChangePolicy"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-go-freq-change-policy", "P2pGoFreqChangePolicy", "P2pGoFreqChangePolicy", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-passphrase-len:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pPassphraseLen">"P2pPassphraseLen"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-passphrase-len", "P2pPassphraseLen", "P2pPassphraseLen", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-pref-chan:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pPrefChan">"P2pPrefChan"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-pref-chan", "P2pPrefChan", "P2pPrefChan", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-no-go-freq:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pNoGoFreq">"P2pNoGoFreq"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-no-go-freq", "P2pNoGoFreq", "P2pNoGoFreq", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-add-cli-chan:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pAddCliChan">"P2pAddCliChan"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-add-cli-chan", "P2pAddCliChan", "P2pAddCliChan", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-optimize-listen-chan:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pOptimizeListenChan">"P2pOptimizeListenChan"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-optimize-listen-chan", "P2pOptimizeListenChan", "P2pOptimizeListenChan", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-go-ht40:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoHt40">"P2pGoHt40"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-go-ht40", "P2pGoHt40", "P2pGoHt40", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-go-vht:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoVht">"P2pGoVht"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-go-vht", "P2pGoVht", "P2pGoVht", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-disabled:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pDisabled">"P2pDisabled"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-disabled", "P2pDisabled", "P2pDisabled", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-go-ctwindow:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoCtwindow">"P2pGoCtwindow"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-go-ctwindow", "P2pGoCtwindow", "P2pGoCtwindow", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-no-group-iface:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pNoGroupIface">"P2pNoGroupIface"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-no-group-iface", "P2pNoGroupIface", "P2pNoGroupIface", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-ignore-shared-freq:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pIgnoreSharedFreq">"P2pIgnoreSharedFreq"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-ignore-shared-freq", "P2pIgnoreSharedFreq", "P2pIgnoreSharedFreq", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:ip-addr-go:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrGo">"IpAddrGo"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ip-addr-go", "IpAddrGo", "IpAddrGo", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:ip-addr-mask:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrMask">"IpAddrMask"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ip-addr-mask", "IpAddrMask", "IpAddrMask", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:ip-addr-start:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrStart">"IpAddrStart"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ip-addr-start", "IpAddrStart", "IpAddrStart", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:ip-addr-end:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrEnd">"IpAddrEnd"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ip-addr-end", "IpAddrEnd", "IpAddrEnd", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-cli-probe:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pCliProbe">"P2pCliProbe"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-cli-probe", "P2pCliProbe", "P2pCliProbe", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:bss-max-count:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BssMaxCount">"BssMaxCount"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("bss-max-count", "BssMaxCount", "BssMaxCount", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:filter-ssids:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FilterSsids">"FilterSsids"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("filter-ssids", "FilterSsids", "FilterSsids", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:filter-rssi:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FilterRssi">"FilterRssi"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("filter-rssi", "FilterRssi", "FilterRssi", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:max-num-sta:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.MaxNumSta">"MaxNumSta"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("max-num-sta", "MaxNumSta", "MaxNumSta", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:disassoc-low-ack:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DisassocLowAck">"DisassocLowAck"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("disassoc-low-ack", "DisassocLowAck", "DisassocLowAck", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:interworking:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Interworking">"Interworking"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("interworking", "Interworking", "Interworking", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:hessid:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Hessid">"Hessid"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("hessid", "Hessid", "Hessid", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:access-network-type:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AccessNetworkType">"AccessNetworkType"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("access-network-type", "AccessNetworkType", "AccessNetworkType", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:go-interworking:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoInterworking">"GoInterworking"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("go-interworking", "GoInterworking", "GoInterworking", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:go-access-network-type:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoAccessNetworkType">"GoAccessNetworkType"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("go-access-network-type", "GoAccessNetworkType", "GoAccessNetworkType", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:go-internet:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoInternet">"GoInternet"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("go-internet", "GoInternet", "GoInternet", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:go-venue-group:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoVenueGroup">"GoVenueGroup"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("go-venue-group", "GoVenueGroup", "GoVenueGroup", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:go-venue-type:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoVenueType">"GoVenueType"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("go-venue-type", "GoVenueType", "GoVenueType", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:pbc-in-m1:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PbcInM1">"PbcInM1"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("pbc-in-m1", "PbcInM1", "PbcInM1", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:autoscan:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Autoscan">"Autoscan"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("autoscan", "Autoscan", "Autoscan", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:wps-nfc-dev-pw-id:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDevPwId">"WpsNfcDevPwId"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("wps-nfc-dev-pw-id", "WpsNfcDevPwId", "WpsNfcDevPwId", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:wps-nfc-dh-pubkey:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDhPubkey">"WpsNfcDhPubkey"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("wps-nfc-dh-pubkey", "WpsNfcDhPubkey", "WpsNfcDhPubkey", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:wps-nfc-dh-privkey:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDhPrivkey">"WpsNfcDhPrivkey"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("wps-nfc-dh-privkey", "WpsNfcDhPrivkey", "WpsNfcDhPrivkey", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:wps-nfc-dev-pw:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDevPw">"WpsNfcDevPw"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("wps-nfc-dev-pw", "WpsNfcDevPw", "WpsNfcDevPw", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:ext-password-backend:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ExtPasswordBackend">"ExtPasswordBackend"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ext-password-backend", "ExtPasswordBackend", "ExtPasswordBackend", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-go-max-inactivity:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoMaxInactivity">"P2pGoMaxInactivity"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-go-max-inactivity", "P2pGoMaxInactivity", "P2pGoMaxInactivity", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:auto-interworking:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AutoInterworking">"AutoInterworking"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("auto-interworking", "AutoInterworking", "AutoInterworking", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:okc:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Okc">"Okc"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("okc", "Okc", "Okc", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:pmf:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Pmf">"Pmf"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("pmf", "Pmf", "Pmf", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:sae-groups:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SaeGroups">"SaeGroups"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("sae-groups", "SaeGroups", "SaeGroups", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:dtim-period:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DtimPeriod">"DtimPeriod"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("dtim-period", "DtimPeriod", "DtimPeriod", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:beacon-int:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BeaconInt">"BeaconInt"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("beacon-int", "BeaconInt", "BeaconInt", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:ap-vendor-elements:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ApVendorElements">"ApVendorElements"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ap-vendor-elements", "ApVendorElements", "ApVendorElements", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:ignore-old-scan-res:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IgnoreOldScanRes">"IgnoreOldScanRes"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ignore-old-scan-res", "IgnoreOldScanRes", "IgnoreOldScanRes", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:freq-list:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FreqList">"FreqList"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("freq-list", "FreqList", "FreqList", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:scan-cur-freq:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ScanCurFreq">"ScanCurFreq"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("scan-cur-freq", "ScanCurFreq", "ScanCurFreq", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:sched-scan-interval:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SchedScanInterval">"SchedScanInterval"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("sched-scan-interval", "SchedScanInterval", "SchedScanInterval", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:sched-scan-start-delay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SchedScanStartDelay">"SchedScanStartDelay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("sched-scan-start-delay", "SchedScanStartDelay", "SchedScanStartDelay", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:tdls-external-control:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.TdlsExternalControl">"TdlsExternalControl"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("tdls-external-control", "TdlsExternalControl", "TdlsExternalControl", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:osu-dir:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OsuDir">"OsuDir"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("osu-dir", "OsuDir", "OsuDir", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:wowlan-triggers:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WowlanTriggers">"WowlanTriggers"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("wowlan-triggers", "WowlanTriggers", "WowlanTriggers", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:p2p-search-delay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pSearchDelay">"P2pSearchDelay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("p2p-search-delay", "P2pSearchDelay", "P2pSearchDelay", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:mac-addr:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.MacAddr">"MacAddr"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("mac-addr", "MacAddr", "MacAddr", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:rand-addr-lifetime:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.RandAddrLifetime">"RandAddrLifetime"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("rand-addr-lifetime", "RandAddrLifetime", "RandAddrLifetime", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:preassoc-mac-addr:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PreassocMacAddr">"PreassocMacAddr"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("preassoc-mac-addr", "PreassocMacAddr", "PreassocMacAddr", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:key-mgmt-offload:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.KeyMgmtOffload">"KeyMgmtOffload"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("key-mgmt-offload", "KeyMgmtOffload", "KeyMgmtOffload", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:passive-scan:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PassiveScan">"PassiveScan"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("passive-scan", "PassiveScan", "PassiveScan", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:reassoc-same-bss-optim:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ReassocSameBssOptim">"ReassocSameBssOptim"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("reassoc-same-bss-optim", "ReassocSameBssOptim", "ReassocSameBssOptim", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:wps-priority:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsPriority">"WpsPriority"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("wps-priority", "WpsPriority", "WpsPriority", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:cert-in-cb:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CertInCb">"CertInCb"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("cert-in-cb", "CertInCb", "CertInCb", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:wpa-rsc-relaxation:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpaRscRelaxation">"WpaRscRelaxation"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("wpa-rsc-relaxation", "WpaRscRelaxation", "WpaRscRelaxation", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:sched-scan-plans:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SchedScanPlans">"SchedScanPlans"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("sched-scan-plans", "SchedScanPlans", "SchedScanPlans", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:gas-address3:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GasAddress3">"GasAddress3"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("gas-address3", "GasAddress3", "GasAddress3", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:ftm-responder:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FtmResponder">"FtmResponder"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ftm-responder", "FtmResponder", "FtmResponder", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:ftm-initiator:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FtmInitiator">"FtmInitiator"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ftm-initiator", "FtmInitiator", "FtmInitiator", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:gas-rand-addr-lifetime:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GasRandAddrLifetime">"GasRandAddrLifetime"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("gas-rand-addr-lifetime", "GasRandAddrLifetime", "GasRandAddrLifetime", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:gas-rand-mac-addr:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GasRandMacAddr">"GasRandMacAddr"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("gas-rand-mac-addr", "GasRandMacAddr", "GasRandMacAddr", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceFiW1Wpa_supplicant1Interface:dpp-config-processing:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DppConfigProcessing">"DppConfigProcessing"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("dpp-config-processing", "DppConfigProcessing", "DppConfigProcessing", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_capabilities: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Capabilities">"Capabilities"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_capabilities() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_capabilities (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_capabilities (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_capabilities: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Capabilities">"Capabilities"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_capabilities (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "capabilities", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_capabilities: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Capabilities">"Capabilities"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_capabilities (wpainterfaceFiW1Wpa_supplicant1Interface *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "capabilities", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_state: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.State">"State"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_state() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_state (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_state (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_state: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.State">"State"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_state (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "state", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_state: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.State">"State"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_state (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "state", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_scanning: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Scanning">"Scanning"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
wpa_interface_fi_w1_wpa_supplicant1_interface_get_scanning (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_scanning (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_scanning: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Scanning">"Scanning"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_scanning (wpainterfaceFiW1Wpa_supplicant1Interface *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "scanning", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_ap_scan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ApScan">"ApScan"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guint 
wpa_interface_fi_w1_wpa_supplicant1_interface_get_ap_scan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_ap_scan (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_ap_scan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ApScan">"ApScan"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_ap_scan (wpainterfaceFiW1Wpa_supplicant1Interface *object, guint value)
{
  g_object_set (G_OBJECT (object), "ap-scan", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_bssexpire_age: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BSSExpireAge">"BSSExpireAge"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guint 
wpa_interface_fi_w1_wpa_supplicant1_interface_get_bssexpire_age (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_bssexpire_age (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_bssexpire_age: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BSSExpireAge">"BSSExpireAge"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_bssexpire_age (wpainterfaceFiW1Wpa_supplicant1Interface *object, guint value)
{
  g_object_set (G_OBJECT (object), "bssexpire-age", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_bssexpire_count: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BSSExpireCount">"BSSExpireCount"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
guint 
wpa_interface_fi_w1_wpa_supplicant1_interface_get_bssexpire_count (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_bssexpire_count (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_bssexpire_count: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BSSExpireCount">"BSSExpireCount"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_bssexpire_count (wpainterfaceFiW1Wpa_supplicant1Interface *object, guint value)
{
  g_object_set (G_OBJECT (object), "bssexpire-count", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_country: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Country">"Country"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_country() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_country (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_country (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_country: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Country">"Country"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_country (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "country", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_country: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Country">"Country"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_country (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "country", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_ifname: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Ifname">"Ifname"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ifname() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_ifname (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_ifname (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ifname: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Ifname">"Ifname"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ifname (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ifname", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_ifname: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Ifname">"Ifname"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_ifname (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ifname", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_driver: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Driver">"Driver"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_driver() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_driver (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_driver (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_driver: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Driver">"Driver"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_driver (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "driver", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_driver: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Driver">"Driver"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_driver (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "driver", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_bridge_ifname: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BridgeIfname">"BridgeIfname"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_bridge_ifname() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_bridge_ifname (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_bridge_ifname (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_bridge_ifname: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BridgeIfname">"BridgeIfname"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_bridge_ifname (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "bridge-ifname", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_bridge_ifname: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BridgeIfname">"BridgeIfname"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_bridge_ifname (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "bridge-ifname", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_config_file: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ConfigFile">"ConfigFile"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_config_file() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_config_file (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_config_file (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_config_file: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ConfigFile">"ConfigFile"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_config_file (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "config-file", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_config_file: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ConfigFile">"ConfigFile"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_config_file (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "config-file", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_current_bss: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CurrentBSS">"CurrentBSS"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_current_bss() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_current_bss (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_current_bss (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_current_bss: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CurrentBSS">"CurrentBSS"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_current_bss (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "current-bss", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_current_bss: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CurrentBSS">"CurrentBSS"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_current_bss (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "current-bss", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_current_network: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CurrentNetwork">"CurrentNetwork"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_current_network() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_current_network (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_current_network (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_current_network: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CurrentNetwork">"CurrentNetwork"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_current_network (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "current-network", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_current_network: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CurrentNetwork">"CurrentNetwork"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_current_network (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "current-network", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_current_auth_mode: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CurrentAuthMode">"CurrentAuthMode"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_current_auth_mode() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_current_auth_mode (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_current_auth_mode (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_current_auth_mode: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CurrentAuthMode">"CurrentAuthMode"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_current_auth_mode (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "current-auth-mode", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_current_auth_mode: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CurrentAuthMode">"CurrentAuthMode"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_current_auth_mode (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "current-auth-mode", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_blobs: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Blobs">"Blobs"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_blobs() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_blobs (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_blobs (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_blobs: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Blobs">"Blobs"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_blobs (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "blobs", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_blobs: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Blobs">"Blobs"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_blobs (wpainterfaceFiW1Wpa_supplicant1Interface *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "blobs", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_bsss: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BSSs">"BSSs"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_bsss() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_bsss (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_bsss (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_bsss: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BSSs">"BSSs"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_bsss (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "bsss", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_bsss: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BSSs">"BSSs"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_bsss (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "bsss", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_networks: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Networks">"Networks"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_networks() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_networks (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_networks (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_networks: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Networks">"Networks"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_networks (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "networks", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_networks: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Networks">"Networks"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_networks (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "networks", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_fast_reauth: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FastReauth">"FastReauth"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
wpa_interface_fi_w1_wpa_supplicant1_interface_get_fast_reauth (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_fast_reauth (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_fast_reauth: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FastReauth">"FastReauth"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_fast_reauth (wpainterfaceFiW1Wpa_supplicant1Interface *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "fast-reauth", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_scan_interval: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ScanInterval">"ScanInterval"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
wpa_interface_fi_w1_wpa_supplicant1_interface_get_scan_interval (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_scan_interval (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_scan_interval: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ScanInterval">"ScanInterval"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_scan_interval (wpainterfaceFiW1Wpa_supplicant1Interface *object, gint value)
{
  g_object_set (G_OBJECT (object), "scan-interval", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_pkcs11_engine_path: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PKCS11EnginePath">"PKCS11EnginePath"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pkcs11_engine_path() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_pkcs11_engine_path (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_pkcs11_engine_path (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pkcs11_engine_path: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PKCS11EnginePath">"PKCS11EnginePath"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pkcs11_engine_path (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "pkcs11-engine-path", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_pkcs11_engine_path: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PKCS11EnginePath">"PKCS11EnginePath"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_pkcs11_engine_path (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "pkcs11-engine-path", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_pkcs11_module_path: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PKCS11ModulePath">"PKCS11ModulePath"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pkcs11_module_path() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_pkcs11_module_path (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_pkcs11_module_path (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pkcs11_module_path: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PKCS11ModulePath">"PKCS11ModulePath"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pkcs11_module_path (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "pkcs11-module-path", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_pkcs11_module_path: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PKCS11ModulePath">"PKCS11ModulePath"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_pkcs11_module_path (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "pkcs11-module-path", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_disconnect_reason: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DisconnectReason">"DisconnectReason"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
wpa_interface_fi_w1_wpa_supplicant1_interface_get_disconnect_reason (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_disconnect_reason (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_disconnect_reason: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DisconnectReason">"DisconnectReason"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_disconnect_reason (wpainterfaceFiW1Wpa_supplicant1Interface *object, gint value)
{
  g_object_set (G_OBJECT (object), "disconnect-reason", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_assoc_status_code: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AssocStatusCode">"AssocStatusCode"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gint 
wpa_interface_fi_w1_wpa_supplicant1_interface_get_assoc_status_code (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_assoc_status_code (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_assoc_status_code: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AssocStatusCode">"AssocStatusCode"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_assoc_status_code (wpainterfaceFiW1Wpa_supplicant1Interface *object, gint value)
{
  g_object_set (G_OBJECT (object), "assoc-status-code", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_ctrl_interface: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CtrlInterface">"CtrlInterface"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ctrl_interface() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_ctrl_interface (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_ctrl_interface (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ctrl_interface: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CtrlInterface">"CtrlInterface"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ctrl_interface (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ctrl-interface", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_ctrl_interface: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CtrlInterface">"CtrlInterface"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_ctrl_interface (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ctrl-interface", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_ctrl_interface_group: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CtrlInterfaceGroup">"CtrlInterfaceGroup"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ctrl_interface_group() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_ctrl_interface_group (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_ctrl_interface_group (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ctrl_interface_group: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CtrlInterfaceGroup">"CtrlInterfaceGroup"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ctrl_interface_group (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ctrl-interface-group", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_ctrl_interface_group: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CtrlInterfaceGroup">"CtrlInterfaceGroup"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_ctrl_interface_group (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ctrl-interface-group", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_eapol_version: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.EapolVersion">"EapolVersion"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_eapol_version() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_eapol_version (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_eapol_version (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_eapol_version: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.EapolVersion">"EapolVersion"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_eapol_version (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "eapol-version", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_eapol_version: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.EapolVersion">"EapolVersion"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_eapol_version (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "eapol-version", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_bgscan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Bgscan">"Bgscan"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_bgscan() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_bgscan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_bgscan (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_bgscan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Bgscan">"Bgscan"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_bgscan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "bgscan", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_bgscan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Bgscan">"Bgscan"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_bgscan (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "bgscan", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_disable_scan_offload: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DisableScanOffload">"DisableScanOffload"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_disable_scan_offload() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_disable_scan_offload (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_disable_scan_offload (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_disable_scan_offload: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DisableScanOffload">"DisableScanOffload"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_disable_scan_offload (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "disable-scan-offload", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_disable_scan_offload: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DisableScanOffload">"DisableScanOffload"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_disable_scan_offload (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "disable-scan-offload", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_opensc_engine_path: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OpenscEnginePath">"OpenscEnginePath"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_opensc_engine_path() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_opensc_engine_path (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_opensc_engine_path (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_opensc_engine_path: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OpenscEnginePath">"OpenscEnginePath"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_opensc_engine_path (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "opensc-engine-path", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_opensc_engine_path: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OpenscEnginePath">"OpenscEnginePath"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_opensc_engine_path (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "opensc-engine-path", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_openssl_ciphers: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OpensslCiphers">"OpensslCiphers"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_openssl_ciphers() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_openssl_ciphers (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_openssl_ciphers (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_openssl_ciphers: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OpensslCiphers">"OpensslCiphers"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_openssl_ciphers (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "openssl-ciphers", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_openssl_ciphers: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OpensslCiphers">"OpensslCiphers"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_openssl_ciphers (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "openssl-ciphers", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_pcsc_reader: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PcscReader">"PcscReader"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pcsc_reader() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_pcsc_reader (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_pcsc_reader (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pcsc_reader: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PcscReader">"PcscReader"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pcsc_reader (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "pcsc-reader", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_pcsc_reader: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PcscReader">"PcscReader"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_pcsc_reader (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "pcsc-reader", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_pcsc_pin: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PcscPin">"PcscPin"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pcsc_pin() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_pcsc_pin (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_pcsc_pin (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pcsc_pin: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PcscPin">"PcscPin"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pcsc_pin (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "pcsc-pin", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_pcsc_pin: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PcscPin">"PcscPin"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_pcsc_pin (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "pcsc-pin", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_external_sim: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ExternalSim">"ExternalSim"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_external_sim() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_external_sim (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_external_sim (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_external_sim: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ExternalSim">"ExternalSim"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_external_sim (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "external-sim", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_external_sim: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ExternalSim">"ExternalSim"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_external_sim (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "external-sim", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_driver_param: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DriverParam">"DriverParam"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_driver_param() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_driver_param (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_driver_param (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_driver_param: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DriverParam">"DriverParam"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_driver_param (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "driver-param", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_driver_param: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DriverParam">"DriverParam"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_driver_param (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "driver-param", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_dot11_rsnaconfig_pmklifetime: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Dot11RSNAConfigPMKLifetime">"Dot11RSNAConfigPMKLifetime"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dot11_rsnaconfig_pmklifetime() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_dot11_rsnaconfig_pmklifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_dot11_rsnaconfig_pmklifetime (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dot11_rsnaconfig_pmklifetime: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Dot11RSNAConfigPMKLifetime">"Dot11RSNAConfigPMKLifetime"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dot11_rsnaconfig_pmklifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "dot11-rsnaconfig-pmklifetime", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_dot11_rsnaconfig_pmklifetime: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Dot11RSNAConfigPMKLifetime">"Dot11RSNAConfigPMKLifetime"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_dot11_rsnaconfig_pmklifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "dot11-rsnaconfig-pmklifetime", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_dot11_rsnaconfig_pmkreauth_threshold: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Dot11RSNAConfigPMKReauthThreshold">"Dot11RSNAConfigPMKReauthThreshold"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dot11_rsnaconfig_pmkreauth_threshold() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_dot11_rsnaconfig_pmkreauth_threshold (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_dot11_rsnaconfig_pmkreauth_threshold (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dot11_rsnaconfig_pmkreauth_threshold: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Dot11RSNAConfigPMKReauthThreshold">"Dot11RSNAConfigPMKReauthThreshold"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dot11_rsnaconfig_pmkreauth_threshold (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "dot11-rsnaconfig-pmkreauth-threshold", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_dot11_rsnaconfig_pmkreauth_threshold: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Dot11RSNAConfigPMKReauthThreshold">"Dot11RSNAConfigPMKReauthThreshold"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_dot11_rsnaconfig_pmkreauth_threshold (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "dot11-rsnaconfig-pmkreauth-threshold", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_dot11_rsnaconfig_satimeout: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Dot11RSNAConfigSATimeout">"Dot11RSNAConfigSATimeout"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dot11_rsnaconfig_satimeout() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_dot11_rsnaconfig_satimeout (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_dot11_rsnaconfig_satimeout (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dot11_rsnaconfig_satimeout: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Dot11RSNAConfigSATimeout">"Dot11RSNAConfigSATimeout"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dot11_rsnaconfig_satimeout (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "dot11-rsnaconfig-satimeout", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_dot11_rsnaconfig_satimeout: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Dot11RSNAConfigSATimeout">"Dot11RSNAConfigSATimeout"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_dot11_rsnaconfig_satimeout (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "dot11-rsnaconfig-satimeout", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_update_config: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.UpdateConfig">"UpdateConfig"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_update_config() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_update_config (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_update_config (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_update_config: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.UpdateConfig">"UpdateConfig"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_update_config (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "update-config", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_update_config: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.UpdateConfig">"UpdateConfig"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_update_config (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "update-config", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_uuid: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Uuid">"Uuid"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_uuid() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_uuid (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_uuid (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_uuid: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Uuid">"Uuid"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_uuid (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "uuid", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_uuid: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Uuid">"Uuid"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_uuid (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "uuid", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_auto_uuid: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AutoUuid">"AutoUuid"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_auto_uuid() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_auto_uuid (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_auto_uuid (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_auto_uuid: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AutoUuid">"AutoUuid"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_auto_uuid (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "auto-uuid", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_auto_uuid: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AutoUuid">"AutoUuid"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_auto_uuid (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "auto-uuid", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_device_name: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DeviceName">"DeviceName"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_device_name() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_device_name (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_device_name (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_device_name: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DeviceName">"DeviceName"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_device_name (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "device-name", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_device_name: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DeviceName">"DeviceName"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_device_name (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "device-name", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_manufacturer: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Manufacturer">"Manufacturer"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_manufacturer() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_manufacturer (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_manufacturer (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_manufacturer: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Manufacturer">"Manufacturer"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_manufacturer (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "manufacturer", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_manufacturer: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Manufacturer">"Manufacturer"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_manufacturer (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "manufacturer", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_model_name: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ModelName">"ModelName"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_model_name() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_model_name (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_model_name (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_model_name: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ModelName">"ModelName"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_model_name (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "model-name", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_model_name: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ModelName">"ModelName"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_model_name (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "model-name", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_model_number: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ModelNumber">"ModelNumber"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_model_number() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_model_number (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_model_number (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_model_number: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ModelNumber">"ModelNumber"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_model_number (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "model-number", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_model_number: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ModelNumber">"ModelNumber"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_model_number (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "model-number", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_serial_number: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SerialNumber">"SerialNumber"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_serial_number() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_serial_number (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_serial_number (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_serial_number: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SerialNumber">"SerialNumber"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_serial_number (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "serial-number", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_serial_number: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SerialNumber">"SerialNumber"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_serial_number (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "serial-number", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_device_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DeviceType">"DeviceType"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_device_type() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_device_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_device_type (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_device_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DeviceType">"DeviceType"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_device_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "device-type", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_device_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DeviceType">"DeviceType"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_device_type (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "device-type", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_os_version: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OsVersion">"OsVersion"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_os_version() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_os_version (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_os_version (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_os_version: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OsVersion">"OsVersion"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_os_version (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "os-version", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_os_version: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OsVersion">"OsVersion"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_os_version (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "os-version", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_config_methods: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ConfigMethods">"ConfigMethods"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_config_methods() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_config_methods (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_config_methods (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_config_methods: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ConfigMethods">"ConfigMethods"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_config_methods (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "config-methods", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_config_methods: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ConfigMethods">"ConfigMethods"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_config_methods (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "config-methods", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_cred_processing: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsCredProcessing">"WpsCredProcessing"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_cred_processing() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_cred_processing (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_wps_cred_processing (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_cred_processing: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsCredProcessing">"WpsCredProcessing"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_cred_processing (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "wps-cred-processing", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_cred_processing: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsCredProcessing">"WpsCredProcessing"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_cred_processing (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "wps-cred-processing", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_vendor_ext_m1: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsVendorExtM1">"WpsVendorExtM1"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_vendor_ext_m1() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_vendor_ext_m1 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_wps_vendor_ext_m1 (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_vendor_ext_m1: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsVendorExtM1">"WpsVendorExtM1"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_vendor_ext_m1 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "wps-vendor-ext-m1", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_vendor_ext_m1: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsVendorExtM1">"WpsVendorExtM1"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_vendor_ext_m1 (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "wps-vendor-ext-m1", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_sec_device_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SecDeviceType">"SecDeviceType"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sec_device_type() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_sec_device_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_sec_device_type (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sec_device_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SecDeviceType">"SecDeviceType"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sec_device_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "sec-device-type", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_sec_device_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SecDeviceType">"SecDeviceType"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_sec_device_type (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "sec-device-type", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_listen_reg_class: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pListenRegClass">"P2pListenRegClass"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_listen_reg_class() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_listen_reg_class (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_listen_reg_class (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_listen_reg_class: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pListenRegClass">"P2pListenRegClass"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_listen_reg_class (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-listen-reg-class", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_listen_reg_class: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pListenRegClass">"P2pListenRegClass"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_listen_reg_class (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-listen-reg-class", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_listen_channel: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pListenChannel">"P2pListenChannel"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_listen_channel() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_listen_channel (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_listen_channel (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_listen_channel: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pListenChannel">"P2pListenChannel"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_listen_channel (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-listen-channel", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_listen_channel: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pListenChannel">"P2pListenChannel"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_listen_channel (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-listen-channel", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_oper_reg_class: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pOperRegClass">"P2pOperRegClass"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_oper_reg_class() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_oper_reg_class (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_oper_reg_class (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_oper_reg_class: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pOperRegClass">"P2pOperRegClass"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_oper_reg_class (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-oper-reg-class", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_oper_reg_class: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pOperRegClass">"P2pOperRegClass"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_oper_reg_class (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-oper-reg-class", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_oper_channel: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pOperChannel">"P2pOperChannel"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_oper_channel() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_oper_channel (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_oper_channel (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_oper_channel: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pOperChannel">"P2pOperChannel"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_oper_channel (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-oper-channel", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_oper_channel: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pOperChannel">"P2pOperChannel"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_oper_channel (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-oper-channel", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_go_intent: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoIntent">"P2pGoIntent"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_intent() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_go_intent (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_go_intent (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_intent: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoIntent">"P2pGoIntent"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_intent (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-go-intent", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_go_intent: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoIntent">"P2pGoIntent"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_go_intent (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-go-intent", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_ssid_postfix: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pSsidPostfix">"P2pSsidPostfix"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_ssid_postfix() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_ssid_postfix (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_ssid_postfix (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_ssid_postfix: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pSsidPostfix">"P2pSsidPostfix"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_ssid_postfix (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-ssid-postfix", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_ssid_postfix: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pSsidPostfix">"P2pSsidPostfix"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_ssid_postfix (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-ssid-postfix", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_persistent_reconnect: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PersistentReconnect">"PersistentReconnect"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_persistent_reconnect() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_persistent_reconnect (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_persistent_reconnect (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_persistent_reconnect: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PersistentReconnect">"PersistentReconnect"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_persistent_reconnect (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "persistent-reconnect", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_persistent_reconnect: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PersistentReconnect">"PersistentReconnect"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_persistent_reconnect (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "persistent-reconnect", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_intra_bss: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pIntraBss">"P2pIntraBss"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_intra_bss() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_intra_bss (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_intra_bss (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_intra_bss: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pIntraBss">"P2pIntraBss"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_intra_bss (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-intra-bss", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_intra_bss: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pIntraBss">"P2pIntraBss"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_intra_bss (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-intra-bss", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_group_idle: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGroupIdle">"P2pGroupIdle"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_group_idle() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_group_idle (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_group_idle (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_group_idle: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGroupIdle">"P2pGroupIdle"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_group_idle (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-group-idle", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_group_idle: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGroupIdle">"P2pGroupIdle"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_group_idle (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-group-idle", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_go_freq_change_policy: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoFreqChangePolicy">"P2pGoFreqChangePolicy"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_freq_change_policy() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_go_freq_change_policy (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_go_freq_change_policy (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_freq_change_policy: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoFreqChangePolicy">"P2pGoFreqChangePolicy"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_freq_change_policy (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-go-freq-change-policy", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_go_freq_change_policy: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoFreqChangePolicy">"P2pGoFreqChangePolicy"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_go_freq_change_policy (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-go-freq-change-policy", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_passphrase_len: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pPassphraseLen">"P2pPassphraseLen"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_passphrase_len() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_passphrase_len (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_passphrase_len (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_passphrase_len: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pPassphraseLen">"P2pPassphraseLen"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_passphrase_len (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-passphrase-len", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_passphrase_len: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pPassphraseLen">"P2pPassphraseLen"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_passphrase_len (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-passphrase-len", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_pref_chan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pPrefChan">"P2pPrefChan"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_pref_chan() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_pref_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_pref_chan (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_pref_chan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pPrefChan">"P2pPrefChan"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_pref_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-pref-chan", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_pref_chan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pPrefChan">"P2pPrefChan"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_pref_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-pref-chan", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_no_go_freq: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pNoGoFreq">"P2pNoGoFreq"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_no_go_freq() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_no_go_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_no_go_freq (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_no_go_freq: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pNoGoFreq">"P2pNoGoFreq"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_no_go_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-no-go-freq", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_no_go_freq: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pNoGoFreq">"P2pNoGoFreq"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_no_go_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-no-go-freq", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_add_cli_chan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pAddCliChan">"P2pAddCliChan"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_add_cli_chan() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_add_cli_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_add_cli_chan (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_add_cli_chan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pAddCliChan">"P2pAddCliChan"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_add_cli_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-add-cli-chan", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_add_cli_chan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pAddCliChan">"P2pAddCliChan"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_add_cli_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-add-cli-chan", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_optimize_listen_chan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pOptimizeListenChan">"P2pOptimizeListenChan"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_optimize_listen_chan() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_optimize_listen_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_optimize_listen_chan (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_optimize_listen_chan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pOptimizeListenChan">"P2pOptimizeListenChan"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_optimize_listen_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-optimize-listen-chan", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_optimize_listen_chan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pOptimizeListenChan">"P2pOptimizeListenChan"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_optimize_listen_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-optimize-listen-chan", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_go_ht40: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoHt40">"P2pGoHt40"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_ht40() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_go_ht40 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_go_ht40 (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_ht40: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoHt40">"P2pGoHt40"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_ht40 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-go-ht40", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_go_ht40: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoHt40">"P2pGoHt40"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_go_ht40 (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-go-ht40", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_go_vht: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoVht">"P2pGoVht"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_vht() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_go_vht (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_go_vht (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_vht: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoVht">"P2pGoVht"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_vht (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-go-vht", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_go_vht: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoVht">"P2pGoVht"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_go_vht (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-go-vht", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_disabled: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pDisabled">"P2pDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_disabled() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_disabled (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_disabled (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_disabled: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pDisabled">"P2pDisabled"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_disabled (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-disabled", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_disabled: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pDisabled">"P2pDisabled"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_disabled (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-disabled", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_go_ctwindow: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoCtwindow">"P2pGoCtwindow"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_ctwindow() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_go_ctwindow (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_go_ctwindow (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_ctwindow: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoCtwindow">"P2pGoCtwindow"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_ctwindow (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-go-ctwindow", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_go_ctwindow: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoCtwindow">"P2pGoCtwindow"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_go_ctwindow (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-go-ctwindow", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_no_group_iface: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pNoGroupIface">"P2pNoGroupIface"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_no_group_iface() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_no_group_iface (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_no_group_iface (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_no_group_iface: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pNoGroupIface">"P2pNoGroupIface"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_no_group_iface (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-no-group-iface", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_no_group_iface: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pNoGroupIface">"P2pNoGroupIface"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_no_group_iface (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-no-group-iface", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_ignore_shared_freq: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pIgnoreSharedFreq">"P2pIgnoreSharedFreq"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_ignore_shared_freq() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_ignore_shared_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_ignore_shared_freq (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_ignore_shared_freq: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pIgnoreSharedFreq">"P2pIgnoreSharedFreq"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_ignore_shared_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-ignore-shared-freq", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_ignore_shared_freq: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pIgnoreSharedFreq">"P2pIgnoreSharedFreq"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_ignore_shared_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-ignore-shared-freq", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_ip_addr_go: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrGo">"IpAddrGo"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ip_addr_go() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_ip_addr_go (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_ip_addr_go (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ip_addr_go: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrGo">"IpAddrGo"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ip_addr_go (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ip-addr-go", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_ip_addr_go: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrGo">"IpAddrGo"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_ip_addr_go (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ip-addr-go", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_ip_addr_mask: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrMask">"IpAddrMask"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ip_addr_mask() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_ip_addr_mask (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_ip_addr_mask (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ip_addr_mask: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrMask">"IpAddrMask"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ip_addr_mask (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ip-addr-mask", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_ip_addr_mask: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrMask">"IpAddrMask"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_ip_addr_mask (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ip-addr-mask", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_ip_addr_start: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrStart">"IpAddrStart"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ip_addr_start() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_ip_addr_start (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_ip_addr_start (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ip_addr_start: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrStart">"IpAddrStart"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ip_addr_start (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ip-addr-start", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_ip_addr_start: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrStart">"IpAddrStart"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_ip_addr_start (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ip-addr-start", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_ip_addr_end: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrEnd">"IpAddrEnd"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ip_addr_end() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_ip_addr_end (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_ip_addr_end (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ip_addr_end: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrEnd">"IpAddrEnd"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ip_addr_end (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ip-addr-end", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_ip_addr_end: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IpAddrEnd">"IpAddrEnd"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_ip_addr_end (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ip-addr-end", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_cli_probe: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pCliProbe">"P2pCliProbe"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_cli_probe() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_cli_probe (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_cli_probe (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_cli_probe: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pCliProbe">"P2pCliProbe"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_cli_probe (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-cli-probe", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_cli_probe: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pCliProbe">"P2pCliProbe"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_cli_probe (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-cli-probe", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_bss_max_count: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BssMaxCount">"BssMaxCount"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_bss_max_count() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_bss_max_count (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_bss_max_count (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_bss_max_count: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BssMaxCount">"BssMaxCount"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_bss_max_count (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "bss-max-count", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_bss_max_count: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BssMaxCount">"BssMaxCount"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_bss_max_count (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "bss-max-count", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_filter_ssids: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FilterSsids">"FilterSsids"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_filter_ssids() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_filter_ssids (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_filter_ssids (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_filter_ssids: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FilterSsids">"FilterSsids"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_filter_ssids (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "filter-ssids", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_filter_ssids: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FilterSsids">"FilterSsids"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_filter_ssids (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "filter-ssids", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_filter_rssi: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FilterRssi">"FilterRssi"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_filter_rssi() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_filter_rssi (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_filter_rssi (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_filter_rssi: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FilterRssi">"FilterRssi"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_filter_rssi (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "filter-rssi", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_filter_rssi: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FilterRssi">"FilterRssi"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_filter_rssi (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "filter-rssi", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_max_num_sta: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.MaxNumSta">"MaxNumSta"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_max_num_sta() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_max_num_sta (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_max_num_sta (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_max_num_sta: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.MaxNumSta">"MaxNumSta"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_max_num_sta (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "max-num-sta", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_max_num_sta: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.MaxNumSta">"MaxNumSta"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_max_num_sta (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "max-num-sta", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_disassoc_low_ack: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DisassocLowAck">"DisassocLowAck"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_disassoc_low_ack() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_disassoc_low_ack (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_disassoc_low_ack (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_disassoc_low_ack: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DisassocLowAck">"DisassocLowAck"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_disassoc_low_ack (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "disassoc-low-ack", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_disassoc_low_ack: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DisassocLowAck">"DisassocLowAck"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_disassoc_low_ack (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "disassoc-low-ack", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_interworking: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Interworking">"Interworking"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_interworking() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_interworking (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_interworking: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Interworking">"Interworking"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "interworking", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_interworking: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Interworking">"Interworking"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "interworking", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_hessid: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Hessid">"Hessid"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_hessid() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_hessid (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_hessid (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_hessid: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Hessid">"Hessid"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_hessid (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "hessid", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_hessid: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Hessid">"Hessid"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_hessid (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "hessid", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_access_network_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AccessNetworkType">"AccessNetworkType"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_access_network_type() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_access_network_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_access_network_type (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_access_network_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AccessNetworkType">"AccessNetworkType"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_access_network_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "access-network-type", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_access_network_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AccessNetworkType">"AccessNetworkType"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_access_network_type (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "access-network-type", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_go_interworking: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoInterworking">"GoInterworking"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_interworking() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_go_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_go_interworking (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_interworking: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoInterworking">"GoInterworking"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "go-interworking", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_go_interworking: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoInterworking">"GoInterworking"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_go_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "go-interworking", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_go_access_network_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoAccessNetworkType">"GoAccessNetworkType"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_access_network_type() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_go_access_network_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_go_access_network_type (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_access_network_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoAccessNetworkType">"GoAccessNetworkType"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_access_network_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "go-access-network-type", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_go_access_network_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoAccessNetworkType">"GoAccessNetworkType"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_go_access_network_type (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "go-access-network-type", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_go_internet: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoInternet">"GoInternet"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_internet() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_go_internet (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_go_internet (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_internet: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoInternet">"GoInternet"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_internet (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "go-internet", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_go_internet: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoInternet">"GoInternet"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_go_internet (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "go-internet", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_go_venue_group: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoVenueGroup">"GoVenueGroup"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_venue_group() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_go_venue_group (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_go_venue_group (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_venue_group: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoVenueGroup">"GoVenueGroup"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_venue_group (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "go-venue-group", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_go_venue_group: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoVenueGroup">"GoVenueGroup"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_go_venue_group (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "go-venue-group", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_go_venue_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoVenueType">"GoVenueType"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_venue_type() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_go_venue_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_go_venue_type (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_venue_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoVenueType">"GoVenueType"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_go_venue_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "go-venue-type", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_go_venue_type: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GoVenueType">"GoVenueType"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_go_venue_type (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "go-venue-type", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_pbc_in_m1: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PbcInM1">"PbcInM1"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pbc_in_m1() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_pbc_in_m1 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_pbc_in_m1 (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pbc_in_m1: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PbcInM1">"PbcInM1"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pbc_in_m1 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "pbc-in-m1", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_pbc_in_m1: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PbcInM1">"PbcInM1"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_pbc_in_m1 (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "pbc-in-m1", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_autoscan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Autoscan">"Autoscan"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_autoscan() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_autoscan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_autoscan (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_autoscan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Autoscan">"Autoscan"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_autoscan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "autoscan", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_autoscan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Autoscan">"Autoscan"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_autoscan (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "autoscan", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_nfc_dev_pw_id: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDevPwId">"WpsNfcDevPwId"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_nfc_dev_pw_id() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_nfc_dev_pw_id (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_wps_nfc_dev_pw_id (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_nfc_dev_pw_id: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDevPwId">"WpsNfcDevPwId"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_nfc_dev_pw_id (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "wps-nfc-dev-pw-id", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_nfc_dev_pw_id: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDevPwId">"WpsNfcDevPwId"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_nfc_dev_pw_id (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "wps-nfc-dev-pw-id", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_nfc_dh_pubkey: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDhPubkey">"WpsNfcDhPubkey"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_nfc_dh_pubkey() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_nfc_dh_pubkey (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_wps_nfc_dh_pubkey (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_nfc_dh_pubkey: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDhPubkey">"WpsNfcDhPubkey"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_nfc_dh_pubkey (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "wps-nfc-dh-pubkey", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_nfc_dh_pubkey: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDhPubkey">"WpsNfcDhPubkey"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_nfc_dh_pubkey (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "wps-nfc-dh-pubkey", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_nfc_dh_privkey: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDhPrivkey">"WpsNfcDhPrivkey"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_nfc_dh_privkey() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_nfc_dh_privkey (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_wps_nfc_dh_privkey (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_nfc_dh_privkey: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDhPrivkey">"WpsNfcDhPrivkey"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_nfc_dh_privkey (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "wps-nfc-dh-privkey", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_nfc_dh_privkey: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDhPrivkey">"WpsNfcDhPrivkey"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_nfc_dh_privkey (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "wps-nfc-dh-privkey", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_nfc_dev_pw: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDevPw">"WpsNfcDevPw"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_nfc_dev_pw() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_nfc_dev_pw (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_wps_nfc_dev_pw (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_nfc_dev_pw: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDevPw">"WpsNfcDevPw"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_nfc_dev_pw (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "wps-nfc-dev-pw", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_nfc_dev_pw: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsNfcDevPw">"WpsNfcDevPw"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_nfc_dev_pw (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "wps-nfc-dev-pw", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_ext_password_backend: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ExtPasswordBackend">"ExtPasswordBackend"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ext_password_backend() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_ext_password_backend (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_ext_password_backend (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ext_password_backend: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ExtPasswordBackend">"ExtPasswordBackend"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ext_password_backend (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ext-password-backend", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_ext_password_backend: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ExtPasswordBackend">"ExtPasswordBackend"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_ext_password_backend (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ext-password-backend", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_go_max_inactivity: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoMaxInactivity">"P2pGoMaxInactivity"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_max_inactivity() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_go_max_inactivity (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_go_max_inactivity (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_max_inactivity: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoMaxInactivity">"P2pGoMaxInactivity"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_go_max_inactivity (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-go-max-inactivity", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_go_max_inactivity: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pGoMaxInactivity">"P2pGoMaxInactivity"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_go_max_inactivity (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-go-max-inactivity", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_auto_interworking: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AutoInterworking">"AutoInterworking"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_auto_interworking() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_auto_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_auto_interworking (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_auto_interworking: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AutoInterworking">"AutoInterworking"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_auto_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "auto-interworking", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_auto_interworking: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.AutoInterworking">"AutoInterworking"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_auto_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "auto-interworking", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_okc: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Okc">"Okc"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_okc() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_okc (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_okc (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_okc: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Okc">"Okc"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_okc (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "okc", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_okc: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Okc">"Okc"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_okc (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "okc", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_pmf: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Pmf">"Pmf"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pmf() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_pmf (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_pmf (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pmf: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Pmf">"Pmf"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_pmf (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "pmf", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_pmf: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.Pmf">"Pmf"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_pmf (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "pmf", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_sae_groups: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SaeGroups">"SaeGroups"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sae_groups() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_sae_groups (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_sae_groups (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sae_groups: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SaeGroups">"SaeGroups"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sae_groups (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "sae-groups", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_sae_groups: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SaeGroups">"SaeGroups"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_sae_groups (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "sae-groups", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_dtim_period: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DtimPeriod">"DtimPeriod"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dtim_period() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_dtim_period (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_dtim_period (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dtim_period: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DtimPeriod">"DtimPeriod"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dtim_period (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "dtim-period", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_dtim_period: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DtimPeriod">"DtimPeriod"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_dtim_period (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "dtim-period", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_beacon_int: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BeaconInt">"BeaconInt"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_beacon_int() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_beacon_int (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_beacon_int (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_beacon_int: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BeaconInt">"BeaconInt"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_beacon_int (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "beacon-int", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_beacon_int: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.BeaconInt">"BeaconInt"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_beacon_int (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "beacon-int", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_ap_vendor_elements: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ApVendorElements">"ApVendorElements"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ap_vendor_elements() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_ap_vendor_elements (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_ap_vendor_elements (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ap_vendor_elements: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ApVendorElements">"ApVendorElements"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ap_vendor_elements (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ap-vendor-elements", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_ap_vendor_elements: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ApVendorElements">"ApVendorElements"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_ap_vendor_elements (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ap-vendor-elements", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_ignore_old_scan_res: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IgnoreOldScanRes">"IgnoreOldScanRes"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ignore_old_scan_res() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_ignore_old_scan_res (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_ignore_old_scan_res (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ignore_old_scan_res: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IgnoreOldScanRes">"IgnoreOldScanRes"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ignore_old_scan_res (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ignore-old-scan-res", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_ignore_old_scan_res: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.IgnoreOldScanRes">"IgnoreOldScanRes"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_ignore_old_scan_res (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ignore-old-scan-res", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_freq_list: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FreqList">"FreqList"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_freq_list() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_freq_list (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_freq_list (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_freq_list: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FreqList">"FreqList"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_freq_list (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "freq-list", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_freq_list: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FreqList">"FreqList"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_freq_list (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "freq-list", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_scan_cur_freq: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ScanCurFreq">"ScanCurFreq"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_scan_cur_freq() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_scan_cur_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_scan_cur_freq (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_scan_cur_freq: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ScanCurFreq">"ScanCurFreq"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_scan_cur_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "scan-cur-freq", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_scan_cur_freq: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ScanCurFreq">"ScanCurFreq"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_scan_cur_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "scan-cur-freq", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_sched_scan_interval: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SchedScanInterval">"SchedScanInterval"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sched_scan_interval() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_sched_scan_interval (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_sched_scan_interval (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sched_scan_interval: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SchedScanInterval">"SchedScanInterval"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sched_scan_interval (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "sched-scan-interval", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_sched_scan_interval: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SchedScanInterval">"SchedScanInterval"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_sched_scan_interval (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "sched-scan-interval", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_sched_scan_start_delay: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SchedScanStartDelay">"SchedScanStartDelay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sched_scan_start_delay() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_sched_scan_start_delay (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_sched_scan_start_delay (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sched_scan_start_delay: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SchedScanStartDelay">"SchedScanStartDelay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sched_scan_start_delay (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "sched-scan-start-delay", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_sched_scan_start_delay: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SchedScanStartDelay">"SchedScanStartDelay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_sched_scan_start_delay (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "sched-scan-start-delay", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_tdls_external_control: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.TdlsExternalControl">"TdlsExternalControl"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_tdls_external_control() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_tdls_external_control (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_tdls_external_control (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_tdls_external_control: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.TdlsExternalControl">"TdlsExternalControl"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_tdls_external_control (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "tdls-external-control", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_tdls_external_control: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.TdlsExternalControl">"TdlsExternalControl"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_tdls_external_control (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "tdls-external-control", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_osu_dir: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OsuDir">"OsuDir"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_osu_dir() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_osu_dir (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_osu_dir (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_osu_dir: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OsuDir">"OsuDir"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_osu_dir (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "osu-dir", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_osu_dir: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.OsuDir">"OsuDir"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_osu_dir (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "osu-dir", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_wowlan_triggers: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WowlanTriggers">"WowlanTriggers"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wowlan_triggers() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_wowlan_triggers (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_wowlan_triggers (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wowlan_triggers: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WowlanTriggers">"WowlanTriggers"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wowlan_triggers (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "wowlan-triggers", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_wowlan_triggers: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WowlanTriggers">"WowlanTriggers"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_wowlan_triggers (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "wowlan-triggers", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_search_delay: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pSearchDelay">"P2pSearchDelay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_search_delay() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_p2p_search_delay (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_p2p_search_delay (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_search_delay: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pSearchDelay">"P2pSearchDelay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_p2p_search_delay (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "p2p-search-delay", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_search_delay: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.P2pSearchDelay">"P2pSearchDelay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_p2p_search_delay (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "p2p-search-delay", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_mac_addr: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.MacAddr">"MacAddr"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_mac_addr() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_mac_addr (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_mac_addr: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.MacAddr">"MacAddr"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "mac-addr", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_mac_addr: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.MacAddr">"MacAddr"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "mac-addr", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_rand_addr_lifetime: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.RandAddrLifetime">"RandAddrLifetime"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_rand_addr_lifetime() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_rand_addr_lifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_rand_addr_lifetime (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_rand_addr_lifetime: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.RandAddrLifetime">"RandAddrLifetime"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_rand_addr_lifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "rand-addr-lifetime", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_rand_addr_lifetime: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.RandAddrLifetime">"RandAddrLifetime"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_rand_addr_lifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "rand-addr-lifetime", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_preassoc_mac_addr: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PreassocMacAddr">"PreassocMacAddr"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_preassoc_mac_addr() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_preassoc_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_preassoc_mac_addr (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_preassoc_mac_addr: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PreassocMacAddr">"PreassocMacAddr"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_preassoc_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "preassoc-mac-addr", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_preassoc_mac_addr: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PreassocMacAddr">"PreassocMacAddr"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_preassoc_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "preassoc-mac-addr", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_key_mgmt_offload: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.KeyMgmtOffload">"KeyMgmtOffload"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_key_mgmt_offload() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_key_mgmt_offload (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_key_mgmt_offload (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_key_mgmt_offload: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.KeyMgmtOffload">"KeyMgmtOffload"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_key_mgmt_offload (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "key-mgmt-offload", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_key_mgmt_offload: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.KeyMgmtOffload">"KeyMgmtOffload"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_key_mgmt_offload (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "key-mgmt-offload", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_passive_scan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PassiveScan">"PassiveScan"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_passive_scan() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_passive_scan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_passive_scan (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_passive_scan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PassiveScan">"PassiveScan"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_passive_scan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "passive-scan", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_passive_scan: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.PassiveScan">"PassiveScan"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_passive_scan (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "passive-scan", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_reassoc_same_bss_optim: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ReassocSameBssOptim">"ReassocSameBssOptim"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_reassoc_same_bss_optim() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_reassoc_same_bss_optim (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_reassoc_same_bss_optim (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_reassoc_same_bss_optim: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ReassocSameBssOptim">"ReassocSameBssOptim"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_reassoc_same_bss_optim (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "reassoc-same-bss-optim", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_reassoc_same_bss_optim: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.ReassocSameBssOptim">"ReassocSameBssOptim"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_reassoc_same_bss_optim (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "reassoc-same-bss-optim", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_priority: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsPriority">"WpsPriority"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_priority() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_wps_priority (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_wps_priority (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_priority: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsPriority">"WpsPriority"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wps_priority (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "wps-priority", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_priority: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpsPriority">"WpsPriority"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_wps_priority (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "wps-priority", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_cert_in_cb: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CertInCb">"CertInCb"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_cert_in_cb() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_cert_in_cb (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_cert_in_cb (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_cert_in_cb: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CertInCb">"CertInCb"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_cert_in_cb (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "cert-in-cb", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_cert_in_cb: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.CertInCb">"CertInCb"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_cert_in_cb (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "cert-in-cb", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_wpa_rsc_relaxation: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpaRscRelaxation">"WpaRscRelaxation"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wpa_rsc_relaxation() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_wpa_rsc_relaxation (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_wpa_rsc_relaxation (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wpa_rsc_relaxation: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpaRscRelaxation">"WpaRscRelaxation"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_wpa_rsc_relaxation (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "wpa-rsc-relaxation", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_wpa_rsc_relaxation: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.WpaRscRelaxation">"WpaRscRelaxation"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_wpa_rsc_relaxation (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "wpa-rsc-relaxation", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_sched_scan_plans: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SchedScanPlans">"SchedScanPlans"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sched_scan_plans() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_sched_scan_plans (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_sched_scan_plans (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sched_scan_plans: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SchedScanPlans">"SchedScanPlans"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_sched_scan_plans (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "sched-scan-plans", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_sched_scan_plans: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.SchedScanPlans">"SchedScanPlans"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_sched_scan_plans (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "sched-scan-plans", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_gas_address3: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GasAddress3">"GasAddress3"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_gas_address3() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_gas_address3 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_gas_address3 (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_gas_address3: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GasAddress3">"GasAddress3"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_gas_address3 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "gas-address3", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_gas_address3: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GasAddress3">"GasAddress3"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_gas_address3 (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "gas-address3", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_ftm_responder: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FtmResponder">"FtmResponder"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ftm_responder() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_ftm_responder (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_ftm_responder (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ftm_responder: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FtmResponder">"FtmResponder"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ftm_responder (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ftm-responder", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_ftm_responder: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FtmResponder">"FtmResponder"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_ftm_responder (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ftm-responder", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_ftm_initiator: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FtmInitiator">"FtmInitiator"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ftm_initiator() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_ftm_initiator (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_ftm_initiator (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ftm_initiator: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FtmInitiator">"FtmInitiator"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_ftm_initiator (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "ftm-initiator", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_ftm_initiator: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.FtmInitiator">"FtmInitiator"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_ftm_initiator (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ftm-initiator", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_gas_rand_addr_lifetime: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GasRandAddrLifetime">"GasRandAddrLifetime"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_gas_rand_addr_lifetime() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_gas_rand_addr_lifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_gas_rand_addr_lifetime (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_gas_rand_addr_lifetime: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GasRandAddrLifetime">"GasRandAddrLifetime"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_gas_rand_addr_lifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "gas-rand-addr-lifetime", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_gas_rand_addr_lifetime: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GasRandAddrLifetime">"GasRandAddrLifetime"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_gas_rand_addr_lifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "gas-rand-addr-lifetime", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_gas_rand_mac_addr: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GasRandMacAddr">"GasRandMacAddr"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_gas_rand_mac_addr() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_gas_rand_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_gas_rand_mac_addr (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_gas_rand_mac_addr: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GasRandMacAddr">"GasRandMacAddr"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_gas_rand_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "gas-rand-mac-addr", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_gas_rand_mac_addr: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.GasRandMacAddr">"GasRandMacAddr"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_gas_rand_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "gas-rand-mac-addr", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_get_dpp_config_processing: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DppConfigProcessing">"DppConfigProcessing"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dpp_config_processing() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_get_dpp_config_processing (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_GET_IFACE (object)->get_dpp_config_processing (object);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dpp_config_processing: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DppConfigProcessing">"DppConfigProcessing"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_dup_dpp_config_processing (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "dpp-config-processing", &value, NULL);
  return value;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_set_dpp_config_processing: (skip)
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface.DppConfigProcessing">"DppConfigProcessing"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_set_dpp_config_processing (wpainterfaceFiW1Wpa_supplicant1Interface *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "dpp-config-processing", value, NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_scan_done:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_success: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.ScanDone">"ScanDone"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_scan_done (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    gboolean arg_success)
{
  g_signal_emit_by_name (object, "scan-done", arg_success);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_bssadded:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_path: Argument to pass with the signal.
 * @arg_properties: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.BSSAdded">"BSSAdded"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_bssadded (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_path,
    GVariant *arg_properties)
{
  g_signal_emit_by_name (object, "bssadded", arg_path, arg_properties);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_bssremoved:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_path: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.BSSRemoved">"BSSRemoved"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_bssremoved (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_path)
{
  g_signal_emit_by_name (object, "bssremoved", arg_path);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_blob_added:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_name: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.BlobAdded">"BlobAdded"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_blob_added (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_name)
{
  g_signal_emit_by_name (object, "blob-added", arg_name);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_blob_removed:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_name: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.BlobRemoved">"BlobRemoved"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_blob_removed (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_name)
{
  g_signal_emit_by_name (object, "blob-removed", arg_name);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_network_added:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_path: Argument to pass with the signal.
 * @arg_properties: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.NetworkAdded">"NetworkAdded"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_network_added (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_path,
    GVariant *arg_properties)
{
  g_signal_emit_by_name (object, "network-added", arg_path, arg_properties);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_network_removed:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_path: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.NetworkRemoved">"NetworkRemoved"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_network_removed (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_path)
{
  g_signal_emit_by_name (object, "network-removed", arg_path);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_network_selected:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_path: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.NetworkSelected">"NetworkSelected"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_network_selected (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_path)
{
  g_signal_emit_by_name (object, "network-selected", arg_path);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_properties_changed:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_properties: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.PropertiesChanged">"PropertiesChanged"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_properties_changed (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GVariant *arg_properties)
{
  g_signal_emit_by_name (object, "properties-changed", arg_properties);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_probe_request:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_args: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.ProbeRequest">"ProbeRequest"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_probe_request (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GVariant *arg_args)
{
  g_signal_emit_by_name (object, "probe-request", arg_args);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_certification:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_certification: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.Certification">"Certification"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_certification (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GVariant *arg_certification)
{
  g_signal_emit_by_name (object, "certification", arg_certification);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_eap:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_status: Argument to pass with the signal.
 * @arg_parameter: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.EAP">"EAP"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_eap (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_status,
    const gchar *arg_parameter)
{
  g_signal_emit_by_name (object, "eap", arg_status, arg_parameter);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_sta_authorized:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_name: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.StaAuthorized">"StaAuthorized"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_sta_authorized (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_name)
{
  g_signal_emit_by_name (object, "sta-authorized", arg_name);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_sta_deauthorized:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_name: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.StaDeauthorized">"StaDeauthorized"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_sta_deauthorized (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_name)
{
  g_signal_emit_by_name (object, "sta-deauthorized", arg_name);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_emit_network_request:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @arg_path: Argument to pass with the signal.
 * @arg_field: Argument to pass with the signal.
 * @arg_text: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface.NetworkRequest">"NetworkRequest"</link> D-Bus signal.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_emit_network_request (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_path,
    const gchar *arg_field,
    const gchar *arg_text)
{
  g_signal_emit_by_name (object, "network-request", arg_path, arg_field, arg_text);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_scan:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Scan">Scan()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_scan_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_scan_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_scan (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Scan",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_scan_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_scan().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_scan().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_scan_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_scan_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Scan">Scan()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_scan() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_scan_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Scan",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_signal_poll:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SignalPoll">SignalPoll()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_signal_poll_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_signal_poll_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_signal_poll (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "SignalPoll",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_signal_poll_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @out_args: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_signal_poll().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_signal_poll().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_signal_poll_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GVariant **out_args,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@a{sv})",
                 out_args);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_signal_poll_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @out_args: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SignalPoll">SignalPoll()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_signal_poll() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_signal_poll_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GVariant **out_args,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "SignalPoll",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@a{sv})",
                 out_args);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_disconnect:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Disconnect">Disconnect()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_disconnect_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_disconnect_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_disconnect (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Disconnect",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_disconnect_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_disconnect().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_disconnect().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_disconnect_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_disconnect_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Disconnect">Disconnect()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_disconnect() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_disconnect_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Disconnect",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_network:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.AddNetwork">AddNetwork()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_network_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_network_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_network (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "AddNetwork",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_network_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @out_path: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_network().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_network().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_network_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    gchar **out_path,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_path);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_network_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @out_path: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.AddNetwork">AddNetwork()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_network() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_network_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GVariant *arg_args,
    gchar **out_path,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "AddNetwork",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_path);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_reassociate:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Reassociate">Reassociate()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_reassociate_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_reassociate_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_reassociate (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Reassociate",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_reassociate_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_reassociate().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_reassociate().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_reassociate_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_reassociate_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Reassociate">Reassociate()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_reassociate() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_reassociate_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Reassociate",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_reattach:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Reattach">Reattach()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_reattach_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_reattach_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_reattach (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Reattach",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_reattach_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_reattach().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_reattach().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_reattach_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_reattach_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Reattach">Reattach()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_reattach() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_reattach_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Reattach",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_reconnect:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Reconnect">Reconnect()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_reconnect_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_reconnect_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_reconnect (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Reconnect",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_reconnect_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_reconnect().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_reconnect().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_reconnect_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_reconnect_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Reconnect">Reconnect()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_reconnect() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_reconnect_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Reconnect",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_network:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_path: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.RemoveNetwork">RemoveNetwork()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_network_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_network_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_network (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_path,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RemoveNetwork",
    g_variant_new ("(o)",
                   arg_path),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_network_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_network().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_network().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_network_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_network_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_path: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.RemoveNetwork">RemoveNetwork()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_network() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_network_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_path,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RemoveNetwork",
    g_variant_new ("(o)",
                   arg_path),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_all_networks:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.RemoveAllNetworks">RemoveAllNetworks()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_all_networks_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_all_networks_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_all_networks (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RemoveAllNetworks",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_all_networks_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_all_networks().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_all_networks().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_all_networks_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_all_networks_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.RemoveAllNetworks">RemoveAllNetworks()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_all_networks() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_all_networks_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RemoveAllNetworks",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_select_network:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_path: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SelectNetwork">SelectNetwork()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_select_network_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_select_network_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_select_network (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_path,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "SelectNetwork",
    g_variant_new ("(o)",
                   arg_path),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_select_network_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_select_network().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_select_network().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_select_network_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_select_network_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_path: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SelectNetwork">SelectNetwork()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_select_network() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_select_network_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_path,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "SelectNetwork",
    g_variant_new ("(o)",
                   arg_path),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_network_reply:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_path: Argument to pass with the method invocation.
 * @arg_field: Argument to pass with the method invocation.
 * @arg_value: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.NetworkReply">NetworkReply()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_network_reply_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_network_reply_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_network_reply (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_path,
    const gchar *arg_field,
    const gchar *arg_value,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "NetworkReply",
    g_variant_new ("(oss)",
                   arg_path,
                   arg_field,
                   arg_value),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_network_reply_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_network_reply().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_network_reply().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_network_reply_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_network_reply_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_path: Argument to pass with the method invocation.
 * @arg_field: Argument to pass with the method invocation.
 * @arg_value: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.NetworkReply">NetworkReply()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_network_reply() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_network_reply_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_path,
    const gchar *arg_field,
    const gchar *arg_value,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "NetworkReply",
    g_variant_new ("(oss)",
                   arg_path,
                   arg_field,
                   arg_value),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_blob:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_name: Argument to pass with the method invocation.
 * @arg_data: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.AddBlob">AddBlob()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_blob_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_blob_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_blob (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_name,
    const gchar *arg_data,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "AddBlob",
    g_variant_new ("(s^ay)",
                   arg_name,
                   arg_data),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_blob_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_blob().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_blob().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_blob_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_blob_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_name: Argument to pass with the method invocation.
 * @arg_data: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.AddBlob">AddBlob()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_blob() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_add_blob_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_name,
    const gchar *arg_data,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "AddBlob",
    g_variant_new ("(s^ay)",
                   arg_name,
                   arg_data),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_get_blob:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_name: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.GetBlob">GetBlob()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_get_blob_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_get_blob_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_get_blob (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_name,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetBlob",
    g_variant_new ("(s)",
                   arg_name),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_get_blob_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @out_data: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_get_blob().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_get_blob().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_get_blob_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    gchar **out_data,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^ay)",
                 out_data);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_get_blob_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_name: Argument to pass with the method invocation.
 * @out_data: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.GetBlob">GetBlob()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_get_blob() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_get_blob_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_name,
    gchar **out_data,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetBlob",
    g_variant_new ("(s)",
                   arg_name),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^ay)",
                 out_data);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_blob:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_name: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.RemoveBlob">RemoveBlob()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_blob_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_blob_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_blob (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_name,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RemoveBlob",
    g_variant_new ("(s)",
                   arg_name),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_blob_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_blob().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_blob().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_blob_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_blob_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_name: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.RemoveBlob">RemoveBlob()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_blob() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_remove_blob_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_name,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RemoveBlob",
    g_variant_new ("(s)",
                   arg_name),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_set_pkcs11_engine_and_module_path:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_pkcs11_engine_path: Argument to pass with the method invocation.
 * @arg_pkcs11_module_path: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SetPKCS11EngineAndModulePath">SetPKCS11EngineAndModulePath()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_set_pkcs11_engine_and_module_path_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_set_pkcs11_engine_and_module_path_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_set_pkcs11_engine_and_module_path (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_pkcs11_engine_path,
    const gchar *arg_pkcs11_module_path,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "SetPKCS11EngineAndModulePath",
    g_variant_new ("(ss)",
                   arg_pkcs11_engine_path,
                   arg_pkcs11_module_path),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_set_pkcs11_engine_and_module_path_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_set_pkcs11_engine_and_module_path().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_set_pkcs11_engine_and_module_path().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_set_pkcs11_engine_and_module_path_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_set_pkcs11_engine_and_module_path_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_pkcs11_engine_path: Argument to pass with the method invocation.
 * @arg_pkcs11_module_path: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SetPKCS11EngineAndModulePath">SetPKCS11EngineAndModulePath()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_set_pkcs11_engine_and_module_path() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_set_pkcs11_engine_and_module_path_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    const gchar *arg_pkcs11_engine_path,
    const gchar *arg_pkcs11_module_path,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "SetPKCS11EngineAndModulePath",
    g_variant_new ("(ss)",
                   arg_pkcs11_engine_path,
                   arg_pkcs11_module_path),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_flush_bss:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_age: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.FlushBSS">FlushBSS()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_flush_bss_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_flush_bss_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_flush_bss (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    guint arg_age,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "FlushBSS",
    g_variant_new ("(u)",
                   arg_age),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_flush_bss_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_flush_bss().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_flush_bss().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_flush_bss_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_flush_bss_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_age: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.FlushBSS">FlushBSS()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_flush_bss() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_flush_bss_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    guint arg_age,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "FlushBSS",
    g_variant_new ("(u)",
                   arg_age),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_subscribe_probe_req:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SubscribeProbeReq">SubscribeProbeReq()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_subscribe_probe_req_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_subscribe_probe_req_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_subscribe_probe_req (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "SubscribeProbeReq",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_subscribe_probe_req_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_subscribe_probe_req().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_subscribe_probe_req().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_subscribe_probe_req_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_subscribe_probe_req_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SubscribeProbeReq">SubscribeProbeReq()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_subscribe_probe_req() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_subscribe_probe_req_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "SubscribeProbeReq",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_unsubscribe_probe_req:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.UnsubscribeProbeReq">UnsubscribeProbeReq()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_unsubscribe_probe_req_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_unsubscribe_probe_req_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_unsubscribe_probe_req (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "UnsubscribeProbeReq",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_unsubscribe_probe_req_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_unsubscribe_probe_req().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_unsubscribe_probe_req().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_unsubscribe_probe_req_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_unsubscribe_probe_req_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.UnsubscribeProbeReq">UnsubscribeProbeReq()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_unsubscribe_probe_req() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_unsubscribe_probe_req_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "UnsubscribeProbeReq",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogoff:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.EAPLogoff">EAPLogoff()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogoff_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogoff_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogoff (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "EAPLogoff",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogoff_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogoff().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogoff().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogoff_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogoff_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.EAPLogoff">EAPLogoff()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogoff() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogoff_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "EAPLogoff",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogon:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.EAPLogon">EAPLogon()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogon_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogon_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogon (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "EAPLogon",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogon_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogon().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogon().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogon_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogon_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.EAPLogon">EAPLogon()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogon() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_eaplogon_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "EAPLogon",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_add:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_frame_id: Argument to pass with the method invocation.
 * @arg_ielems: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.VendorElemAdd">VendorElemAdd()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_add_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_add_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_add (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    gint arg_frame_id,
    const gchar *arg_ielems,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "VendorElemAdd",
    g_variant_new ("(i^ay)",
                   arg_frame_id,
                   arg_ielems),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_add_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_add().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_add().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_add_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_add_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_frame_id: Argument to pass with the method invocation.
 * @arg_ielems: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.VendorElemAdd">VendorElemAdd()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_add() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_add_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    gint arg_frame_id,
    const gchar *arg_ielems,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "VendorElemAdd",
    g_variant_new ("(i^ay)",
                   arg_frame_id,
                   arg_ielems),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_get:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_frame_id: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.VendorElemGet">VendorElemGet()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_get_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_get_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_get (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    gint arg_frame_id,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "VendorElemGet",
    g_variant_new ("(i)",
                   arg_frame_id),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_get_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @out_ielems: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_get().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_get().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_get_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    gchar **out_ielems,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^ay)",
                 out_ielems);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_get_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_frame_id: Argument to pass with the method invocation.
 * @out_ielems: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.VendorElemGet">VendorElemGet()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_get() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_get_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    gint arg_frame_id,
    gchar **out_ielems,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "VendorElemGet",
    g_variant_new ("(i)",
                   arg_frame_id),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^ay)",
                 out_ielems);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_rem:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_frame_id: Argument to pass with the method invocation.
 * @arg_ielems: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.VendorElemRem">VendorElemRem()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_rem_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_rem_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_rem (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    gint arg_frame_id,
    const gchar *arg_ielems,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "VendorElemRem",
    g_variant_new ("(i^ay)",
                   arg_frame_id,
                   arg_ielems),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_rem_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_rem().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_rem().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_rem_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_rem_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @arg_frame_id: Argument to pass with the method invocation.
 * @arg_ielems: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.VendorElemRem">VendorElemRem()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_rem() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_vendor_elem_rem_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    gint arg_frame_id,
    const gchar *arg_ielems,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "VendorElemRem",
    g_variant_new ("(i^ay)",
                   arg_frame_id,
                   arg_ielems),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_save_config:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SaveConfig">SaveConfig()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_save_config_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_save_config_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_save_config (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "SaveConfig",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_save_config_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_save_config().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_save_config().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_save_config_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_save_config_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SaveConfig">SaveConfig()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_save_config() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_save_config_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "SaveConfig",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_abort_scan:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.AbortScan">AbortScan()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_call_abort_scan_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_abort_scan_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_call_abort_scan (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "AbortScan",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_abort_scan_finish:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_call_abort_scan().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_call_abort_scan().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_abort_scan_finish (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_call_abort_scan_sync:
 * @proxy: A #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.AbortScan">AbortScan()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_call_abort_scan() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_fi_w1_wpa_supplicant1_interface_call_abort_scan_sync (
    wpainterfaceFiW1Wpa_supplicant1Interface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "AbortScan",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_scan:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Scan">Scan()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_scan (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_signal_poll:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @args: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SignalPoll">SignalPoll()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_signal_poll (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation,
    GVariant *args)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(@a{sv})",
                   args));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_disconnect:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Disconnect">Disconnect()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_disconnect (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_add_network:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @path: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.AddNetwork">AddNetwork()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_add_network (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation,
    const gchar *path)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(o)",
                   path));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_reassociate:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Reassociate">Reassociate()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_reassociate (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_reattach:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Reattach">Reattach()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_reattach (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_reconnect:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.Reconnect">Reconnect()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_reconnect (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_remove_network:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.RemoveNetwork">RemoveNetwork()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_remove_network (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_remove_all_networks:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.RemoveAllNetworks">RemoveAllNetworks()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_remove_all_networks (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_select_network:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SelectNetwork">SelectNetwork()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_select_network (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_network_reply:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.NetworkReply">NetworkReply()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_network_reply (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_add_blob:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.AddBlob">AddBlob()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_add_blob (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_get_blob:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @data: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.GetBlob">GetBlob()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_get_blob (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation,
    const gchar *data)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(^ay)",
                   data));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_remove_blob:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.RemoveBlob">RemoveBlob()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_remove_blob (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_set_pkcs11_engine_and_module_path:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SetPKCS11EngineAndModulePath">SetPKCS11EngineAndModulePath()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_set_pkcs11_engine_and_module_path (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_flush_bss:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.FlushBSS">FlushBSS()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_flush_bss (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_subscribe_probe_req:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SubscribeProbeReq">SubscribeProbeReq()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_subscribe_probe_req (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_unsubscribe_probe_req:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.UnsubscribeProbeReq">UnsubscribeProbeReq()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_unsubscribe_probe_req (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_eaplogoff:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.EAPLogoff">EAPLogoff()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_eaplogoff (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_eaplogon:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.EAPLogon">EAPLogon()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_eaplogon (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_vendor_elem_add:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.VendorElemAdd">VendorElemAdd()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_vendor_elem_add (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_vendor_elem_get:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @ielems: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.VendorElemGet">VendorElemGet()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_vendor_elem_get (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation,
    const gchar *ielems)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(^ay)",
                   ielems));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_vendor_elem_rem:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.VendorElemRem">VendorElemRem()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_vendor_elem_rem (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_save_config:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.SaveConfig">SaveConfig()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_save_config (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_complete_abort_scan:
 * @object: A #wpainterfaceFiW1Wpa_supplicant1Interface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface.AbortScan">AbortScan()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_complete_abort_scan (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * wpainterfaceFiW1Wpa_supplicant1InterfaceProxy:
 *
 * The #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * wpainterfaceFiW1Wpa_supplicant1InterfaceProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #wpainterfaceFiW1Wpa_supplicant1InterfaceProxy.
 */

struct _wpainterfaceFiW1Wpa_supplicant1InterfaceProxyPrivate
{
  GData *qdata;
};

static void wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_iface_init (wpainterfaceFiW1Wpa_supplicant1InterfaceIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (wpainterfaceFiW1Wpa_supplicant1InterfaceProxy, wpa_interface_fi_w1_wpa_supplicant1_interface_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (wpainterfaceFiW1Wpa_supplicant1InterfaceProxy)
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE, wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (wpainterfaceFiW1Wpa_supplicant1InterfaceProxy, wpa_interface_fi_w1_wpa_supplicant1_interface_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE, wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_iface_init));

#endif
static void
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_finalize (GObject *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_parent_class)->finalize (object);
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 130);
  info = _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface fi.w1.wpa_supplicant1.Interface: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 130);
  info = _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "fi.w1.wpa_supplicant1.Interface", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static GVariant *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_capabilities (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Capabilities");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_state (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "State");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_scanning (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Scanning");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static guint 
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ap_scan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  guint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ApScan");
  if (variant != NULL)
    {
      value = g_variant_get_uint32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static guint 
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_bssexpire_age (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  guint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "BSSExpireAge");
  if (variant != NULL)
    {
      value = g_variant_get_uint32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static guint 
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_bssexpire_count (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  guint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "BSSExpireCount");
  if (variant != NULL)
    {
      value = g_variant_get_uint32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_country (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Country");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ifname (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Ifname");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_driver (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Driver");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_bridge_ifname (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "BridgeIfname");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_config_file (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ConfigFile");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_current_bss (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "CurrentBSS");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_current_network (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "CurrentNetwork");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_current_auth_mode (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "CurrentAuthMode");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static GVariant *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_blobs (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Blobs");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static const gchar *const *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_bsss (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "BSSs");
  if (variant != NULL)
    {
      value = g_variant_get_objv (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *const *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_networks (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Networks");
  if (variant != NULL)
    {
      value = g_variant_get_objv (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gboolean 
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_fast_reauth (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "FastReauth");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_scan_interval (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ScanInterval");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_pkcs11_engine_path (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PKCS11EnginePath");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_pkcs11_module_path (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PKCS11ModulePath");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_disconnect_reason (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DisconnectReason");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static gint 
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_assoc_status_code (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  gint value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "AssocStatusCode");
  if (variant != NULL)
    {
      value = g_variant_get_int32 (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ctrl_interface (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "CtrlInterface");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ctrl_interface_group (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "CtrlInterfaceGroup");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_eapol_version (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "EapolVersion");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_bgscan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Bgscan");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_disable_scan_offload (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DisableScanOffload");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_opensc_engine_path (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "OpenscEnginePath");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_openssl_ciphers (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "OpensslCiphers");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_pcsc_reader (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PcscReader");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_pcsc_pin (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PcscPin");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_external_sim (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ExternalSim");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_driver_param (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DriverParam");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_dot11_rsnaconfig_pmklifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Dot11RSNAConfigPMKLifetime");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_dot11_rsnaconfig_pmkreauth_threshold (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Dot11RSNAConfigPMKReauthThreshold");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_dot11_rsnaconfig_satimeout (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Dot11RSNAConfigSATimeout");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_update_config (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "UpdateConfig");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_uuid (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Uuid");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_auto_uuid (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "AutoUuid");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_device_name (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DeviceName");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_manufacturer (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Manufacturer");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_model_name (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ModelName");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_model_number (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ModelNumber");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_serial_number (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SerialNumber");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_device_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DeviceType");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_os_version (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "OsVersion");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_config_methods (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ConfigMethods");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_cred_processing (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "WpsCredProcessing");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_vendor_ext_m1 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "WpsVendorExtM1");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_sec_device_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SecDeviceType");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_listen_reg_class (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pListenRegClass");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_listen_channel (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pListenChannel");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_oper_reg_class (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pOperRegClass");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_oper_channel (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pOperChannel");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_go_intent (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pGoIntent");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_ssid_postfix (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pSsidPostfix");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_persistent_reconnect (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PersistentReconnect");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_intra_bss (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pIntraBss");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_group_idle (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pGroupIdle");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_go_freq_change_policy (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pGoFreqChangePolicy");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_passphrase_len (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pPassphraseLen");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_pref_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pPrefChan");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_no_go_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pNoGoFreq");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_add_cli_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pAddCliChan");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_optimize_listen_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pOptimizeListenChan");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_go_ht40 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pGoHt40");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_go_vht (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pGoVht");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_disabled (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pDisabled");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_go_ctwindow (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pGoCtwindow");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_no_group_iface (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pNoGroupIface");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_ignore_shared_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pIgnoreSharedFreq");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ip_addr_go (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "IpAddrGo");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ip_addr_mask (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "IpAddrMask");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ip_addr_start (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "IpAddrStart");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ip_addr_end (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "IpAddrEnd");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_cli_probe (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pCliProbe");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_bss_max_count (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "BssMaxCount");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_filter_ssids (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "FilterSsids");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_filter_rssi (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "FilterRssi");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_max_num_sta (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "MaxNumSta");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_disassoc_low_ack (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DisassocLowAck");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Interworking");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_hessid (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Hessid");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_access_network_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "AccessNetworkType");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_go_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "GoInterworking");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_go_access_network_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "GoAccessNetworkType");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_go_internet (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "GoInternet");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_go_venue_group (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "GoVenueGroup");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_go_venue_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "GoVenueType");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_pbc_in_m1 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PbcInM1");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_autoscan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Autoscan");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_nfc_dev_pw_id (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "WpsNfcDevPwId");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_nfc_dh_pubkey (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "WpsNfcDhPubkey");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_nfc_dh_privkey (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "WpsNfcDhPrivkey");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_nfc_dev_pw (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "WpsNfcDevPw");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ext_password_backend (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ExtPasswordBackend");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_go_max_inactivity (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pGoMaxInactivity");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_auto_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "AutoInterworking");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_okc (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Okc");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_pmf (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Pmf");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_sae_groups (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SaeGroups");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_dtim_period (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DtimPeriod");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_beacon_int (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "BeaconInt");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ap_vendor_elements (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ApVendorElements");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ignore_old_scan_res (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "IgnoreOldScanRes");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_freq_list (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "FreqList");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_scan_cur_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ScanCurFreq");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_sched_scan_interval (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SchedScanInterval");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_sched_scan_start_delay (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SchedScanStartDelay");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_tdls_external_control (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "TdlsExternalControl");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_osu_dir (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "OsuDir");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wowlan_triggers (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "WowlanTriggers");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_search_delay (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2pSearchDelay");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "MacAddr");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_rand_addr_lifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "RandAddrLifetime");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_preassoc_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PreassocMacAddr");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_key_mgmt_offload (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "KeyMgmtOffload");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_passive_scan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PassiveScan");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_reassoc_same_bss_optim (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ReassocSameBssOptim");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_priority (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "WpsPriority");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_cert_in_cb (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "CertInCb");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wpa_rsc_relaxation (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "WpaRscRelaxation");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_sched_scan_plans (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SchedScanPlans");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_gas_address3 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "GasAddress3");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ftm_responder (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "FtmResponder");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ftm_initiator (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "FtmInitiator");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_gas_rand_addr_lifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "GasRandAddrLifetime");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_gas_rand_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "GasRandMacAddr");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_dpp_config_processing (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DppConfigProcessing");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_init (wpainterfaceFiW1Wpa_supplicant1InterfaceProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY, wpainterfaceFiW1Wpa_supplicant1InterfaceProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info ());
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_class_init (wpainterfaceFiW1Wpa_supplicant1InterfaceProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_finalize;
  gobject_class->get_property = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_property;
  gobject_class->set_property = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_g_signal;
  proxy_class->g_properties_changed = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_g_properties_changed;

  wpa_interface_fi_w1_wpa_supplicant1_interface_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (wpainterfaceFiW1Wpa_supplicant1InterfaceProxyPrivate));
#endif
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_iface_init (wpainterfaceFiW1Wpa_supplicant1InterfaceIface *iface)
{
  iface->get_capabilities = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_capabilities;
  iface->get_state = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_state;
  iface->get_scanning = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_scanning;
  iface->get_ap_scan = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ap_scan;
  iface->get_bssexpire_age = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_bssexpire_age;
  iface->get_bssexpire_count = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_bssexpire_count;
  iface->get_country = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_country;
  iface->get_ifname = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ifname;
  iface->get_driver = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_driver;
  iface->get_bridge_ifname = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_bridge_ifname;
  iface->get_config_file = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_config_file;
  iface->get_current_bss = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_current_bss;
  iface->get_current_network = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_current_network;
  iface->get_current_auth_mode = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_current_auth_mode;
  iface->get_blobs = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_blobs;
  iface->get_bsss = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_bsss;
  iface->get_networks = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_networks;
  iface->get_fast_reauth = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_fast_reauth;
  iface->get_scan_interval = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_scan_interval;
  iface->get_pkcs11_engine_path = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_pkcs11_engine_path;
  iface->get_pkcs11_module_path = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_pkcs11_module_path;
  iface->get_disconnect_reason = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_disconnect_reason;
  iface->get_assoc_status_code = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_assoc_status_code;
  iface->get_ctrl_interface = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ctrl_interface;
  iface->get_ctrl_interface_group = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ctrl_interface_group;
  iface->get_eapol_version = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_eapol_version;
  iface->get_bgscan = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_bgscan;
  iface->get_disable_scan_offload = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_disable_scan_offload;
  iface->get_opensc_engine_path = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_opensc_engine_path;
  iface->get_openssl_ciphers = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_openssl_ciphers;
  iface->get_pcsc_reader = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_pcsc_reader;
  iface->get_pcsc_pin = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_pcsc_pin;
  iface->get_external_sim = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_external_sim;
  iface->get_driver_param = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_driver_param;
  iface->get_dot11_rsnaconfig_pmklifetime = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_dot11_rsnaconfig_pmklifetime;
  iface->get_dot11_rsnaconfig_pmkreauth_threshold = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_dot11_rsnaconfig_pmkreauth_threshold;
  iface->get_dot11_rsnaconfig_satimeout = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_dot11_rsnaconfig_satimeout;
  iface->get_update_config = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_update_config;
  iface->get_uuid = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_uuid;
  iface->get_auto_uuid = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_auto_uuid;
  iface->get_device_name = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_device_name;
  iface->get_manufacturer = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_manufacturer;
  iface->get_model_name = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_model_name;
  iface->get_model_number = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_model_number;
  iface->get_serial_number = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_serial_number;
  iface->get_device_type = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_device_type;
  iface->get_os_version = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_os_version;
  iface->get_config_methods = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_config_methods;
  iface->get_wps_cred_processing = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_cred_processing;
  iface->get_wps_vendor_ext_m1 = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_vendor_ext_m1;
  iface->get_sec_device_type = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_sec_device_type;
  iface->get_p2p_listen_reg_class = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_listen_reg_class;
  iface->get_p2p_listen_channel = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_listen_channel;
  iface->get_p2p_oper_reg_class = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_oper_reg_class;
  iface->get_p2p_oper_channel = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_oper_channel;
  iface->get_p2p_go_intent = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_go_intent;
  iface->get_p2p_ssid_postfix = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_ssid_postfix;
  iface->get_persistent_reconnect = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_persistent_reconnect;
  iface->get_p2p_intra_bss = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_intra_bss;
  iface->get_p2p_group_idle = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_group_idle;
  iface->get_p2p_go_freq_change_policy = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_go_freq_change_policy;
  iface->get_p2p_passphrase_len = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_passphrase_len;
  iface->get_p2p_pref_chan = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_pref_chan;
  iface->get_p2p_no_go_freq = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_no_go_freq;
  iface->get_p2p_add_cli_chan = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_add_cli_chan;
  iface->get_p2p_optimize_listen_chan = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_optimize_listen_chan;
  iface->get_p2p_go_ht40 = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_go_ht40;
  iface->get_p2p_go_vht = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_go_vht;
  iface->get_p2p_disabled = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_disabled;
  iface->get_p2p_go_ctwindow = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_go_ctwindow;
  iface->get_p2p_no_group_iface = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_no_group_iface;
  iface->get_p2p_ignore_shared_freq = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_ignore_shared_freq;
  iface->get_ip_addr_go = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ip_addr_go;
  iface->get_ip_addr_mask = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ip_addr_mask;
  iface->get_ip_addr_start = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ip_addr_start;
  iface->get_ip_addr_end = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ip_addr_end;
  iface->get_p2p_cli_probe = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_cli_probe;
  iface->get_bss_max_count = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_bss_max_count;
  iface->get_filter_ssids = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_filter_ssids;
  iface->get_filter_rssi = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_filter_rssi;
  iface->get_max_num_sta = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_max_num_sta;
  iface->get_disassoc_low_ack = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_disassoc_low_ack;
  iface->get_interworking = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_interworking;
  iface->get_hessid = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_hessid;
  iface->get_access_network_type = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_access_network_type;
  iface->get_go_interworking = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_go_interworking;
  iface->get_go_access_network_type = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_go_access_network_type;
  iface->get_go_internet = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_go_internet;
  iface->get_go_venue_group = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_go_venue_group;
  iface->get_go_venue_type = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_go_venue_type;
  iface->get_pbc_in_m1 = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_pbc_in_m1;
  iface->get_autoscan = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_autoscan;
  iface->get_wps_nfc_dev_pw_id = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_nfc_dev_pw_id;
  iface->get_wps_nfc_dh_pubkey = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_nfc_dh_pubkey;
  iface->get_wps_nfc_dh_privkey = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_nfc_dh_privkey;
  iface->get_wps_nfc_dev_pw = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_nfc_dev_pw;
  iface->get_ext_password_backend = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ext_password_backend;
  iface->get_p2p_go_max_inactivity = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_go_max_inactivity;
  iface->get_auto_interworking = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_auto_interworking;
  iface->get_okc = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_okc;
  iface->get_pmf = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_pmf;
  iface->get_sae_groups = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_sae_groups;
  iface->get_dtim_period = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_dtim_period;
  iface->get_beacon_int = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_beacon_int;
  iface->get_ap_vendor_elements = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ap_vendor_elements;
  iface->get_ignore_old_scan_res = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ignore_old_scan_res;
  iface->get_freq_list = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_freq_list;
  iface->get_scan_cur_freq = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_scan_cur_freq;
  iface->get_sched_scan_interval = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_sched_scan_interval;
  iface->get_sched_scan_start_delay = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_sched_scan_start_delay;
  iface->get_tdls_external_control = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_tdls_external_control;
  iface->get_osu_dir = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_osu_dir;
  iface->get_wowlan_triggers = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wowlan_triggers;
  iface->get_p2p_search_delay = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_p2p_search_delay;
  iface->get_mac_addr = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_mac_addr;
  iface->get_rand_addr_lifetime = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_rand_addr_lifetime;
  iface->get_preassoc_mac_addr = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_preassoc_mac_addr;
  iface->get_key_mgmt_offload = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_key_mgmt_offload;
  iface->get_passive_scan = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_passive_scan;
  iface->get_reassoc_same_bss_optim = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_reassoc_same_bss_optim;
  iface->get_wps_priority = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wps_priority;
  iface->get_cert_in_cb = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_cert_in_cb;
  iface->get_wpa_rsc_relaxation = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_wpa_rsc_relaxation;
  iface->get_sched_scan_plans = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_sched_scan_plans;
  iface->get_gas_address3 = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_gas_address3;
  iface->get_ftm_responder = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ftm_responder;
  iface->get_ftm_initiator = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_ftm_initiator;
  iface->get_gas_rand_addr_lifetime = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_gas_rand_addr_lifetime;
  iface->get_gas_rand_mac_addr = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_gas_rand_mac_addr;
  iface->get_dpp_config_processing = wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_get_dpp_config_processing;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface.top_of_page">fi.w1.wpa_supplicant1.Interface</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "fi.w1.wpa_supplicant1.Interface", NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new().
 *
 * Returns: (transfer full) (type wpainterfaceFiW1Wpa_supplicant1InterfaceProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceFiW1Wpa_supplicant1Interface *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE (ret);
  else
    return NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface.top_of_page">fi.w1.wpa_supplicant1.Interface</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type wpainterfaceFiW1Wpa_supplicant1InterfaceProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceFiW1Wpa_supplicant1Interface *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "fi.w1.wpa_supplicant1.Interface", NULL);
  if (ret != NULL)
    return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE (ret);
  else
    return NULL;
}


/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "fi.w1.wpa_supplicant1.Interface", NULL);
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type wpainterfaceFiW1Wpa_supplicant1InterfaceProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceFiW1Wpa_supplicant1Interface *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE (ret);
  else
    return NULL;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type wpainterfaceFiW1Wpa_supplicant1InterfaceProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceFiW1Wpa_supplicant1Interface *
wpa_interface_fi_w1_wpa_supplicant1_interface_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "fi.w1.wpa_supplicant1.Interface", NULL);
  if (ret != NULL)
    return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton:
 *
 * The #wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * wpainterfaceFiW1Wpa_supplicant1InterfaceSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton.
 */

struct _wpainterfaceFiW1Wpa_supplicant1InterfaceSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_vtable =
{
  _wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_handle_method_call,
  _wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_handle_get_property,
  _wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info ();
}

static GDBusInterfaceVTable *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_vtable;
}

static GVariant *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _wpa_interface_fi_w1_wpa_supplicant1_interface_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _wpa_interface_fi_w1_wpa_supplicant1_interface_emit_changed (gpointer user_data);

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _wpa_interface_fi_w1_wpa_supplicant1_interface_emit_changed (skeleton);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_scan_done (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    gboolean arg_success)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(b)",
                   arg_success));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "ScanDone",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_bssadded (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_path,
    GVariant *arg_properties)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o@a{sv})",
                   arg_path,
                   arg_properties));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "BSSAdded",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_bssremoved (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_path)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o)",
                   arg_path));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "BSSRemoved",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_blob_added (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_name)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(s)",
                   arg_name));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "BlobAdded",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_blob_removed (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_name)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(s)",
                   arg_name));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "BlobRemoved",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_network_added (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_path,
    GVariant *arg_properties)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o@a{sv})",
                   arg_path,
                   arg_properties));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "NetworkAdded",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_network_removed (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_path)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o)",
                   arg_path));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "NetworkRemoved",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_network_selected (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_path)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o)",
                   arg_path));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "NetworkSelected",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_properties_changed (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GVariant *arg_properties)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@a{sv})",
                   arg_properties));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "PropertiesChanged",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_probe_request (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GVariant *arg_args)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@a{sv})",
                   arg_args));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "ProbeRequest",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_certification (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    GVariant *arg_certification)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@a{sv})",
                   arg_certification));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "Certification",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_eap (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_status,
    const gchar *arg_parameter)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(ss)",
                   arg_status,
                   arg_parameter));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "EAP",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_sta_authorized (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_name)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(s)",
                   arg_name));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "StaAuthorized",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_sta_deauthorized (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_name)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(s)",
                   arg_name));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "StaDeauthorized",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_network_request (
    wpainterfaceFiW1Wpa_supplicant1Interface *object,
    const gchar *arg_path,
    const gchar *arg_field,
    const gchar *arg_text)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(oss)",
                   arg_path,
                   arg_field,
                   arg_text));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface", "NetworkRequest",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_iface_init (wpainterfaceFiW1Wpa_supplicant1InterfaceIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton, wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton)
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE, wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton, wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE, wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_iface_init));

#endif
static void
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_finalize (GObject *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  guint n;
  for (n = 0; n < 130; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_parent_class)->finalize (object);
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 130);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_wpa_interface_fi_w1_wpa_supplicant1_interface_emit_changed (gpointer user_data)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "fi.w1.wpa_supplicant1.Interface",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_wpa_interface_fi_w1_wpa_supplicant1_interface_schedule_emit_changed (wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _wpa_interface_fi_w1_wpa_supplicant1_interface_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _wpa_interface_fi_w1_wpa_supplicant1_interface_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 130);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _wpa_interface_fi_w1_wpa_supplicant1_interface_schedule_emit_changed (skeleton, _wpa_interface_fi_w1_wpa_supplicant1_interface_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_init (wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON, wpainterfaceFiW1Wpa_supplicant1InterfaceSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 130);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[3], G_TYPE_UINT);
  g_value_init (&skeleton->priv->properties[4], G_TYPE_UINT);
  g_value_init (&skeleton->priv->properties[5], G_TYPE_UINT);
  g_value_init (&skeleton->priv->properties[6], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[7], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[8], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[9], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[10], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[11], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[12], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[13], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[14], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[15], G_TYPE_STRV);
  g_value_init (&skeleton->priv->properties[16], G_TYPE_STRV);
  g_value_init (&skeleton->priv->properties[17], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[18], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[19], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[20], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[21], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[22], G_TYPE_INT);
  g_value_init (&skeleton->priv->properties[23], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[24], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[25], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[26], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[27], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[28], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[29], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[30], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[31], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[32], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[33], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[34], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[35], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[36], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[37], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[38], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[39], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[40], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[41], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[42], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[43], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[44], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[45], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[46], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[47], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[48], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[49], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[50], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[51], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[52], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[53], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[54], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[55], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[56], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[57], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[58], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[59], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[60], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[61], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[62], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[63], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[64], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[65], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[66], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[67], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[68], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[69], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[70], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[71], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[72], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[73], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[74], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[75], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[76], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[77], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[78], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[79], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[80], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[81], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[82], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[83], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[84], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[85], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[86], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[87], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[88], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[89], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[90], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[91], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[92], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[93], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[94], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[95], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[96], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[97], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[98], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[99], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[100], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[101], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[102], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[103], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[104], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[105], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[106], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[107], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[108], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[109], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[110], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[111], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[112], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[113], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[114], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[115], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[116], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[117], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[118], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[119], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[120], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[121], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[122], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[123], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[124], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[125], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[126], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[127], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[128], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[129], G_TYPE_STRING);
}

static GVariant *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_capabilities (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_state (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_scanning (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static guint 
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ap_scan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  guint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_uint (&(skeleton->priv->properties[3]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static guint 
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_bssexpire_age (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  guint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_uint (&(skeleton->priv->properties[4]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static guint 
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_bssexpire_count (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  guint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_uint (&(skeleton->priv->properties[5]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_country (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[6]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ifname (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[7]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_driver (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[8]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_bridge_ifname (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[9]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_config_file (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[10]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_current_bss (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[11]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_current_network (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[12]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_current_auth_mode (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[13]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static GVariant *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_blobs (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[14]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *const *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_bsss (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties[15]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *const *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_networks (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties[16]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gboolean 
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_fast_reauth (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[17]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_scan_interval (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[18]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_pkcs11_engine_path (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[19]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_pkcs11_module_path (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[20]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_disconnect_reason (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[21]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static gint 
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_assoc_status_code (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  gint value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_int (&(skeleton->priv->properties[22]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ctrl_interface (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[23]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ctrl_interface_group (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[24]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_eapol_version (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[25]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_bgscan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[26]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_disable_scan_offload (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[27]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_opensc_engine_path (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[28]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_openssl_ciphers (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[29]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_pcsc_reader (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[30]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_pcsc_pin (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[31]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_external_sim (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[32]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_driver_param (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[33]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_dot11_rsnaconfig_pmklifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[34]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_dot11_rsnaconfig_pmkreauth_threshold (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[35]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_dot11_rsnaconfig_satimeout (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[36]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_update_config (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[37]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_uuid (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[38]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_auto_uuid (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[39]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_device_name (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[40]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_manufacturer (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[41]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_model_name (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[42]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_model_number (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[43]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_serial_number (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[44]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_device_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[45]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_os_version (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[46]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_config_methods (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[47]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_cred_processing (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[48]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_vendor_ext_m1 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[49]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_sec_device_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[50]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_listen_reg_class (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[51]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_listen_channel (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[52]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_oper_reg_class (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[53]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_oper_channel (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[54]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_go_intent (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[55]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_ssid_postfix (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[56]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_persistent_reconnect (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[57]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_intra_bss (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[58]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_group_idle (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[59]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_go_freq_change_policy (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[60]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_passphrase_len (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[61]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_pref_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[62]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_no_go_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[63]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_add_cli_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[64]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_optimize_listen_chan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[65]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_go_ht40 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[66]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_go_vht (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[67]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_disabled (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[68]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_go_ctwindow (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[69]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_no_group_iface (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[70]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_ignore_shared_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[71]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ip_addr_go (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[72]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ip_addr_mask (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[73]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ip_addr_start (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[74]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ip_addr_end (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[75]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_cli_probe (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[76]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_bss_max_count (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[77]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_filter_ssids (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[78]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_filter_rssi (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[79]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_max_num_sta (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[80]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_disassoc_low_ack (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[81]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[82]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_hessid (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[83]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_access_network_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[84]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_go_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[85]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_go_access_network_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[86]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_go_internet (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[87]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_go_venue_group (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[88]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_go_venue_type (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[89]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_pbc_in_m1 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[90]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_autoscan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[91]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_nfc_dev_pw_id (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[92]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_nfc_dh_pubkey (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[93]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_nfc_dh_privkey (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[94]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_nfc_dev_pw (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[95]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ext_password_backend (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[96]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_go_max_inactivity (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[97]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_auto_interworking (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[98]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_okc (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[99]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_pmf (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[100]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_sae_groups (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[101]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_dtim_period (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[102]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_beacon_int (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[103]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ap_vendor_elements (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[104]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ignore_old_scan_res (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[105]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_freq_list (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[106]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_scan_cur_freq (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[107]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_sched_scan_interval (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[108]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_sched_scan_start_delay (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[109]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_tdls_external_control (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[110]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_osu_dir (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[111]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wowlan_triggers (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[112]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_search_delay (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[113]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[114]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_rand_addr_lifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[115]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_preassoc_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[116]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_key_mgmt_offload (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[117]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_passive_scan (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[118]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_reassoc_same_bss_optim (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[119]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_priority (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[120]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_cert_in_cb (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[121]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wpa_rsc_relaxation (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[122]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_sched_scan_plans (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[123]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_gas_address3 (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[124]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ftm_responder (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[125]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ftm_initiator (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[126]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_gas_rand_addr_lifetime (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[127]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_gas_rand_mac_addr (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[128]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_dpp_config_processing (wpainterfaceFiW1Wpa_supplicant1Interface *object)
{
  wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton *skeleton = WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[129]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_class_init (wpainterfaceFiW1Wpa_supplicant1InterfaceSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_finalize;
  gobject_class->get_property = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_property;
  gobject_class->set_property = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_set_property;
  gobject_class->notify       = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_notify;


  wpa_interface_fi_w1_wpa_supplicant1_interface_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (wpainterfaceFiW1Wpa_supplicant1InterfaceSkeletonPrivate));
#endif
}

static void
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_iface_init (wpainterfaceFiW1Wpa_supplicant1InterfaceIface *iface)
{
  iface->scan_done = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_scan_done;
  iface->bssadded = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_bssadded;
  iface->bssremoved = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_bssremoved;
  iface->blob_added = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_blob_added;
  iface->blob_removed = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_blob_removed;
  iface->network_added = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_network_added;
  iface->network_removed = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_network_removed;
  iface->network_selected = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_network_selected;
  iface->properties_changed = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_properties_changed;
  iface->probe_request = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_probe_request;
  iface->certification = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_certification;
  iface->eap = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_eap;
  iface->sta_authorized = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_sta_authorized;
  iface->sta_deauthorized = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_sta_deauthorized;
  iface->network_request = _wpa_interface_fi_w1_wpa_supplicant1_interface_on_signal_network_request;
  iface->get_capabilities = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_capabilities;
  iface->get_state = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_state;
  iface->get_scanning = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_scanning;
  iface->get_ap_scan = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ap_scan;
  iface->get_bssexpire_age = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_bssexpire_age;
  iface->get_bssexpire_count = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_bssexpire_count;
  iface->get_country = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_country;
  iface->get_ifname = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ifname;
  iface->get_driver = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_driver;
  iface->get_bridge_ifname = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_bridge_ifname;
  iface->get_config_file = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_config_file;
  iface->get_current_bss = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_current_bss;
  iface->get_current_network = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_current_network;
  iface->get_current_auth_mode = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_current_auth_mode;
  iface->get_blobs = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_blobs;
  iface->get_bsss = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_bsss;
  iface->get_networks = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_networks;
  iface->get_fast_reauth = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_fast_reauth;
  iface->get_scan_interval = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_scan_interval;
  iface->get_pkcs11_engine_path = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_pkcs11_engine_path;
  iface->get_pkcs11_module_path = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_pkcs11_module_path;
  iface->get_disconnect_reason = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_disconnect_reason;
  iface->get_assoc_status_code = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_assoc_status_code;
  iface->get_ctrl_interface = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ctrl_interface;
  iface->get_ctrl_interface_group = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ctrl_interface_group;
  iface->get_eapol_version = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_eapol_version;
  iface->get_bgscan = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_bgscan;
  iface->get_disable_scan_offload = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_disable_scan_offload;
  iface->get_opensc_engine_path = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_opensc_engine_path;
  iface->get_openssl_ciphers = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_openssl_ciphers;
  iface->get_pcsc_reader = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_pcsc_reader;
  iface->get_pcsc_pin = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_pcsc_pin;
  iface->get_external_sim = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_external_sim;
  iface->get_driver_param = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_driver_param;
  iface->get_dot11_rsnaconfig_pmklifetime = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_dot11_rsnaconfig_pmklifetime;
  iface->get_dot11_rsnaconfig_pmkreauth_threshold = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_dot11_rsnaconfig_pmkreauth_threshold;
  iface->get_dot11_rsnaconfig_satimeout = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_dot11_rsnaconfig_satimeout;
  iface->get_update_config = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_update_config;
  iface->get_uuid = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_uuid;
  iface->get_auto_uuid = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_auto_uuid;
  iface->get_device_name = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_device_name;
  iface->get_manufacturer = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_manufacturer;
  iface->get_model_name = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_model_name;
  iface->get_model_number = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_model_number;
  iface->get_serial_number = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_serial_number;
  iface->get_device_type = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_device_type;
  iface->get_os_version = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_os_version;
  iface->get_config_methods = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_config_methods;
  iface->get_wps_cred_processing = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_cred_processing;
  iface->get_wps_vendor_ext_m1 = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_vendor_ext_m1;
  iface->get_sec_device_type = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_sec_device_type;
  iface->get_p2p_listen_reg_class = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_listen_reg_class;
  iface->get_p2p_listen_channel = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_listen_channel;
  iface->get_p2p_oper_reg_class = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_oper_reg_class;
  iface->get_p2p_oper_channel = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_oper_channel;
  iface->get_p2p_go_intent = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_go_intent;
  iface->get_p2p_ssid_postfix = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_ssid_postfix;
  iface->get_persistent_reconnect = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_persistent_reconnect;
  iface->get_p2p_intra_bss = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_intra_bss;
  iface->get_p2p_group_idle = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_group_idle;
  iface->get_p2p_go_freq_change_policy = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_go_freq_change_policy;
  iface->get_p2p_passphrase_len = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_passphrase_len;
  iface->get_p2p_pref_chan = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_pref_chan;
  iface->get_p2p_no_go_freq = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_no_go_freq;
  iface->get_p2p_add_cli_chan = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_add_cli_chan;
  iface->get_p2p_optimize_listen_chan = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_optimize_listen_chan;
  iface->get_p2p_go_ht40 = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_go_ht40;
  iface->get_p2p_go_vht = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_go_vht;
  iface->get_p2p_disabled = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_disabled;
  iface->get_p2p_go_ctwindow = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_go_ctwindow;
  iface->get_p2p_no_group_iface = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_no_group_iface;
  iface->get_p2p_ignore_shared_freq = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_ignore_shared_freq;
  iface->get_ip_addr_go = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ip_addr_go;
  iface->get_ip_addr_mask = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ip_addr_mask;
  iface->get_ip_addr_start = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ip_addr_start;
  iface->get_ip_addr_end = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ip_addr_end;
  iface->get_p2p_cli_probe = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_cli_probe;
  iface->get_bss_max_count = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_bss_max_count;
  iface->get_filter_ssids = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_filter_ssids;
  iface->get_filter_rssi = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_filter_rssi;
  iface->get_max_num_sta = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_max_num_sta;
  iface->get_disassoc_low_ack = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_disassoc_low_ack;
  iface->get_interworking = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_interworking;
  iface->get_hessid = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_hessid;
  iface->get_access_network_type = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_access_network_type;
  iface->get_go_interworking = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_go_interworking;
  iface->get_go_access_network_type = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_go_access_network_type;
  iface->get_go_internet = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_go_internet;
  iface->get_go_venue_group = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_go_venue_group;
  iface->get_go_venue_type = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_go_venue_type;
  iface->get_pbc_in_m1 = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_pbc_in_m1;
  iface->get_autoscan = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_autoscan;
  iface->get_wps_nfc_dev_pw_id = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_nfc_dev_pw_id;
  iface->get_wps_nfc_dh_pubkey = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_nfc_dh_pubkey;
  iface->get_wps_nfc_dh_privkey = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_nfc_dh_privkey;
  iface->get_wps_nfc_dev_pw = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_nfc_dev_pw;
  iface->get_ext_password_backend = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ext_password_backend;
  iface->get_p2p_go_max_inactivity = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_go_max_inactivity;
  iface->get_auto_interworking = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_auto_interworking;
  iface->get_okc = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_okc;
  iface->get_pmf = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_pmf;
  iface->get_sae_groups = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_sae_groups;
  iface->get_dtim_period = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_dtim_period;
  iface->get_beacon_int = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_beacon_int;
  iface->get_ap_vendor_elements = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ap_vendor_elements;
  iface->get_ignore_old_scan_res = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ignore_old_scan_res;
  iface->get_freq_list = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_freq_list;
  iface->get_scan_cur_freq = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_scan_cur_freq;
  iface->get_sched_scan_interval = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_sched_scan_interval;
  iface->get_sched_scan_start_delay = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_sched_scan_start_delay;
  iface->get_tdls_external_control = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_tdls_external_control;
  iface->get_osu_dir = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_osu_dir;
  iface->get_wowlan_triggers = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wowlan_triggers;
  iface->get_p2p_search_delay = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_p2p_search_delay;
  iface->get_mac_addr = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_mac_addr;
  iface->get_rand_addr_lifetime = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_rand_addr_lifetime;
  iface->get_preassoc_mac_addr = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_preassoc_mac_addr;
  iface->get_key_mgmt_offload = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_key_mgmt_offload;
  iface->get_passive_scan = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_passive_scan;
  iface->get_reassoc_same_bss_optim = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_reassoc_same_bss_optim;
  iface->get_wps_priority = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wps_priority;
  iface->get_cert_in_cb = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_cert_in_cb;
  iface->get_wpa_rsc_relaxation = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_wpa_rsc_relaxation;
  iface->get_sched_scan_plans = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_sched_scan_plans;
  iface->get_gas_address3 = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_gas_address3;
  iface->get_ftm_responder = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ftm_responder;
  iface->get_ftm_initiator = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_ftm_initiator;
  iface->get_gas_rand_addr_lifetime = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_gas_rand_addr_lifetime;
  iface->get_gas_rand_mac_addr = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_gas_rand_mac_addr;
  iface->get_dpp_config_processing = wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_get_dpp_config_processing;
}

/**
 * wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface.top_of_page">fi.w1.wpa_supplicant1.Interface</link>.
 *
 * Returns: (transfer full) (type wpainterfaceFiW1Wpa_supplicant1InterfaceSkeleton): The skeleton object.
 */
wpainterfaceFiW1Wpa_supplicant1Interface *
wpa_interface_fi_w1_wpa_supplicant1_interface_skeleton_new (void)
{
  return WPA_INTERFACE_FI_W1_WPA_SUPPLICANT1_INTERFACE (g_object_new (WPA_INTERFACE_TYPE_FI_W1_WPA_SUPPLICANT1_INTERFACE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface fi.w1.wpa_supplicant1.Interface.WPS
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:wpainterfaceWPS
 * @title: wpainterfaceWPS
 * @short_description: Generated C code for the fi.w1.wpa_supplicant1.Interface.WPS D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-WPS.top_of_page">fi.w1.wpa_supplicant1.Interface.WPS</link> D-Bus interface in C.
 */

/* ---- Introspection data for fi.w1.wpa_supplicant1.Interface.WPS ---- */

static const _ExtendedGDBusArgInfo _wpa_interface_wps_method_info_start_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_wps_method_info_start_IN_ARG_pointers[] =
{
  &_wpa_interface_wps_method_info_start_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusArgInfo _wpa_interface_wps_method_info_start_OUT_ARG_output =
{
  {
    -1,
    (gchar *) "output",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_wps_method_info_start_OUT_ARG_pointers[] =
{
  &_wpa_interface_wps_method_info_start_OUT_ARG_output,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_wps_method_info_start =
{
  {
    -1,
    (gchar *) "Start",
    (GDBusArgInfo **) &_wpa_interface_wps_method_info_start_IN_ARG_pointers,
    (GDBusArgInfo **) &_wpa_interface_wps_method_info_start_OUT_ARG_pointers,
    NULL
  },
  "handle-start",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_wps_method_info_cancel =
{
  {
    -1,
    (gchar *) "Cancel",
    NULL,
    NULL,
    NULL
  },
  "handle-cancel",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _wpa_interface_wps_method_info_pointers[] =
{
  &_wpa_interface_wps_method_info_start,
  &_wpa_interface_wps_method_info_cancel,
  NULL
};

static const _ExtendedGDBusArgInfo _wpa_interface_wps_signal_info_event_ARG_name =
{
  {
    -1,
    (gchar *) "name",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_wps_signal_info_event_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_wps_signal_info_event_ARG_pointers[] =
{
  &_wpa_interface_wps_signal_info_event_ARG_name,
  &_wpa_interface_wps_signal_info_event_ARG_args,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_wps_signal_info_event =
{
  {
    -1,
    (gchar *) "Event",
    (GDBusArgInfo **) &_wpa_interface_wps_signal_info_event_ARG_pointers,
    NULL
  },
  "event"
};

static const _ExtendedGDBusArgInfo _wpa_interface_wps_signal_info_credentials_ARG_credentials =
{
  {
    -1,
    (gchar *) "credentials",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_wps_signal_info_credentials_ARG_pointers[] =
{
  &_wpa_interface_wps_signal_info_credentials_ARG_credentials,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_wps_signal_info_credentials =
{
  {
    -1,
    (gchar *) "Credentials",
    (GDBusArgInfo **) &_wpa_interface_wps_signal_info_credentials_ARG_pointers,
    NULL
  },
  "credentials"
};

static const _ExtendedGDBusArgInfo _wpa_interface_wps_signal_info_properties_changed_ARG_properties =
{
  {
    -1,
    (gchar *) "properties",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_wps_signal_info_properties_changed_ARG_pointers[] =
{
  &_wpa_interface_wps_signal_info_properties_changed_ARG_properties,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_wps_signal_info_properties_changed =
{
  {
    -1,
    (gchar *) "PropertiesChanged",
    (GDBusArgInfo **) &_wpa_interface_wps_signal_info_properties_changed_ARG_pointers,
    NULL
  },
  "properties-changed"
};

static const _ExtendedGDBusSignalInfo * const _wpa_interface_wps_signal_info_pointers[] =
{
  &_wpa_interface_wps_signal_info_event,
  &_wpa_interface_wps_signal_info_credentials,
  &_wpa_interface_wps_signal_info_properties_changed,
  NULL
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_wps_property_info_process_credentials =
{
  {
    -1,
    (gchar *) "ProcessCredentials",
    (gchar *) "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "process-credentials",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_wps_property_info_config_methods =
{
  {
    -1,
    (gchar *) "ConfigMethods",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "config-methods",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_wps_property_info_device_name =
{
  {
    -1,
    (gchar *) "DeviceName",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "device-name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_wps_property_info_manufacturer =
{
  {
    -1,
    (gchar *) "Manufacturer",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "manufacturer",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_wps_property_info_model_name =
{
  {
    -1,
    (gchar *) "ModelName",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "model-name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_wps_property_info_model_number =
{
  {
    -1,
    (gchar *) "ModelNumber",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "model-number",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_wps_property_info_serial_number =
{
  {
    -1,
    (gchar *) "SerialNumber",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "serial-number",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_wps_property_info_device_type =
{
  {
    -1,
    (gchar *) "DeviceType",
    (gchar *) "ay",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "device-type",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _wpa_interface_wps_property_info_pointers[] =
{
  &_wpa_interface_wps_property_info_process_credentials,
  &_wpa_interface_wps_property_info_config_methods,
  &_wpa_interface_wps_property_info_device_name,
  &_wpa_interface_wps_property_info_manufacturer,
  &_wpa_interface_wps_property_info_model_name,
  &_wpa_interface_wps_property_info_model_number,
  &_wpa_interface_wps_property_info_serial_number,
  &_wpa_interface_wps_property_info_device_type,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _wpa_interface_wps_interface_info =
{
  {
    -1,
    (gchar *) "fi.w1.wpa_supplicant1.Interface.WPS",
    (GDBusMethodInfo **) &_wpa_interface_wps_method_info_pointers,
    (GDBusSignalInfo **) &_wpa_interface_wps_signal_info_pointers,
    (GDBusPropertyInfo **) &_wpa_interface_wps_property_info_pointers,
    NULL
  },
  "wps",
};


/**
 * wpa_interface_wps_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-WPS.top_of_page">fi.w1.wpa_supplicant1.Interface.WPS</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
wpa_interface_wps_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_wpa_interface_wps_interface_info.parent_struct;
}

/**
 * wpa_interface_wps_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #wpainterfaceWPS interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
wpa_interface_wps_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "process-credentials");
  g_object_class_override_property (klass, property_id_begin++, "config-methods");
  g_object_class_override_property (klass, property_id_begin++, "device-name");
  g_object_class_override_property (klass, property_id_begin++, "manufacturer");
  g_object_class_override_property (klass, property_id_begin++, "model-name");
  g_object_class_override_property (klass, property_id_begin++, "model-number");
  g_object_class_override_property (klass, property_id_begin++, "serial-number");
  g_object_class_override_property (klass, property_id_begin++, "device-type");
  return property_id_begin - 1;
}



/**
 * wpainterfaceWPS:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-WPS.top_of_page">fi.w1.wpa_supplicant1.Interface.WPS</link>.
 */

/**
 * wpainterfaceWPSIface:
 * @parent_iface: The parent interface.
 * @handle_cancel: Handler for the #wpainterfaceWPS::handle-cancel signal.
 * @handle_start: Handler for the #wpainterfaceWPS::handle-start signal.
 * @get_config_methods: Getter for the #wpainterfaceWPS:config-methods property.
 * @get_device_name: Getter for the #wpainterfaceWPS:device-name property.
 * @get_device_type: Getter for the #wpainterfaceWPS:device-type property.
 * @get_manufacturer: Getter for the #wpainterfaceWPS:manufacturer property.
 * @get_model_name: Getter for the #wpainterfaceWPS:model-name property.
 * @get_model_number: Getter for the #wpainterfaceWPS:model-number property.
 * @get_process_credentials: Getter for the #wpainterfaceWPS:process-credentials property.
 * @get_serial_number: Getter for the #wpainterfaceWPS:serial-number property.
 * @credentials: Handler for the #wpainterfaceWPS::credentials signal.
 * @event: Handler for the #wpainterfaceWPS::event signal.
 * @properties_changed: Handler for the #wpainterfaceWPS::properties-changed signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-WPS.top_of_page">fi.w1.wpa_supplicant1.Interface.WPS</link>.
 */

typedef wpainterfaceWPSIface wpainterfaceWPSInterface;
G_DEFINE_INTERFACE (wpainterfaceWPS, wpa_interface_wps, G_TYPE_OBJECT);

static void
wpa_interface_wps_default_init (wpainterfaceWPSIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * wpainterfaceWPS::handle-start:
   * @object: A #wpainterfaceWPS.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-WPS.Start">Start()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_wps_complete_start() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-start",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceWPSIface, handle_start),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceWPS::handle-cancel:
   * @object: A #wpainterfaceWPS.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-WPS.Cancel">Cancel()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_wps_complete_cancel() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-cancel",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceWPSIface, handle_cancel),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * wpainterfaceWPS::event:
   * @object: A #wpainterfaceWPS.
   * @arg_name: Argument.
   * @arg_args: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-WPS.Event">"Event"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("event",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceWPSIface, event),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_VARIANT);

  /**
   * wpainterfaceWPS::credentials:
   * @object: A #wpainterfaceWPS.
   * @arg_credentials: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-WPS.Credentials">"Credentials"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("credentials",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceWPSIface, credentials),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_VARIANT);

  /**
   * wpainterfaceWPS::properties-changed:
   * @object: A #wpainterfaceWPS.
   * @arg_properties: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-WPS.PropertiesChanged">"PropertiesChanged"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("properties-changed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceWPSIface, properties_changed),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_VARIANT);

  /* GObject properties for D-Bus properties: */
  /**
   * wpainterfaceWPS:process-credentials:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ProcessCredentials">"ProcessCredentials"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("process-credentials", "ProcessCredentials", "ProcessCredentials", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceWPS:config-methods:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ConfigMethods">"ConfigMethods"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("config-methods", "ConfigMethods", "ConfigMethods", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceWPS:device-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.DeviceName">"DeviceName"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("device-name", "DeviceName", "DeviceName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceWPS:manufacturer:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.Manufacturer">"Manufacturer"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("manufacturer", "Manufacturer", "Manufacturer", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceWPS:model-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ModelName">"ModelName"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("model-name", "ModelName", "ModelName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceWPS:model-number:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ModelNumber">"ModelNumber"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("model-number", "ModelNumber", "ModelNumber", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceWPS:serial-number:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.SerialNumber">"SerialNumber"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("serial-number", "SerialNumber", "SerialNumber", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceWPS:device-type:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.DeviceType">"DeviceType"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("device-type", "DeviceType", "DeviceType", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * wpa_interface_wps_get_process_credentials: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ProcessCredentials">"ProcessCredentials"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: The property value.
 */
gboolean 
wpa_interface_wps_get_process_credentials (wpainterfaceWPS *object)
{
  return WPA_INTERFACE_WPS_GET_IFACE (object)->get_process_credentials (object);
}

/**
 * wpa_interface_wps_set_process_credentials: (skip)
 * @object: A #wpainterfaceWPS.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ProcessCredentials">"ProcessCredentials"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_wps_set_process_credentials (wpainterfaceWPS *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "process-credentials", value, NULL);
}

/**
 * wpa_interface_wps_get_config_methods: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ConfigMethods">"ConfigMethods"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_wps_dup_config_methods() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_wps_get_config_methods (wpainterfaceWPS *object)
{
  return WPA_INTERFACE_WPS_GET_IFACE (object)->get_config_methods (object);
}

/**
 * wpa_interface_wps_dup_config_methods: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ConfigMethods">"ConfigMethods"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_wps_dup_config_methods (wpainterfaceWPS *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "config-methods", &value, NULL);
  return value;
}

/**
 * wpa_interface_wps_set_config_methods: (skip)
 * @object: A #wpainterfaceWPS.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ConfigMethods">"ConfigMethods"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_wps_set_config_methods (wpainterfaceWPS *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "config-methods", value, NULL);
}

/**
 * wpa_interface_wps_get_device_name: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.DeviceName">"DeviceName"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_wps_dup_device_name() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_wps_get_device_name (wpainterfaceWPS *object)
{
  return WPA_INTERFACE_WPS_GET_IFACE (object)->get_device_name (object);
}

/**
 * wpa_interface_wps_dup_device_name: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.DeviceName">"DeviceName"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_wps_dup_device_name (wpainterfaceWPS *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "device-name", &value, NULL);
  return value;
}

/**
 * wpa_interface_wps_set_device_name: (skip)
 * @object: A #wpainterfaceWPS.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.DeviceName">"DeviceName"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_wps_set_device_name (wpainterfaceWPS *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "device-name", value, NULL);
}

/**
 * wpa_interface_wps_get_manufacturer: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.Manufacturer">"Manufacturer"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_wps_dup_manufacturer() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_wps_get_manufacturer (wpainterfaceWPS *object)
{
  return WPA_INTERFACE_WPS_GET_IFACE (object)->get_manufacturer (object);
}

/**
 * wpa_interface_wps_dup_manufacturer: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.Manufacturer">"Manufacturer"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_wps_dup_manufacturer (wpainterfaceWPS *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "manufacturer", &value, NULL);
  return value;
}

/**
 * wpa_interface_wps_set_manufacturer: (skip)
 * @object: A #wpainterfaceWPS.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.Manufacturer">"Manufacturer"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_wps_set_manufacturer (wpainterfaceWPS *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "manufacturer", value, NULL);
}

/**
 * wpa_interface_wps_get_model_name: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ModelName">"ModelName"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_wps_dup_model_name() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_wps_get_model_name (wpainterfaceWPS *object)
{
  return WPA_INTERFACE_WPS_GET_IFACE (object)->get_model_name (object);
}

/**
 * wpa_interface_wps_dup_model_name: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ModelName">"ModelName"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_wps_dup_model_name (wpainterfaceWPS *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "model-name", &value, NULL);
  return value;
}

/**
 * wpa_interface_wps_set_model_name: (skip)
 * @object: A #wpainterfaceWPS.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ModelName">"ModelName"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_wps_set_model_name (wpainterfaceWPS *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "model-name", value, NULL);
}

/**
 * wpa_interface_wps_get_model_number: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ModelNumber">"ModelNumber"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_wps_dup_model_number() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_wps_get_model_number (wpainterfaceWPS *object)
{
  return WPA_INTERFACE_WPS_GET_IFACE (object)->get_model_number (object);
}

/**
 * wpa_interface_wps_dup_model_number: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ModelNumber">"ModelNumber"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_wps_dup_model_number (wpainterfaceWPS *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "model-number", &value, NULL);
  return value;
}

/**
 * wpa_interface_wps_set_model_number: (skip)
 * @object: A #wpainterfaceWPS.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.ModelNumber">"ModelNumber"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_wps_set_model_number (wpainterfaceWPS *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "model-number", value, NULL);
}

/**
 * wpa_interface_wps_get_serial_number: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.SerialNumber">"SerialNumber"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_wps_dup_serial_number() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_wps_get_serial_number (wpainterfaceWPS *object)
{
  return WPA_INTERFACE_WPS_GET_IFACE (object)->get_serial_number (object);
}

/**
 * wpa_interface_wps_dup_serial_number: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.SerialNumber">"SerialNumber"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_wps_dup_serial_number (wpainterfaceWPS *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "serial-number", &value, NULL);
  return value;
}

/**
 * wpa_interface_wps_set_serial_number: (skip)
 * @object: A #wpainterfaceWPS.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.SerialNumber">"SerialNumber"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_wps_set_serial_number (wpainterfaceWPS *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "serial-number", value, NULL);
}

/**
 * wpa_interface_wps_get_device_type: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.DeviceType">"DeviceType"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_wps_dup_device_type() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_wps_get_device_type (wpainterfaceWPS *object)
{
  return WPA_INTERFACE_WPS_GET_IFACE (object)->get_device_type (object);
}

/**
 * wpa_interface_wps_dup_device_type: (skip)
 * @object: A #wpainterfaceWPS.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.DeviceType">"DeviceType"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_wps_dup_device_type (wpainterfaceWPS *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "device-type", &value, NULL);
  return value;
}

/**
 * wpa_interface_wps_set_device_type: (skip)
 * @object: A #wpainterfaceWPS.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-WPS.DeviceType">"DeviceType"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_wps_set_device_type (wpainterfaceWPS *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "device-type", value, NULL);
}

/**
 * wpa_interface_wps_emit_event:
 * @object: A #wpainterfaceWPS.
 * @arg_name: Argument to pass with the signal.
 * @arg_args: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-WPS.Event">"Event"</link> D-Bus signal.
 */
void
wpa_interface_wps_emit_event (
    wpainterfaceWPS *object,
    const gchar *arg_name,
    GVariant *arg_args)
{
  g_signal_emit_by_name (object, "event", arg_name, arg_args);
}

/**
 * wpa_interface_wps_emit_credentials:
 * @object: A #wpainterfaceWPS.
 * @arg_credentials: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-WPS.Credentials">"Credentials"</link> D-Bus signal.
 */
void
wpa_interface_wps_emit_credentials (
    wpainterfaceWPS *object,
    GVariant *arg_credentials)
{
  g_signal_emit_by_name (object, "credentials", arg_credentials);
}

/**
 * wpa_interface_wps_emit_properties_changed:
 * @object: A #wpainterfaceWPS.
 * @arg_properties: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-WPS.PropertiesChanged">"PropertiesChanged"</link> D-Bus signal.
 */
void
wpa_interface_wps_emit_properties_changed (
    wpainterfaceWPS *object,
    GVariant *arg_properties)
{
  g_signal_emit_by_name (object, "properties-changed", arg_properties);
}

/**
 * wpa_interface_wps_call_start:
 * @proxy: A #wpainterfaceWPSProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-WPS.Start">Start()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_wps_call_start_finish() to get the result of the operation.
 *
 * See wpa_interface_wps_call_start_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_wps_call_start (
    wpainterfaceWPS *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Start",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_wps_call_start_finish:
 * @proxy: A #wpainterfaceWPSProxy.
 * @out_output: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_wps_call_start().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_wps_call_start().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_wps_call_start_finish (
    wpainterfaceWPS *proxy,
    GVariant **out_output,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@a{sv})",
                 out_output);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_wps_call_start_sync:
 * @proxy: A #wpainterfaceWPSProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @out_output: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-WPS.Start">Start()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_wps_call_start() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_wps_call_start_sync (
    wpainterfaceWPS *proxy,
    GVariant *arg_args,
    GVariant **out_output,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Start",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@a{sv})",
                 out_output);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_wps_call_cancel:
 * @proxy: A #wpainterfaceWPSProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-WPS.Cancel">Cancel()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_wps_call_cancel_finish() to get the result of the operation.
 *
 * See wpa_interface_wps_call_cancel_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_wps_call_cancel (
    wpainterfaceWPS *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Cancel",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_wps_call_cancel_finish:
 * @proxy: A #wpainterfaceWPSProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_wps_call_cancel().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_wps_call_cancel().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_wps_call_cancel_finish (
    wpainterfaceWPS *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_wps_call_cancel_sync:
 * @proxy: A #wpainterfaceWPSProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-WPS.Cancel">Cancel()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_wps_call_cancel() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_wps_call_cancel_sync (
    wpainterfaceWPS *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Cancel",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_wps_complete_start:
 * @object: A #wpainterfaceWPS.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @output: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-WPS.Start">Start()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_wps_complete_start (
    wpainterfaceWPS *object,
    GDBusMethodInvocation *invocation,
    GVariant *output)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(@a{sv})",
                   output));
}

/**
 * wpa_interface_wps_complete_cancel:
 * @object: A #wpainterfaceWPS.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-WPS.Cancel">Cancel()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_wps_complete_cancel (
    wpainterfaceWPS *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * wpainterfaceWPSProxy:
 *
 * The #wpainterfaceWPSProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * wpainterfaceWPSProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #wpainterfaceWPSProxy.
 */

struct _wpainterfaceWPSProxyPrivate
{
  GData *qdata;
};

static void wpa_interface_wps_proxy_iface_init (wpainterfaceWPSIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (wpainterfaceWPSProxy, wpa_interface_wps_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (wpainterfaceWPSProxy)
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_WPS, wpa_interface_wps_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (wpainterfaceWPSProxy, wpa_interface_wps_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_WPS, wpa_interface_wps_proxy_iface_init));

#endif
static void
wpa_interface_wps_proxy_finalize (GObject *object)
{
  wpainterfaceWPSProxy *proxy = WPA_INTERFACE_WPS_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (wpa_interface_wps_proxy_parent_class)->finalize (object);
}

static void
wpa_interface_wps_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 8);
  info = _wpa_interface_wps_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
wpa_interface_wps_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface fi.w1.wpa_supplicant1.Interface.WPS: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
wpa_interface_wps_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 8);
  info = _wpa_interface_wps_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "fi.w1.wpa_supplicant1.Interface.WPS", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) wpa_interface_wps_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
wpa_interface_wps_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_wpa_interface_wps_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], WPA_INTERFACE_TYPE_WPS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, WPA_INTERFACE_TYPE_WPS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
wpa_interface_wps_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  wpainterfaceWPSProxy *proxy = WPA_INTERFACE_WPS_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_wps_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_wps_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static gboolean 
wpa_interface_wps_proxy_get_process_credentials (wpainterfaceWPS *object)
{
  wpainterfaceWPSProxy *proxy = WPA_INTERFACE_WPS_PROXY (object);
  GVariant *variant;
  gboolean value = 0;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ProcessCredentials");
  if (variant != NULL)
    {
      value = g_variant_get_boolean (variant);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_wps_proxy_get_config_methods (wpainterfaceWPS *object)
{
  wpainterfaceWPSProxy *proxy = WPA_INTERFACE_WPS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ConfigMethods");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_wps_proxy_get_device_name (wpainterfaceWPS *object)
{
  wpainterfaceWPSProxy *proxy = WPA_INTERFACE_WPS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DeviceName");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_wps_proxy_get_manufacturer (wpainterfaceWPS *object)
{
  wpainterfaceWPSProxy *proxy = WPA_INTERFACE_WPS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Manufacturer");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_wps_proxy_get_model_name (wpainterfaceWPS *object)
{
  wpainterfaceWPSProxy *proxy = WPA_INTERFACE_WPS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ModelName");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_wps_proxy_get_model_number (wpainterfaceWPS *object)
{
  wpainterfaceWPSProxy *proxy = WPA_INTERFACE_WPS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "ModelNumber");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_wps_proxy_get_serial_number (wpainterfaceWPS *object)
{
  wpainterfaceWPSProxy *proxy = WPA_INTERFACE_WPS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "SerialNumber");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_wps_proxy_get_device_type (wpainterfaceWPS *object)
{
  wpainterfaceWPSProxy *proxy = WPA_INTERFACE_WPS_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "DeviceType");
  if (variant != NULL)
    {
      value = g_variant_get_bytestring (variant);
      g_variant_unref (variant);
    }
  return value;
}

static void
wpa_interface_wps_proxy_init (wpainterfaceWPSProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = wpa_interface_wps_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, WPA_INTERFACE_TYPE_WPS_PROXY, wpainterfaceWPSProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), wpa_interface_wps_interface_info ());
}

static void
wpa_interface_wps_proxy_class_init (wpainterfaceWPSProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = wpa_interface_wps_proxy_finalize;
  gobject_class->get_property = wpa_interface_wps_proxy_get_property;
  gobject_class->set_property = wpa_interface_wps_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = wpa_interface_wps_proxy_g_signal;
  proxy_class->g_properties_changed = wpa_interface_wps_proxy_g_properties_changed;

  wpa_interface_wps_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (wpainterfaceWPSProxyPrivate));
#endif
}

static void
wpa_interface_wps_proxy_iface_init (wpainterfaceWPSIface *iface)
{
  iface->get_process_credentials = wpa_interface_wps_proxy_get_process_credentials;
  iface->get_config_methods = wpa_interface_wps_proxy_get_config_methods;
  iface->get_device_name = wpa_interface_wps_proxy_get_device_name;
  iface->get_manufacturer = wpa_interface_wps_proxy_get_manufacturer;
  iface->get_model_name = wpa_interface_wps_proxy_get_model_name;
  iface->get_model_number = wpa_interface_wps_proxy_get_model_number;
  iface->get_serial_number = wpa_interface_wps_proxy_get_serial_number;
  iface->get_device_type = wpa_interface_wps_proxy_get_device_type;
}

/**
 * wpa_interface_wps_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-WPS.top_of_page">fi.w1.wpa_supplicant1.Interface.WPS</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_wps_proxy_new_finish() to get the result of the operation.
 *
 * See wpa_interface_wps_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
wpa_interface_wps_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (WPA_INTERFACE_TYPE_WPS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "fi.w1.wpa_supplicant1.Interface.WPS", NULL);
}

/**
 * wpa_interface_wps_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_wps_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with wpa_interface_wps_proxy_new().
 *
 * Returns: (transfer full) (type wpainterfaceWPSProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceWPS *
wpa_interface_wps_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return WPA_INTERFACE_WPS (ret);
  else
    return NULL;
}

/**
 * wpa_interface_wps_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-WPS.top_of_page">fi.w1.wpa_supplicant1.Interface.WPS</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_wps_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type wpainterfaceWPSProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceWPS *
wpa_interface_wps_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (WPA_INTERFACE_TYPE_WPS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "fi.w1.wpa_supplicant1.Interface.WPS", NULL);
  if (ret != NULL)
    return WPA_INTERFACE_WPS (ret);
  else
    return NULL;
}


/**
 * wpa_interface_wps_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like wpa_interface_wps_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_wps_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See wpa_interface_wps_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
wpa_interface_wps_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (WPA_INTERFACE_TYPE_WPS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "fi.w1.wpa_supplicant1.Interface.WPS", NULL);
}

/**
 * wpa_interface_wps_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_wps_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with wpa_interface_wps_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type wpainterfaceWPSProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceWPS *
wpa_interface_wps_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return WPA_INTERFACE_WPS (ret);
  else
    return NULL;
}

/**
 * wpa_interface_wps_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like wpa_interface_wps_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_wps_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type wpainterfaceWPSProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceWPS *
wpa_interface_wps_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (WPA_INTERFACE_TYPE_WPS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "fi.w1.wpa_supplicant1.Interface.WPS", NULL);
  if (ret != NULL)
    return WPA_INTERFACE_WPS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * wpainterfaceWPSSkeleton:
 *
 * The #wpainterfaceWPSSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * wpainterfaceWPSSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #wpainterfaceWPSSkeleton.
 */

struct _wpainterfaceWPSSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_wpa_interface_wps_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], WPA_INTERFACE_TYPE_WPS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, WPA_INTERFACE_TYPE_WPS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_wpa_interface_wps_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_wps_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_wpa_interface_wps_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_wps_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _wpa_interface_wps_skeleton_vtable =
{
  _wpa_interface_wps_skeleton_handle_method_call,
  _wpa_interface_wps_skeleton_handle_get_property,
  _wpa_interface_wps_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
wpa_interface_wps_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return wpa_interface_wps_interface_info ();
}

static GDBusInterfaceVTable *
wpa_interface_wps_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_wpa_interface_wps_skeleton_vtable;
}

static GVariant *
wpa_interface_wps_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_wpa_interface_wps_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _wpa_interface_wps_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _wpa_interface_wps_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _wpa_interface_wps_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.WPS", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _wpa_interface_wps_emit_changed (gpointer user_data);

static void
wpa_interface_wps_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _wpa_interface_wps_emit_changed (skeleton);
}

static void
_wpa_interface_wps_on_signal_event (
    wpainterfaceWPS *object,
    const gchar *arg_name,
    GVariant *arg_args)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(s@a{sv})",
                   arg_name,
                   arg_args));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.WPS", "Event",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_wps_on_signal_credentials (
    wpainterfaceWPS *object,
    GVariant *arg_credentials)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@a{sv})",
                   arg_credentials));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.WPS", "Credentials",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_wps_on_signal_properties_changed (
    wpainterfaceWPS *object,
    GVariant *arg_properties)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@a{sv})",
                   arg_properties));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.WPS", "PropertiesChanged",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void wpa_interface_wps_skeleton_iface_init (wpainterfaceWPSIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (wpainterfaceWPSSkeleton, wpa_interface_wps_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (wpainterfaceWPSSkeleton)
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_WPS, wpa_interface_wps_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (wpainterfaceWPSSkeleton, wpa_interface_wps_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_WPS, wpa_interface_wps_skeleton_iface_init));

#endif
static void
wpa_interface_wps_skeleton_finalize (GObject *object)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);
  guint n;
  for (n = 0; n < 8; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (wpa_interface_wps_skeleton_parent_class)->finalize (object);
}

static void
wpa_interface_wps_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 8);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_wpa_interface_wps_emit_changed (gpointer user_data)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "fi.w1.wpa_supplicant1.Interface.WPS",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_wpa_interface_wps_schedule_emit_changed (wpainterfaceWPSSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
wpa_interface_wps_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _wpa_interface_wps_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _wpa_interface_wps_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
wpa_interface_wps_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 8);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _wpa_interface_wps_schedule_emit_changed (skeleton, _wpa_interface_wps_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
wpa_interface_wps_skeleton_init (wpainterfaceWPSSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = wpa_interface_wps_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, WPA_INTERFACE_TYPE_WPS_SKELETON, wpainterfaceWPSSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 8);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_BOOLEAN);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[3], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[4], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[5], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[6], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[7], G_TYPE_STRING);
}

static gboolean 
wpa_interface_wps_skeleton_get_process_credentials (wpainterfaceWPS *object)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);
  gboolean value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boolean (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_wps_skeleton_get_config_methods (wpainterfaceWPS *object)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_wps_skeleton_get_device_name (wpainterfaceWPS *object)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_wps_skeleton_get_manufacturer (wpainterfaceWPS *object)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[3]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_wps_skeleton_get_model_name (wpainterfaceWPS *object)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[4]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_wps_skeleton_get_model_number (wpainterfaceWPS *object)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[5]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_wps_skeleton_get_serial_number (wpainterfaceWPS *object)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[6]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_wps_skeleton_get_device_type (wpainterfaceWPS *object)
{
  wpainterfaceWPSSkeleton *skeleton = WPA_INTERFACE_WPS_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[7]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
wpa_interface_wps_skeleton_class_init (wpainterfaceWPSSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = wpa_interface_wps_skeleton_finalize;
  gobject_class->get_property = wpa_interface_wps_skeleton_get_property;
  gobject_class->set_property = wpa_interface_wps_skeleton_set_property;
  gobject_class->notify       = wpa_interface_wps_skeleton_notify;


  wpa_interface_wps_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = wpa_interface_wps_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = wpa_interface_wps_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = wpa_interface_wps_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = wpa_interface_wps_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (wpainterfaceWPSSkeletonPrivate));
#endif
}

static void
wpa_interface_wps_skeleton_iface_init (wpainterfaceWPSIface *iface)
{
  iface->event = _wpa_interface_wps_on_signal_event;
  iface->credentials = _wpa_interface_wps_on_signal_credentials;
  iface->properties_changed = _wpa_interface_wps_on_signal_properties_changed;
  iface->get_process_credentials = wpa_interface_wps_skeleton_get_process_credentials;
  iface->get_config_methods = wpa_interface_wps_skeleton_get_config_methods;
  iface->get_device_name = wpa_interface_wps_skeleton_get_device_name;
  iface->get_manufacturer = wpa_interface_wps_skeleton_get_manufacturer;
  iface->get_model_name = wpa_interface_wps_skeleton_get_model_name;
  iface->get_model_number = wpa_interface_wps_skeleton_get_model_number;
  iface->get_serial_number = wpa_interface_wps_skeleton_get_serial_number;
  iface->get_device_type = wpa_interface_wps_skeleton_get_device_type;
}

/**
 * wpa_interface_wps_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-WPS.top_of_page">fi.w1.wpa_supplicant1.Interface.WPS</link>.
 *
 * Returns: (transfer full) (type wpainterfaceWPSSkeleton): The skeleton object.
 */
wpainterfaceWPS *
wpa_interface_wps_skeleton_new (void)
{
  return WPA_INTERFACE_WPS (g_object_new (WPA_INTERFACE_TYPE_WPS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface fi.w1.wpa_supplicant1.Interface.P2PDevice
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:wpainterfaceP2PDevice
 * @title: wpainterfaceP2PDevice
 * @short_description: Generated C code for the fi.w1.wpa_supplicant1.Interface.P2PDevice D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-P2PDevice.top_of_page">fi.w1.wpa_supplicant1.Interface.P2PDevice</link> D-Bus interface in C.
 */

/* ---- Introspection data for fi.w1.wpa_supplicant1.Interface.P2PDevice ---- */

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_find_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_find_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_find_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_find =
{
  {
    -1,
    (gchar *) "Find",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_find_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-find",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_stop_find =
{
  {
    -1,
    (gchar *) "StopFind",
    NULL,
    NULL,
    NULL
  },
  "handle-stop-find",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_listen_IN_ARG_timeout =
{
  {
    -1,
    (gchar *) "timeout",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_listen_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_listen_IN_ARG_timeout,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_listen =
{
  {
    -1,
    (gchar *) "Listen",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_listen_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-listen",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_extended_listen_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_extended_listen_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_extended_listen_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_extended_listen =
{
  {
    -1,
    (gchar *) "ExtendedListen",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_extended_listen_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-extended-listen",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_presence_request_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_presence_request_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_presence_request_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_presence_request =
{
  {
    -1,
    (gchar *) "PresenceRequest",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_presence_request_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-presence-request",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_provision_discovery_request_IN_ARG_peer =
{
  {
    -1,
    (gchar *) "peer",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_provision_discovery_request_IN_ARG_config_method =
{
  {
    -1,
    (gchar *) "config_method",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_provision_discovery_request_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_provision_discovery_request_IN_ARG_peer,
  &_wpa_interface_p2_pdevice_method_info_provision_discovery_request_IN_ARG_config_method,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_provision_discovery_request =
{
  {
    -1,
    (gchar *) "ProvisionDiscoveryRequest",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_provision_discovery_request_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-provision-discovery-request",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_connect_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_connect_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_connect_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_connect_OUT_ARG_generated_pin =
{
  {
    -1,
    (gchar *) "generated_pin",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_connect_OUT_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_connect_OUT_ARG_generated_pin,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_connect =
{
  {
    -1,
    (gchar *) "Connect",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_connect_IN_ARG_pointers,
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_connect_OUT_ARG_pointers,
    NULL
  },
  "handle-connect",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_group_add_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_group_add_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_group_add_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_group_add =
{
  {
    -1,
    (gchar *) "GroupAdd",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_group_add_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-group-add",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_cancel =
{
  {
    -1,
    (gchar *) "Cancel",
    NULL,
    NULL,
    NULL
  },
  "handle-cancel",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_invite_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_invite_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_invite_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_invite =
{
  {
    -1,
    (gchar *) "Invite",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_invite_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-invite",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_disconnect =
{
  {
    -1,
    (gchar *) "Disconnect",
    NULL,
    NULL,
    NULL
  },
  "handle-disconnect",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_reject_peer_IN_ARG_peer =
{
  {
    -1,
    (gchar *) "peer",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_reject_peer_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_reject_peer_IN_ARG_peer,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_reject_peer =
{
  {
    -1,
    (gchar *) "RejectPeer",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_reject_peer_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-reject-peer",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_remove_client_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_remove_client_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_remove_client_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_remove_client =
{
  {
    -1,
    (gchar *) "RemoveClient",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_remove_client_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-remove-client",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_flush =
{
  {
    -1,
    (gchar *) "Flush",
    NULL,
    NULL,
    NULL
  },
  "handle-flush",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_add_service_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_add_service_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_add_service_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_add_service =
{
  {
    -1,
    (gchar *) "AddService",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_add_service_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-add-service",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_delete_service_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_delete_service_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_delete_service_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_delete_service =
{
  {
    -1,
    (gchar *) "DeleteService",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_delete_service_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-delete-service",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_flush_service =
{
  {
    -1,
    (gchar *) "FlushService",
    NULL,
    NULL,
    NULL
  },
  "handle-flush-service",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_service_discovery_request_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_service_discovery_request_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_service_discovery_request_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_service_discovery_request_OUT_ARG_ref =
{
  {
    -1,
    (gchar *) "ref",
    (gchar *) "t",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_service_discovery_request_OUT_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_service_discovery_request_OUT_ARG_ref,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_service_discovery_request =
{
  {
    -1,
    (gchar *) "ServiceDiscoveryRequest",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_service_discovery_request_IN_ARG_pointers,
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_service_discovery_request_OUT_ARG_pointers,
    NULL
  },
  "handle-service-discovery-request",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_service_discovery_response_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_service_discovery_response_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_service_discovery_response_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_service_discovery_response =
{
  {
    -1,
    (gchar *) "ServiceDiscoveryResponse",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_service_discovery_response_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-service-discovery-response",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_service_discovery_cancel_request_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "t",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_service_discovery_cancel_request_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_service_discovery_cancel_request_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_service_discovery_cancel_request =
{
  {
    -1,
    (gchar *) "ServiceDiscoveryCancelRequest",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_service_discovery_cancel_request_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-service-discovery-cancel-request",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_service_update =
{
  {
    -1,
    (gchar *) "ServiceUpdate",
    NULL,
    NULL,
    NULL
  },
  "handle-service-update",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_service_discovery_external_IN_ARG_arg =
{
  {
    -1,
    (gchar *) "arg",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_service_discovery_external_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_service_discovery_external_IN_ARG_arg,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_service_discovery_external =
{
  {
    -1,
    (gchar *) "ServiceDiscoveryExternal",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_service_discovery_external_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-service-discovery-external",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_add_persistent_group_IN_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_add_persistent_group_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_add_persistent_group_IN_ARG_args,
  NULL
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_add_persistent_group_OUT_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_add_persistent_group_OUT_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_add_persistent_group_OUT_ARG_path,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_add_persistent_group =
{
  {
    -1,
    (gchar *) "AddPersistentGroup",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_add_persistent_group_IN_ARG_pointers,
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_add_persistent_group_OUT_ARG_pointers,
    NULL
  },
  "handle-add-persistent-group",
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_method_info_remove_persistent_group_IN_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_method_info_remove_persistent_group_IN_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_remove_persistent_group_IN_ARG_path,
  NULL
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_remove_persistent_group =
{
  {
    -1,
    (gchar *) "RemovePersistentGroup",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_method_info_remove_persistent_group_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-remove-persistent-group",
  FALSE
};

static const _ExtendedGDBusMethodInfo _wpa_interface_p2_pdevice_method_info_remove_all_persistent_groups =
{
  {
    -1,
    (gchar *) "RemoveAllPersistentGroups",
    NULL,
    NULL,
    NULL
  },
  "handle-remove-all-persistent-groups",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _wpa_interface_p2_pdevice_method_info_pointers[] =
{
  &_wpa_interface_p2_pdevice_method_info_find,
  &_wpa_interface_p2_pdevice_method_info_stop_find,
  &_wpa_interface_p2_pdevice_method_info_listen,
  &_wpa_interface_p2_pdevice_method_info_extended_listen,
  &_wpa_interface_p2_pdevice_method_info_presence_request,
  &_wpa_interface_p2_pdevice_method_info_provision_discovery_request,
  &_wpa_interface_p2_pdevice_method_info_connect,
  &_wpa_interface_p2_pdevice_method_info_group_add,
  &_wpa_interface_p2_pdevice_method_info_cancel,
  &_wpa_interface_p2_pdevice_method_info_invite,
  &_wpa_interface_p2_pdevice_method_info_disconnect,
  &_wpa_interface_p2_pdevice_method_info_reject_peer,
  &_wpa_interface_p2_pdevice_method_info_remove_client,
  &_wpa_interface_p2_pdevice_method_info_flush,
  &_wpa_interface_p2_pdevice_method_info_add_service,
  &_wpa_interface_p2_pdevice_method_info_delete_service,
  &_wpa_interface_p2_pdevice_method_info_flush_service,
  &_wpa_interface_p2_pdevice_method_info_service_discovery_request,
  &_wpa_interface_p2_pdevice_method_info_service_discovery_response,
  &_wpa_interface_p2_pdevice_method_info_service_discovery_cancel_request,
  &_wpa_interface_p2_pdevice_method_info_service_update,
  &_wpa_interface_p2_pdevice_method_info_service_discovery_external,
  &_wpa_interface_p2_pdevice_method_info_add_persistent_group,
  &_wpa_interface_p2_pdevice_method_info_remove_persistent_group,
  &_wpa_interface_p2_pdevice_method_info_remove_all_persistent_groups,
  NULL
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_device_found_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_device_found_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_device_found_ARG_path,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_device_found =
{
  {
    -1,
    (gchar *) "DeviceFound",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_device_found_ARG_pointers,
    NULL
  },
  "device-found"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_device_found_properties_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_device_found_properties_ARG_properties =
{
  {
    -1,
    (gchar *) "properties",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_device_found_properties_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_device_found_properties_ARG_path,
  &_wpa_interface_p2_pdevice_signal_info_device_found_properties_ARG_properties,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_device_found_properties =
{
  {
    -1,
    (gchar *) "DeviceFoundProperties",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_device_found_properties_ARG_pointers,
    NULL
  },
  "device-found-properties"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_device_lost_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_device_lost_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_device_lost_ARG_path,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_device_lost =
{
  {
    -1,
    (gchar *) "DeviceLost",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_device_lost_ARG_pointers,
    NULL
  },
  "device-lost"
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_find_stopped =
{
  {
    -1,
    (gchar *) "FindStopped",
    NULL,
    NULL
  },
  "find-stopped"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_request_display_pin_ARG_peer_object =
{
  {
    -1,
    (gchar *) "peer_object",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_request_display_pin_ARG_pin =
{
  {
    -1,
    (gchar *) "pin",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_provision_discovery_request_display_pin_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_request_display_pin_ARG_peer_object,
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_request_display_pin_ARG_pin,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_request_display_pin =
{
  {
    -1,
    (gchar *) "ProvisionDiscoveryRequestDisplayPin",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_provision_discovery_request_display_pin_ARG_pointers,
    NULL
  },
  "provision-discovery-request-display-pin"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_response_display_pin_ARG_peer_object =
{
  {
    -1,
    (gchar *) "peer_object",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_response_display_pin_ARG_pin =
{
  {
    -1,
    (gchar *) "pin",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_provision_discovery_response_display_pin_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_response_display_pin_ARG_peer_object,
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_response_display_pin_ARG_pin,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_response_display_pin =
{
  {
    -1,
    (gchar *) "ProvisionDiscoveryResponseDisplayPin",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_provision_discovery_response_display_pin_ARG_pointers,
    NULL
  },
  "provision-discovery-response-display-pin"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_request_enter_pin_ARG_peer_object =
{
  {
    -1,
    (gchar *) "peer_object",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_provision_discovery_request_enter_pin_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_request_enter_pin_ARG_peer_object,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_request_enter_pin =
{
  {
    -1,
    (gchar *) "ProvisionDiscoveryRequestEnterPin",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_provision_discovery_request_enter_pin_ARG_pointers,
    NULL
  },
  "provision-discovery-request-enter-pin"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_response_enter_pin_ARG_peer_object =
{
  {
    -1,
    (gchar *) "peer_object",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_provision_discovery_response_enter_pin_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_response_enter_pin_ARG_peer_object,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_response_enter_pin =
{
  {
    -1,
    (gchar *) "ProvisionDiscoveryResponseEnterPin",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_provision_discovery_response_enter_pin_ARG_pointers,
    NULL
  },
  "provision-discovery-response-enter-pin"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_pbcrequest_ARG_peer_object =
{
  {
    -1,
    (gchar *) "peer_object",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_provision_discovery_pbcrequest_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_pbcrequest_ARG_peer_object,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_pbcrequest =
{
  {
    -1,
    (gchar *) "ProvisionDiscoveryPBCRequest",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_provision_discovery_pbcrequest_ARG_pointers,
    NULL
  },
  "provision-discovery-pbcrequest"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_pbcresponse_ARG_peer_object =
{
  {
    -1,
    (gchar *) "peer_object",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_provision_discovery_pbcresponse_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_pbcresponse_ARG_peer_object,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_pbcresponse =
{
  {
    -1,
    (gchar *) "ProvisionDiscoveryPBCResponse",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_provision_discovery_pbcresponse_ARG_pointers,
    NULL
  },
  "provision-discovery-pbcresponse"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_failure_ARG_peer_object =
{
  {
    -1,
    (gchar *) "peer_object",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_failure_ARG_status =
{
  {
    -1,
    (gchar *) "status",
    (gchar *) "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_provision_discovery_failure_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_failure_ARG_peer_object,
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_failure_ARG_status,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_provision_discovery_failure =
{
  {
    -1,
    (gchar *) "ProvisionDiscoveryFailure",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_provision_discovery_failure_ARG_pointers,
    NULL
  },
  "provision-discovery-failure"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_group_started_ARG_properties =
{
  {
    -1,
    (gchar *) "properties",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_group_started_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_group_started_ARG_properties,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_group_started =
{
  {
    -1,
    (gchar *) "GroupStarted",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_group_started_ARG_pointers,
    NULL
  },
  "group-started"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_group_formation_failure_ARG_reason =
{
  {
    -1,
    (gchar *) "reason",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_group_formation_failure_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_group_formation_failure_ARG_reason,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_group_formation_failure =
{
  {
    -1,
    (gchar *) "GroupFormationFailure",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_group_formation_failure_ARG_pointers,
    NULL
  },
  "group-formation-failure"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_gonegotiation_success_ARG_properties =
{
  {
    -1,
    (gchar *) "properties",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_gonegotiation_success_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_gonegotiation_success_ARG_properties,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_gonegotiation_success =
{
  {
    -1,
    (gchar *) "GONegotiationSuccess",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_gonegotiation_success_ARG_pointers,
    NULL
  },
  "gonegotiation-success"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_gonegotiation_failure_ARG_properties =
{
  {
    -1,
    (gchar *) "properties",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_gonegotiation_failure_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_gonegotiation_failure_ARG_properties,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_gonegotiation_failure =
{
  {
    -1,
    (gchar *) "GONegotiationFailure",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_gonegotiation_failure_ARG_pointers,
    NULL
  },
  "gonegotiation-failure"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_gonegotiation_request_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_gonegotiation_request_ARG_dev_passwd_id =
{
  {
    -1,
    (gchar *) "dev_passwd_id",
    (gchar *) "q",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_gonegotiation_request_ARG_device_go_intent =
{
  {
    -1,
    (gchar *) "device_go_intent",
    (gchar *) "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_gonegotiation_request_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_gonegotiation_request_ARG_path,
  &_wpa_interface_p2_pdevice_signal_info_gonegotiation_request_ARG_dev_passwd_id,
  &_wpa_interface_p2_pdevice_signal_info_gonegotiation_request_ARG_device_go_intent,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_gonegotiation_request =
{
  {
    -1,
    (gchar *) "GONegotiationRequest",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_gonegotiation_request_ARG_pointers,
    NULL
  },
  "gonegotiation-request"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_invitation_result_ARG_invite_result =
{
  {
    -1,
    (gchar *) "invite_result",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_invitation_result_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_invitation_result_ARG_invite_result,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_invitation_result =
{
  {
    -1,
    (gchar *) "InvitationResult",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_invitation_result_ARG_pointers,
    NULL
  },
  "invitation-result"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_group_finished_ARG_properties =
{
  {
    -1,
    (gchar *) "properties",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_group_finished_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_group_finished_ARG_properties,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_group_finished =
{
  {
    -1,
    (gchar *) "GroupFinished",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_group_finished_ARG_pointers,
    NULL
  },
  "group-finished"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_service_discovery_request_ARG_sd_request =
{
  {
    -1,
    (gchar *) "sd_request",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_service_discovery_request_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_service_discovery_request_ARG_sd_request,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_service_discovery_request =
{
  {
    -1,
    (gchar *) "ServiceDiscoveryRequest",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_service_discovery_request_ARG_pointers,
    NULL
  },
  "service-discovery-request"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_service_discovery_response_ARG_sd_response =
{
  {
    -1,
    (gchar *) "sd_response",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_service_discovery_response_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_service_discovery_response_ARG_sd_response,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_service_discovery_response =
{
  {
    -1,
    (gchar *) "ServiceDiscoveryResponse",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_service_discovery_response_ARG_pointers,
    NULL
  },
  "service-discovery-response"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_persistent_group_added_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_persistent_group_added_ARG_properties =
{
  {
    -1,
    (gchar *) "properties",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_persistent_group_added_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_persistent_group_added_ARG_path,
  &_wpa_interface_p2_pdevice_signal_info_persistent_group_added_ARG_properties,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_persistent_group_added =
{
  {
    -1,
    (gchar *) "PersistentGroupAdded",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_persistent_group_added_ARG_pointers,
    NULL
  },
  "persistent-group-added"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_persistent_group_removed_ARG_path =
{
  {
    -1,
    (gchar *) "path",
    (gchar *) "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_persistent_group_removed_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_persistent_group_removed_ARG_path,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_persistent_group_removed =
{
  {
    -1,
    (gchar *) "PersistentGroupRemoved",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_persistent_group_removed_ARG_pointers,
    NULL
  },
  "persistent-group-removed"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_wps_failed_ARG_name =
{
  {
    -1,
    (gchar *) "name",
    (gchar *) "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_wps_failed_ARG_args =
{
  {
    -1,
    (gchar *) "args",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_wps_failed_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_wps_failed_ARG_name,
  &_wpa_interface_p2_pdevice_signal_info_wps_failed_ARG_args,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_wps_failed =
{
  {
    -1,
    (gchar *) "WpsFailed",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_wps_failed_ARG_pointers,
    NULL
  },
  "wps-failed"
};

static const _ExtendedGDBusArgInfo _wpa_interface_p2_pdevice_signal_info_invitation_received_ARG_properties =
{
  {
    -1,
    (gchar *) "properties",
    (gchar *) "a{sv}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _wpa_interface_p2_pdevice_signal_info_invitation_received_ARG_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_invitation_received_ARG_properties,
  NULL
};

static const _ExtendedGDBusSignalInfo _wpa_interface_p2_pdevice_signal_info_invitation_received =
{
  {
    -1,
    (gchar *) "InvitationReceived",
    (GDBusArgInfo **) &_wpa_interface_p2_pdevice_signal_info_invitation_received_ARG_pointers,
    NULL
  },
  "invitation-received"
};

static const _ExtendedGDBusSignalInfo * const _wpa_interface_p2_pdevice_signal_info_pointers[] =
{
  &_wpa_interface_p2_pdevice_signal_info_device_found,
  &_wpa_interface_p2_pdevice_signal_info_device_found_properties,
  &_wpa_interface_p2_pdevice_signal_info_device_lost,
  &_wpa_interface_p2_pdevice_signal_info_find_stopped,
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_request_display_pin,
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_response_display_pin,
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_request_enter_pin,
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_response_enter_pin,
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_pbcrequest,
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_pbcresponse,
  &_wpa_interface_p2_pdevice_signal_info_provision_discovery_failure,
  &_wpa_interface_p2_pdevice_signal_info_group_started,
  &_wpa_interface_p2_pdevice_signal_info_group_formation_failure,
  &_wpa_interface_p2_pdevice_signal_info_gonegotiation_success,
  &_wpa_interface_p2_pdevice_signal_info_gonegotiation_failure,
  &_wpa_interface_p2_pdevice_signal_info_gonegotiation_request,
  &_wpa_interface_p2_pdevice_signal_info_invitation_result,
  &_wpa_interface_p2_pdevice_signal_info_group_finished,
  &_wpa_interface_p2_pdevice_signal_info_service_discovery_request,
  &_wpa_interface_p2_pdevice_signal_info_service_discovery_response,
  &_wpa_interface_p2_pdevice_signal_info_persistent_group_added,
  &_wpa_interface_p2_pdevice_signal_info_persistent_group_removed,
  &_wpa_interface_p2_pdevice_signal_info_wps_failed,
  &_wpa_interface_p2_pdevice_signal_info_invitation_received,
  NULL
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_p2_pdevice_property_info_p2_pdevice_config =
{
  {
    -1,
    (gchar *) "P2PDeviceConfig",
    (gchar *) "a{sv}",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "p2-pdevice-config",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_p2_pdevice_property_info_peers =
{
  {
    -1,
    (gchar *) "Peers",
    (gchar *) "ao",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "peers",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_p2_pdevice_property_info_role =
{
  {
    -1,
    (gchar *) "Role",
    (gchar *) "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "role",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_p2_pdevice_property_info_group =
{
  {
    -1,
    (gchar *) "Group",
    (gchar *) "o",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "group",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_p2_pdevice_property_info_peer_go =
{
  {
    -1,
    (gchar *) "PeerGO",
    (gchar *) "o",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "peer-go",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _wpa_interface_p2_pdevice_property_info_persistent_groups =
{
  {
    -1,
    (gchar *) "PersistentGroups",
    (gchar *) "ao",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "persistent-groups",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _wpa_interface_p2_pdevice_property_info_pointers[] =
{
  &_wpa_interface_p2_pdevice_property_info_p2_pdevice_config,
  &_wpa_interface_p2_pdevice_property_info_peers,
  &_wpa_interface_p2_pdevice_property_info_role,
  &_wpa_interface_p2_pdevice_property_info_group,
  &_wpa_interface_p2_pdevice_property_info_peer_go,
  &_wpa_interface_p2_pdevice_property_info_persistent_groups,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _wpa_interface_p2_pdevice_interface_info =
{
  {
    -1,
    (gchar *) "fi.w1.wpa_supplicant1.Interface.P2PDevice",
    (GDBusMethodInfo **) &_wpa_interface_p2_pdevice_method_info_pointers,
    (GDBusSignalInfo **) &_wpa_interface_p2_pdevice_signal_info_pointers,
    (GDBusPropertyInfo **) &_wpa_interface_p2_pdevice_property_info_pointers,
    NULL
  },
  "p2-pdevice",
};


/**
 * wpa_interface_p2_pdevice_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-P2PDevice.top_of_page">fi.w1.wpa_supplicant1.Interface.P2PDevice</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
wpa_interface_p2_pdevice_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_wpa_interface_p2_pdevice_interface_info.parent_struct;
}

/**
 * wpa_interface_p2_pdevice_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #wpainterfaceP2PDevice interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
wpa_interface_p2_pdevice_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "p2-pdevice-config");
  g_object_class_override_property (klass, property_id_begin++, "peers");
  g_object_class_override_property (klass, property_id_begin++, "role");
  g_object_class_override_property (klass, property_id_begin++, "group");
  g_object_class_override_property (klass, property_id_begin++, "peer-go");
  g_object_class_override_property (klass, property_id_begin++, "persistent-groups");
  return property_id_begin - 1;
}



/**
 * wpainterfaceP2PDevice:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-P2PDevice.top_of_page">fi.w1.wpa_supplicant1.Interface.P2PDevice</link>.
 */

/**
 * wpainterfaceP2PDeviceIface:
 * @parent_iface: The parent interface.
 * @handle_add_persistent_group: Handler for the #wpainterfaceP2PDevice::handle-add-persistent-group signal.
 * @handle_add_service: Handler for the #wpainterfaceP2PDevice::handle-add-service signal.
 * @handle_cancel: Handler for the #wpainterfaceP2PDevice::handle-cancel signal.
 * @handle_connect: Handler for the #wpainterfaceP2PDevice::handle-connect signal.
 * @handle_delete_service: Handler for the #wpainterfaceP2PDevice::handle-delete-service signal.
 * @handle_disconnect: Handler for the #wpainterfaceP2PDevice::handle-disconnect signal.
 * @handle_extended_listen: Handler for the #wpainterfaceP2PDevice::handle-extended-listen signal.
 * @handle_find: Handler for the #wpainterfaceP2PDevice::handle-find signal.
 * @handle_flush: Handler for the #wpainterfaceP2PDevice::handle-flush signal.
 * @handle_flush_service: Handler for the #wpainterfaceP2PDevice::handle-flush-service signal.
 * @handle_group_add: Handler for the #wpainterfaceP2PDevice::handle-group-add signal.
 * @handle_invite: Handler for the #wpainterfaceP2PDevice::handle-invite signal.
 * @handle_listen: Handler for the #wpainterfaceP2PDevice::handle-listen signal.
 * @handle_presence_request: Handler for the #wpainterfaceP2PDevice::handle-presence-request signal.
 * @handle_provision_discovery_request: Handler for the #wpainterfaceP2PDevice::handle-provision-discovery-request signal.
 * @handle_reject_peer: Handler for the #wpainterfaceP2PDevice::handle-reject-peer signal.
 * @handle_remove_all_persistent_groups: Handler for the #wpainterfaceP2PDevice::handle-remove-all-persistent-groups signal.
 * @handle_remove_client: Handler for the #wpainterfaceP2PDevice::handle-remove-client signal.
 * @handle_remove_persistent_group: Handler for the #wpainterfaceP2PDevice::handle-remove-persistent-group signal.
 * @handle_service_discovery_cancel_request: Handler for the #wpainterfaceP2PDevice::handle-service-discovery-cancel-request signal.
 * @handle_service_discovery_external: Handler for the #wpainterfaceP2PDevice::handle-service-discovery-external signal.
 * @handle_service_discovery_request: Handler for the #wpainterfaceP2PDevice::handle-service-discovery-request signal.
 * @handle_service_discovery_response: Handler for the #wpainterfaceP2PDevice::handle-service-discovery-response signal.
 * @handle_service_update: Handler for the #wpainterfaceP2PDevice::handle-service-update signal.
 * @handle_stop_find: Handler for the #wpainterfaceP2PDevice::handle-stop-find signal.
 * @get_group: Getter for the #wpainterfaceP2PDevice:group property.
 * @get_p2_pdevice_config: Getter for the #wpainterfaceP2PDevice:p2-pdevice-config property.
 * @get_peer_go: Getter for the #wpainterfaceP2PDevice:peer-go property.
 * @get_peers: Getter for the #wpainterfaceP2PDevice:peers property.
 * @get_persistent_groups: Getter for the #wpainterfaceP2PDevice:persistent-groups property.
 * @get_role: Getter for the #wpainterfaceP2PDevice:role property.
 * @device_found: Handler for the #wpainterfaceP2PDevice::device-found signal.
 * @device_found_properties: Handler for the #wpainterfaceP2PDevice::device-found-properties signal.
 * @device_lost: Handler for the #wpainterfaceP2PDevice::device-lost signal.
 * @find_stopped: Handler for the #wpainterfaceP2PDevice::find-stopped signal.
 * @gonegotiation_failure: Handler for the #wpainterfaceP2PDevice::gonegotiation-failure signal.
 * @gonegotiation_request: Handler for the #wpainterfaceP2PDevice::gonegotiation-request signal.
 * @gonegotiation_success: Handler for the #wpainterfaceP2PDevice::gonegotiation-success signal.
 * @group_finished: Handler for the #wpainterfaceP2PDevice::group-finished signal.
 * @group_formation_failure: Handler for the #wpainterfaceP2PDevice::group-formation-failure signal.
 * @group_started: Handler for the #wpainterfaceP2PDevice::group-started signal.
 * @invitation_received: Handler for the #wpainterfaceP2PDevice::invitation-received signal.
 * @invitation_result: Handler for the #wpainterfaceP2PDevice::invitation-result signal.
 * @persistent_group_added: Handler for the #wpainterfaceP2PDevice::persistent-group-added signal.
 * @persistent_group_removed: Handler for the #wpainterfaceP2PDevice::persistent-group-removed signal.
 * @provision_discovery_failure: Handler for the #wpainterfaceP2PDevice::provision-discovery-failure signal.
 * @provision_discovery_pbcrequest: Handler for the #wpainterfaceP2PDevice::provision-discovery-pbcrequest signal.
 * @provision_discovery_pbcresponse: Handler for the #wpainterfaceP2PDevice::provision-discovery-pbcresponse signal.
 * @provision_discovery_request_display_pin: Handler for the #wpainterfaceP2PDevice::provision-discovery-request-display-pin signal.
 * @provision_discovery_request_enter_pin: Handler for the #wpainterfaceP2PDevice::provision-discovery-request-enter-pin signal.
 * @provision_discovery_response_display_pin: Handler for the #wpainterfaceP2PDevice::provision-discovery-response-display-pin signal.
 * @provision_discovery_response_enter_pin: Handler for the #wpainterfaceP2PDevice::provision-discovery-response-enter-pin signal.
 * @service_discovery_request: Handler for the #wpainterfaceP2PDevice::service-discovery-request signal.
 * @service_discovery_response: Handler for the #wpainterfaceP2PDevice::service-discovery-response signal.
 * @wps_failed: Handler for the #wpainterfaceP2PDevice::wps-failed signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-P2PDevice.top_of_page">fi.w1.wpa_supplicant1.Interface.P2PDevice</link>.
 */

typedef wpainterfaceP2PDeviceIface wpainterfaceP2PDeviceInterface;
G_DEFINE_INTERFACE (wpainterfaceP2PDevice, wpa_interface_p2_pdevice, G_TYPE_OBJECT);

static void
wpa_interface_p2_pdevice_default_init (wpainterfaceP2PDeviceIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * wpainterfaceP2PDevice::handle-find:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Find">Find()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_find() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-find",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_find),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::handle-stop-find:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.StopFind">StopFind()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_stop_find() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-stop-find",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_stop_find),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceP2PDevice::handle-listen:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_timeout: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Listen">Listen()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_listen() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-listen",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_listen),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);

  /**
   * wpainterfaceP2PDevice::handle-extended-listen:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ExtendedListen">ExtendedListen()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_extended_listen() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-extended-listen",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_extended_listen),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::handle-presence-request:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.PresenceRequest">PresenceRequest()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_presence_request() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-presence-request",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_presence_request),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::handle-provision-discovery-request:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_peer: Argument passed by remote caller.
   * @arg_config_method: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryRequest">ProvisionDiscoveryRequest()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_provision_discovery_request() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-provision-discovery-request",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_provision_discovery_request),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * wpainterfaceP2PDevice::handle-connect:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Connect">Connect()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_connect() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-connect",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_connect),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::handle-group-add:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.GroupAdd">GroupAdd()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_group_add() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-group-add",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_group_add),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::handle-cancel:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Cancel">Cancel()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_cancel() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-cancel",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_cancel),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceP2PDevice::handle-invite:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Invite">Invite()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_invite() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-invite",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_invite),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::handle-disconnect:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Disconnect">Disconnect()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_disconnect() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-disconnect",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_disconnect),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceP2PDevice::handle-reject-peer:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_peer: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RejectPeer">RejectPeer()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_reject_peer() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-reject-peer",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_reject_peer),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * wpainterfaceP2PDevice::handle-remove-client:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RemoveClient">RemoveClient()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_remove_client() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-remove-client",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_remove_client),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::handle-flush:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Flush">Flush()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_flush() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-flush",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_flush),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceP2PDevice::handle-add-service:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.AddService">AddService()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_add_service() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-add-service",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_add_service),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::handle-delete-service:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.DeleteService">DeleteService()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_delete_service() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-delete-service",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_delete_service),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::handle-flush-service:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.FlushService">FlushService()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_flush_service() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-flush-service",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_flush_service),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceP2PDevice::handle-service-discovery-request:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryRequest">ServiceDiscoveryRequest()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_service_discovery_request() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-service-discovery-request",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_service_discovery_request),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::handle-service-discovery-response:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryResponse">ServiceDiscoveryResponse()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_service_discovery_response() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-service-discovery-response",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_service_discovery_response),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::handle-service-discovery-cancel-request:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryCancelRequest">ServiceDiscoveryCancelRequest()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_service_discovery_cancel_request() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-service-discovery-cancel-request",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_service_discovery_cancel_request),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UINT64);

  /**
   * wpainterfaceP2PDevice::handle-service-update:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceUpdate">ServiceUpdate()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_service_update() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-service-update",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_service_update),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * wpainterfaceP2PDevice::handle-service-discovery-external:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_arg: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryExternal">ServiceDiscoveryExternal()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_service_discovery_external() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-service-discovery-external",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_service_discovery_external),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);

  /**
   * wpainterfaceP2PDevice::handle-add-persistent-group:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_args: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.AddPersistentGroup">AddPersistentGroup()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_add_persistent_group() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-add-persistent-group",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_add_persistent_group),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::handle-remove-persistent-group:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   * @arg_path: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RemovePersistentGroup">RemovePersistentGroup()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_remove_persistent_group() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-remove-persistent-group",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_remove_persistent_group),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * wpainterfaceP2PDevice::handle-remove-all-persistent-groups:
   * @object: A #wpainterfaceP2PDevice.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RemoveAllPersistentGroups">RemoveAllPersistentGroups()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call wpa_interface_p2_pdevice_complete_remove_all_persistent_groups() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-remove-all-persistent-groups",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, handle_remove_all_persistent_groups),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * wpainterfaceP2PDevice::device-found:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_path: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.DeviceFound">"DeviceFound"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("device-found",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, device_found),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceP2PDevice::device-found-properties:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_path: Argument.
   * @arg_properties: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.DeviceFoundProperties">"DeviceFoundProperties"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("device-found-properties",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, device_found_properties),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::device-lost:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_path: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.DeviceLost">"DeviceLost"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("device-lost",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, device_lost),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceP2PDevice::find-stopped:
   * @object: A #wpainterfaceP2PDevice.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.FindStopped">"FindStopped"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("find-stopped",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, find_stopped),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * wpainterfaceP2PDevice::provision-discovery-request-display-pin:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_peer_object: Argument.
   * @arg_pin: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryRequestDisplayPin">"ProvisionDiscoveryRequestDisplayPin"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("provision-discovery-request-display-pin",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, provision_discovery_request_display_pin),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * wpainterfaceP2PDevice::provision-discovery-response-display-pin:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_peer_object: Argument.
   * @arg_pin: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryResponseDisplayPin">"ProvisionDiscoveryResponseDisplayPin"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("provision-discovery-response-display-pin",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, provision_discovery_response_display_pin),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * wpainterfaceP2PDevice::provision-discovery-request-enter-pin:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_peer_object: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryRequestEnterPin">"ProvisionDiscoveryRequestEnterPin"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("provision-discovery-request-enter-pin",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, provision_discovery_request_enter_pin),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceP2PDevice::provision-discovery-response-enter-pin:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_peer_object: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryResponseEnterPin">"ProvisionDiscoveryResponseEnterPin"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("provision-discovery-response-enter-pin",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, provision_discovery_response_enter_pin),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceP2PDevice::provision-discovery-pbcrequest:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_peer_object: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryPBCRequest">"ProvisionDiscoveryPBCRequest"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("provision-discovery-pbcrequest",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, provision_discovery_pbcrequest),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceP2PDevice::provision-discovery-pbcresponse:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_peer_object: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryPBCResponse">"ProvisionDiscoveryPBCResponse"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("provision-discovery-pbcresponse",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, provision_discovery_pbcresponse),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceP2PDevice::provision-discovery-failure:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_peer_object: Argument.
   * @arg_status: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryFailure">"ProvisionDiscoveryFailure"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("provision-discovery-failure",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, provision_discovery_failure),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_INT);

  /**
   * wpainterfaceP2PDevice::group-started:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_properties: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.GroupStarted">"GroupStarted"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("group-started",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, group_started),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::group-formation-failure:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_reason: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.GroupFormationFailure">"GroupFormationFailure"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("group-formation-failure",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, group_formation_failure),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceP2PDevice::gonegotiation-success:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_properties: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.GONegotiationSuccess">"GONegotiationSuccess"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("gonegotiation-success",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, gonegotiation_success),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::gonegotiation-failure:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_properties: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.GONegotiationFailure">"GONegotiationFailure"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("gonegotiation-failure",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, gonegotiation_failure),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::gonegotiation-request:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_path: Argument.
   * @arg_dev_passwd_id: Argument.
   * @arg_device_go_intent: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.GONegotiationRequest">"GONegotiationRequest"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("gonegotiation-request",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, gonegotiation_request),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    3, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_UCHAR);

  /**
   * wpainterfaceP2PDevice::invitation-result:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_invite_result: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.InvitationResult">"InvitationResult"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("invitation-result",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, invitation_result),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::group-finished:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_properties: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.GroupFinished">"GroupFinished"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("group-finished",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, group_finished),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::service-discovery-request:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_sd_request: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryRequest">"ServiceDiscoveryRequest"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("service-discovery-request",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, service_discovery_request),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::service-discovery-response:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_sd_response: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryResponse">"ServiceDiscoveryResponse"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("service-discovery-response",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, service_discovery_response),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::persistent-group-added:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_path: Argument.
   * @arg_properties: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.PersistentGroupAdded">"PersistentGroupAdded"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("persistent-group-added",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, persistent_group_added),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::persistent-group-removed:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_path: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.PersistentGroupRemoved">"PersistentGroupRemoved"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("persistent-group-removed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, persistent_group_removed),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /**
   * wpainterfaceP2PDevice::wps-failed:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_name: Argument.
   * @arg_args: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.WpsFailed">"WpsFailed"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("wps-failed",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, wps_failed),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_VARIANT);

  /**
   * wpainterfaceP2PDevice::invitation-received:
   * @object: A #wpainterfaceP2PDevice.
   * @arg_properties: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.InvitationReceived">"InvitationReceived"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("invitation-received",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (wpainterfaceP2PDeviceIface, invitation_received),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_VARIANT);

  /* GObject properties for D-Bus properties: */
  /**
   * wpainterfaceP2PDevice:p2-pdevice-config:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.P2PDeviceConfig">"P2PDeviceConfig"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("p2-pdevice-config", "P2PDeviceConfig", "P2PDeviceConfig", G_VARIANT_TYPE ("a{sv}"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceP2PDevice:peers:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.Peers">"Peers"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("peers", "Peers", "Peers", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceP2PDevice:role:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.Role">"Role"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("role", "Role", "Role", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceP2PDevice:group:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.Group">"Group"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("group", "Group", "Group", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceP2PDevice:peer-go:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.PeerGO">"PeerGO"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("peer-go", "PeerGO", "PeerGO", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * wpainterfaceP2PDevice:persistent-groups:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.PersistentGroups">"PersistentGroups"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("persistent-groups", "PersistentGroups", "PersistentGroups", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

/**
 * wpa_interface_p2_pdevice_get_p2_pdevice_config: (skip)
 * @object: A #wpainterfaceP2PDevice.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.P2PDeviceConfig">"P2PDeviceConfig"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_p2_pdevice_dup_p2_pdevice_config() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
GVariant *
wpa_interface_p2_pdevice_get_p2_pdevice_config (wpainterfaceP2PDevice *object)
{
  return WPA_INTERFACE_P2_PDEVICE_GET_IFACE (object)->get_p2_pdevice_config (object);
}

/**
 * wpa_interface_p2_pdevice_dup_p2_pdevice_config: (skip)
 * @object: A #wpainterfaceP2PDevice.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.P2PDeviceConfig">"P2PDeviceConfig"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_variant_unref().
 */
GVariant *
wpa_interface_p2_pdevice_dup_p2_pdevice_config (wpainterfaceP2PDevice *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "p2-pdevice-config", &value, NULL);
  return value;
}

/**
 * wpa_interface_p2_pdevice_set_p2_pdevice_config: (skip)
 * @object: A #wpainterfaceP2PDevice.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.P2PDeviceConfig">"P2PDeviceConfig"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
wpa_interface_p2_pdevice_set_p2_pdevice_config (wpainterfaceP2PDevice *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "p2-pdevice-config", value, NULL);
}

/**
 * wpa_interface_p2_pdevice_get_peers: (skip)
 * @object: A #wpainterfaceP2PDevice.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.Peers">"Peers"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_p2_pdevice_dup_peers() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
wpa_interface_p2_pdevice_get_peers (wpainterfaceP2PDevice *object)
{
  return WPA_INTERFACE_P2_PDEVICE_GET_IFACE (object)->get_peers (object);
}

/**
 * wpa_interface_p2_pdevice_dup_peers: (skip)
 * @object: A #wpainterfaceP2PDevice.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.Peers">"Peers"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
wpa_interface_p2_pdevice_dup_peers (wpainterfaceP2PDevice *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "peers", &value, NULL);
  return value;
}

/**
 * wpa_interface_p2_pdevice_set_peers: (skip)
 * @object: A #wpainterfaceP2PDevice.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.Peers">"Peers"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_p2_pdevice_set_peers (wpainterfaceP2PDevice *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "peers", value, NULL);
}

/**
 * wpa_interface_p2_pdevice_get_role: (skip)
 * @object: A #wpainterfaceP2PDevice.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.Role">"Role"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_p2_pdevice_dup_role() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_p2_pdevice_get_role (wpainterfaceP2PDevice *object)
{
  return WPA_INTERFACE_P2_PDEVICE_GET_IFACE (object)->get_role (object);
}

/**
 * wpa_interface_p2_pdevice_dup_role: (skip)
 * @object: A #wpainterfaceP2PDevice.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.Role">"Role"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_p2_pdevice_dup_role (wpainterfaceP2PDevice *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "role", &value, NULL);
  return value;
}

/**
 * wpa_interface_p2_pdevice_set_role: (skip)
 * @object: A #wpainterfaceP2PDevice.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.Role">"Role"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_p2_pdevice_set_role (wpainterfaceP2PDevice *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "role", value, NULL);
}

/**
 * wpa_interface_p2_pdevice_get_group: (skip)
 * @object: A #wpainterfaceP2PDevice.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.Group">"Group"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_p2_pdevice_dup_group() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_p2_pdevice_get_group (wpainterfaceP2PDevice *object)
{
  return WPA_INTERFACE_P2_PDEVICE_GET_IFACE (object)->get_group (object);
}

/**
 * wpa_interface_p2_pdevice_dup_group: (skip)
 * @object: A #wpainterfaceP2PDevice.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.Group">"Group"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_p2_pdevice_dup_group (wpainterfaceP2PDevice *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "group", &value, NULL);
  return value;
}

/**
 * wpa_interface_p2_pdevice_set_group: (skip)
 * @object: A #wpainterfaceP2PDevice.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.Group">"Group"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_p2_pdevice_set_group (wpainterfaceP2PDevice *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "group", value, NULL);
}

/**
 * wpa_interface_p2_pdevice_get_peer_go: (skip)
 * @object: A #wpainterfaceP2PDevice.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.PeerGO">"PeerGO"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_p2_pdevice_dup_peer_go() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *
wpa_interface_p2_pdevice_get_peer_go (wpainterfaceP2PDevice *object)
{
  return WPA_INTERFACE_P2_PDEVICE_GET_IFACE (object)->get_peer_go (object);
}

/**
 * wpa_interface_p2_pdevice_dup_peer_go: (skip)
 * @object: A #wpainterfaceP2PDevice.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.PeerGO">"PeerGO"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_free().
 */
gchar *
wpa_interface_p2_pdevice_dup_peer_go (wpainterfaceP2PDevice *object)
{
  gchar *value;
  g_object_get (G_OBJECT (object), "peer-go", &value, NULL);
  return value;
}

/**
 * wpa_interface_p2_pdevice_set_peer_go: (skip)
 * @object: A #wpainterfaceP2PDevice.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.PeerGO">"PeerGO"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_p2_pdevice_set_peer_go (wpainterfaceP2PDevice *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "peer-go", value, NULL);
}

/**
 * wpa_interface_p2_pdevice_get_persistent_groups: (skip)
 * @object: A #wpainterfaceP2PDevice.
 *
 * Gets the value of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.PersistentGroups">"PersistentGroups"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * <warning>The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use wpa_interface_p2_pdevice_dup_persistent_groups() if on another thread.</warning>
 *
 * Returns: (transfer none): The property value or %NULL if the property is not set. Do not free the returned value, it belongs to @object.
 */
const gchar *const *
wpa_interface_p2_pdevice_get_persistent_groups (wpainterfaceP2PDevice *object)
{
  return WPA_INTERFACE_P2_PDEVICE_GET_IFACE (object)->get_persistent_groups (object);
}

/**
 * wpa_interface_p2_pdevice_dup_persistent_groups: (skip)
 * @object: A #wpainterfaceP2PDevice.
 *
 * Gets a copy of the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.PersistentGroups">"PersistentGroups"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer full): The property value or %NULL if the property is not set. The returned value should be freed with g_strfreev().
 */
gchar **
wpa_interface_p2_pdevice_dup_persistent_groups (wpainterfaceP2PDevice *object)
{
  gchar **value;
  g_object_get (G_OBJECT (object), "persistent-groups", &value, NULL);
  return value;
}

/**
 * wpa_interface_p2_pdevice_set_persistent_groups: (skip)
 * @object: A #wpainterfaceP2PDevice.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-fi-w1-wpa_supplicant1-Interface-P2PDevice.PersistentGroups">"PersistentGroups"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
wpa_interface_p2_pdevice_set_persistent_groups (wpainterfaceP2PDevice *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "persistent-groups", value, NULL);
}

/**
 * wpa_interface_p2_pdevice_emit_device_found:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_path: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.DeviceFound">"DeviceFound"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_device_found (
    wpainterfaceP2PDevice *object,
    const gchar *arg_path)
{
  g_signal_emit_by_name (object, "device-found", arg_path);
}

/**
 * wpa_interface_p2_pdevice_emit_device_found_properties:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_path: Argument to pass with the signal.
 * @arg_properties: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.DeviceFoundProperties">"DeviceFoundProperties"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_device_found_properties (
    wpainterfaceP2PDevice *object,
    const gchar *arg_path,
    GVariant *arg_properties)
{
  g_signal_emit_by_name (object, "device-found-properties", arg_path, arg_properties);
}

/**
 * wpa_interface_p2_pdevice_emit_device_lost:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_path: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.DeviceLost">"DeviceLost"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_device_lost (
    wpainterfaceP2PDevice *object,
    const gchar *arg_path)
{
  g_signal_emit_by_name (object, "device-lost", arg_path);
}

/**
 * wpa_interface_p2_pdevice_emit_find_stopped:
 * @object: A #wpainterfaceP2PDevice.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.FindStopped">"FindStopped"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_find_stopped (
    wpainterfaceP2PDevice *object)
{
  g_signal_emit_by_name (object, "find-stopped");
}

/**
 * wpa_interface_p2_pdevice_emit_provision_discovery_request_display_pin:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_peer_object: Argument to pass with the signal.
 * @arg_pin: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryRequestDisplayPin">"ProvisionDiscoveryRequestDisplayPin"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_provision_discovery_request_display_pin (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object,
    const gchar *arg_pin)
{
  g_signal_emit_by_name (object, "provision-discovery-request-display-pin", arg_peer_object, arg_pin);
}

/**
 * wpa_interface_p2_pdevice_emit_provision_discovery_response_display_pin:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_peer_object: Argument to pass with the signal.
 * @arg_pin: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryResponseDisplayPin">"ProvisionDiscoveryResponseDisplayPin"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_provision_discovery_response_display_pin (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object,
    const gchar *arg_pin)
{
  g_signal_emit_by_name (object, "provision-discovery-response-display-pin", arg_peer_object, arg_pin);
}

/**
 * wpa_interface_p2_pdevice_emit_provision_discovery_request_enter_pin:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_peer_object: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryRequestEnterPin">"ProvisionDiscoveryRequestEnterPin"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_provision_discovery_request_enter_pin (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object)
{
  g_signal_emit_by_name (object, "provision-discovery-request-enter-pin", arg_peer_object);
}

/**
 * wpa_interface_p2_pdevice_emit_provision_discovery_response_enter_pin:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_peer_object: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryResponseEnterPin">"ProvisionDiscoveryResponseEnterPin"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_provision_discovery_response_enter_pin (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object)
{
  g_signal_emit_by_name (object, "provision-discovery-response-enter-pin", arg_peer_object);
}

/**
 * wpa_interface_p2_pdevice_emit_provision_discovery_pbcrequest:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_peer_object: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryPBCRequest">"ProvisionDiscoveryPBCRequest"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_provision_discovery_pbcrequest (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object)
{
  g_signal_emit_by_name (object, "provision-discovery-pbcrequest", arg_peer_object);
}

/**
 * wpa_interface_p2_pdevice_emit_provision_discovery_pbcresponse:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_peer_object: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryPBCResponse">"ProvisionDiscoveryPBCResponse"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_provision_discovery_pbcresponse (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object)
{
  g_signal_emit_by_name (object, "provision-discovery-pbcresponse", arg_peer_object);
}

/**
 * wpa_interface_p2_pdevice_emit_provision_discovery_failure:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_peer_object: Argument to pass with the signal.
 * @arg_status: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryFailure">"ProvisionDiscoveryFailure"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_provision_discovery_failure (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object,
    gint arg_status)
{
  g_signal_emit_by_name (object, "provision-discovery-failure", arg_peer_object, arg_status);
}

/**
 * wpa_interface_p2_pdevice_emit_group_started:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_properties: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.GroupStarted">"GroupStarted"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_group_started (
    wpainterfaceP2PDevice *object,
    GVariant *arg_properties)
{
  g_signal_emit_by_name (object, "group-started", arg_properties);
}

/**
 * wpa_interface_p2_pdevice_emit_group_formation_failure:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_reason: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.GroupFormationFailure">"GroupFormationFailure"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_group_formation_failure (
    wpainterfaceP2PDevice *object,
    const gchar *arg_reason)
{
  g_signal_emit_by_name (object, "group-formation-failure", arg_reason);
}

/**
 * wpa_interface_p2_pdevice_emit_gonegotiation_success:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_properties: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.GONegotiationSuccess">"GONegotiationSuccess"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_gonegotiation_success (
    wpainterfaceP2PDevice *object,
    GVariant *arg_properties)
{
  g_signal_emit_by_name (object, "gonegotiation-success", arg_properties);
}

/**
 * wpa_interface_p2_pdevice_emit_gonegotiation_failure:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_properties: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.GONegotiationFailure">"GONegotiationFailure"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_gonegotiation_failure (
    wpainterfaceP2PDevice *object,
    GVariant *arg_properties)
{
  g_signal_emit_by_name (object, "gonegotiation-failure", arg_properties);
}

/**
 * wpa_interface_p2_pdevice_emit_gonegotiation_request:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_path: Argument to pass with the signal.
 * @arg_dev_passwd_id: Argument to pass with the signal.
 * @arg_device_go_intent: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.GONegotiationRequest">"GONegotiationRequest"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_gonegotiation_request (
    wpainterfaceP2PDevice *object,
    const gchar *arg_path,
    guint16 arg_dev_passwd_id,
    guchar arg_device_go_intent)
{
  g_signal_emit_by_name (object, "gonegotiation-request", arg_path, arg_dev_passwd_id, arg_device_go_intent);
}

/**
 * wpa_interface_p2_pdevice_emit_invitation_result:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_invite_result: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.InvitationResult">"InvitationResult"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_invitation_result (
    wpainterfaceP2PDevice *object,
    GVariant *arg_invite_result)
{
  g_signal_emit_by_name (object, "invitation-result", arg_invite_result);
}

/**
 * wpa_interface_p2_pdevice_emit_group_finished:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_properties: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.GroupFinished">"GroupFinished"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_group_finished (
    wpainterfaceP2PDevice *object,
    GVariant *arg_properties)
{
  g_signal_emit_by_name (object, "group-finished", arg_properties);
}

/**
 * wpa_interface_p2_pdevice_emit_service_discovery_request:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_sd_request: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryRequest">"ServiceDiscoveryRequest"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_service_discovery_request (
    wpainterfaceP2PDevice *object,
    GVariant *arg_sd_request)
{
  g_signal_emit_by_name (object, "service-discovery-request", arg_sd_request);
}

/**
 * wpa_interface_p2_pdevice_emit_service_discovery_response:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_sd_response: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryResponse">"ServiceDiscoveryResponse"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_service_discovery_response (
    wpainterfaceP2PDevice *object,
    GVariant *arg_sd_response)
{
  g_signal_emit_by_name (object, "service-discovery-response", arg_sd_response);
}

/**
 * wpa_interface_p2_pdevice_emit_persistent_group_added:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_path: Argument to pass with the signal.
 * @arg_properties: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.PersistentGroupAdded">"PersistentGroupAdded"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_persistent_group_added (
    wpainterfaceP2PDevice *object,
    const gchar *arg_path,
    GVariant *arg_properties)
{
  g_signal_emit_by_name (object, "persistent-group-added", arg_path, arg_properties);
}

/**
 * wpa_interface_p2_pdevice_emit_persistent_group_removed:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_path: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.PersistentGroupRemoved">"PersistentGroupRemoved"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_persistent_group_removed (
    wpainterfaceP2PDevice *object,
    const gchar *arg_path)
{
  g_signal_emit_by_name (object, "persistent-group-removed", arg_path);
}

/**
 * wpa_interface_p2_pdevice_emit_wps_failed:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_name: Argument to pass with the signal.
 * @arg_args: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.WpsFailed">"WpsFailed"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_wps_failed (
    wpainterfaceP2PDevice *object,
    const gchar *arg_name,
    GVariant *arg_args)
{
  g_signal_emit_by_name (object, "wps-failed", arg_name, arg_args);
}

/**
 * wpa_interface_p2_pdevice_emit_invitation_received:
 * @object: A #wpainterfaceP2PDevice.
 * @arg_properties: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-fi-w1-wpa_supplicant1-Interface-P2PDevice.InvitationReceived">"InvitationReceived"</link> D-Bus signal.
 */
void
wpa_interface_p2_pdevice_emit_invitation_received (
    wpainterfaceP2PDevice *object,
    GVariant *arg_properties)
{
  g_signal_emit_by_name (object, "invitation-received", arg_properties);
}

/**
 * wpa_interface_p2_pdevice_call_find:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Find">Find()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_find_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_find_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_find (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Find",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_find_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_find().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_find().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_find_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_find_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Find">Find()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_find() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_find_sync (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Find",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_stop_find:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.StopFind">StopFind()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_stop_find_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_stop_find_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_stop_find (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "StopFind",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_stop_find_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_stop_find().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_stop_find().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_stop_find_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_stop_find_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.StopFind">StopFind()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_stop_find() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_stop_find_sync (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "StopFind",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_listen:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_timeout: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Listen">Listen()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_listen_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_listen_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_listen (
    wpainterfaceP2PDevice *proxy,
    gint arg_timeout,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Listen",
    g_variant_new ("(i)",
                   arg_timeout),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_listen_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_listen().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_listen().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_listen_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_listen_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_timeout: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Listen">Listen()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_listen() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_listen_sync (
    wpainterfaceP2PDevice *proxy,
    gint arg_timeout,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Listen",
    g_variant_new ("(i)",
                   arg_timeout),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_extended_listen:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ExtendedListen">ExtendedListen()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_extended_listen_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_extended_listen_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_extended_listen (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "ExtendedListen",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_extended_listen_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_extended_listen().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_extended_listen().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_extended_listen_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_extended_listen_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ExtendedListen">ExtendedListen()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_extended_listen() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_extended_listen_sync (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "ExtendedListen",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_presence_request:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.PresenceRequest">PresenceRequest()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_presence_request_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_presence_request_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_presence_request (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "PresenceRequest",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_presence_request_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_presence_request().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_presence_request().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_presence_request_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_presence_request_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.PresenceRequest">PresenceRequest()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_presence_request() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_presence_request_sync (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "PresenceRequest",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_provision_discovery_request:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_peer: Argument to pass with the method invocation.
 * @arg_config_method: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryRequest">ProvisionDiscoveryRequest()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_provision_discovery_request_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_provision_discovery_request_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_provision_discovery_request (
    wpainterfaceP2PDevice *proxy,
    const gchar *arg_peer,
    const gchar *arg_config_method,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "ProvisionDiscoveryRequest",
    g_variant_new ("(os)",
                   arg_peer,
                   arg_config_method),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_provision_discovery_request_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_provision_discovery_request().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_provision_discovery_request().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_provision_discovery_request_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_provision_discovery_request_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_peer: Argument to pass with the method invocation.
 * @arg_config_method: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryRequest">ProvisionDiscoveryRequest()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_provision_discovery_request() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_provision_discovery_request_sync (
    wpainterfaceP2PDevice *proxy,
    const gchar *arg_peer,
    const gchar *arg_config_method,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "ProvisionDiscoveryRequest",
    g_variant_new ("(os)",
                   arg_peer,
                   arg_config_method),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_connect:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Connect">Connect()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_connect_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_connect_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_connect (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Connect",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_connect_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @out_generated_pin: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_connect().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_connect().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_connect_finish (
    wpainterfaceP2PDevice *proxy,
    gchar **out_generated_pin,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_generated_pin);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_connect_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @out_generated_pin: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Connect">Connect()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_connect() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_connect_sync (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    gchar **out_generated_pin,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Connect",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_generated_pin);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_group_add:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.GroupAdd">GroupAdd()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_group_add_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_group_add_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_group_add (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GroupAdd",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_group_add_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_group_add().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_group_add().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_group_add_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_group_add_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.GroupAdd">GroupAdd()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_group_add() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_group_add_sync (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GroupAdd",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_cancel:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Cancel">Cancel()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_cancel_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_cancel_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_cancel (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Cancel",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_cancel_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_cancel().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_cancel().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_cancel_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_cancel_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Cancel">Cancel()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_cancel() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_cancel_sync (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Cancel",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_invite:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Invite">Invite()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_invite_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_invite_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_invite (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Invite",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_invite_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_invite().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_invite().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_invite_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_invite_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Invite">Invite()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_invite() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_invite_sync (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Invite",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_disconnect:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Disconnect">Disconnect()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_disconnect_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_disconnect_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_disconnect (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Disconnect",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_disconnect_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_disconnect().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_disconnect().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_disconnect_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_disconnect_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Disconnect">Disconnect()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_disconnect() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_disconnect_sync (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Disconnect",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_reject_peer:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_peer: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RejectPeer">RejectPeer()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_reject_peer_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_reject_peer_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_reject_peer (
    wpainterfaceP2PDevice *proxy,
    const gchar *arg_peer,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RejectPeer",
    g_variant_new ("(o)",
                   arg_peer),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_reject_peer_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_reject_peer().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_reject_peer().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_reject_peer_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_reject_peer_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_peer: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RejectPeer">RejectPeer()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_reject_peer() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_reject_peer_sync (
    wpainterfaceP2PDevice *proxy,
    const gchar *arg_peer,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RejectPeer",
    g_variant_new ("(o)",
                   arg_peer),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_remove_client:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RemoveClient">RemoveClient()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_remove_client_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_remove_client_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_remove_client (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RemoveClient",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_remove_client_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_remove_client().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_remove_client().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_remove_client_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_remove_client_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RemoveClient">RemoveClient()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_remove_client() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_remove_client_sync (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RemoveClient",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_flush:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Flush">Flush()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_flush_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_flush_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_flush (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Flush",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_flush_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_flush().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_flush().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_flush_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_flush_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Flush">Flush()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_flush() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_flush_sync (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Flush",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_add_service:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.AddService">AddService()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_add_service_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_add_service_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_add_service (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "AddService",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_add_service_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_add_service().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_add_service().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_add_service_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_add_service_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.AddService">AddService()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_add_service() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_add_service_sync (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "AddService",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_delete_service:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.DeleteService">DeleteService()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_delete_service_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_delete_service_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_delete_service (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "DeleteService",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_delete_service_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_delete_service().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_delete_service().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_delete_service_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_delete_service_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.DeleteService">DeleteService()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_delete_service() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_delete_service_sync (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "DeleteService",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_flush_service:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.FlushService">FlushService()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_flush_service_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_flush_service_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_flush_service (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "FlushService",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_flush_service_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_flush_service().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_flush_service().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_flush_service_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_flush_service_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.FlushService">FlushService()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_flush_service() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_flush_service_sync (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "FlushService",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_service_discovery_request:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryRequest">ServiceDiscoveryRequest()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_service_discovery_request_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_service_discovery_request_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_service_discovery_request (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "ServiceDiscoveryRequest",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_service_discovery_request_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @out_ref: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_service_discovery_request().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_service_discovery_request().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_service_discovery_request_finish (
    wpainterfaceP2PDevice *proxy,
    guint64 *out_ref,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(t)",
                 out_ref);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_service_discovery_request_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @out_ref: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryRequest">ServiceDiscoveryRequest()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_service_discovery_request() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_service_discovery_request_sync (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    guint64 *out_ref,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "ServiceDiscoveryRequest",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(t)",
                 out_ref);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_service_discovery_response:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryResponse">ServiceDiscoveryResponse()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_service_discovery_response_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_service_discovery_response_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_service_discovery_response (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "ServiceDiscoveryResponse",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_service_discovery_response_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_service_discovery_response().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_service_discovery_response().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_service_discovery_response_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_service_discovery_response_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryResponse">ServiceDiscoveryResponse()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_service_discovery_response() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_service_discovery_response_sync (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "ServiceDiscoveryResponse",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_service_discovery_cancel_request:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryCancelRequest">ServiceDiscoveryCancelRequest()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_service_discovery_cancel_request_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_service_discovery_cancel_request_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_service_discovery_cancel_request (
    wpainterfaceP2PDevice *proxy,
    guint64 arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "ServiceDiscoveryCancelRequest",
    g_variant_new ("(t)",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_service_discovery_cancel_request_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_service_discovery_cancel_request().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_service_discovery_cancel_request().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_service_discovery_cancel_request_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_service_discovery_cancel_request_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryCancelRequest">ServiceDiscoveryCancelRequest()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_service_discovery_cancel_request() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_service_discovery_cancel_request_sync (
    wpainterfaceP2PDevice *proxy,
    guint64 arg_args,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "ServiceDiscoveryCancelRequest",
    g_variant_new ("(t)",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_service_update:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceUpdate">ServiceUpdate()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_service_update_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_service_update_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_service_update (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "ServiceUpdate",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_service_update_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_service_update().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_service_update().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_service_update_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_service_update_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceUpdate">ServiceUpdate()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_service_update() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_service_update_sync (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "ServiceUpdate",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_service_discovery_external:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_arg: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryExternal">ServiceDiscoveryExternal()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_service_discovery_external_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_service_discovery_external_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_service_discovery_external (
    wpainterfaceP2PDevice *proxy,
    gint arg_arg,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "ServiceDiscoveryExternal",
    g_variant_new ("(i)",
                   arg_arg),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_service_discovery_external_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_service_discovery_external().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_service_discovery_external().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_service_discovery_external_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_service_discovery_external_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_arg: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryExternal">ServiceDiscoveryExternal()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_service_discovery_external() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_service_discovery_external_sync (
    wpainterfaceP2PDevice *proxy,
    gint arg_arg,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "ServiceDiscoveryExternal",
    g_variant_new ("(i)",
                   arg_arg),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_add_persistent_group:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.AddPersistentGroup">AddPersistentGroup()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_add_persistent_group_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_add_persistent_group_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_add_persistent_group (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "AddPersistentGroup",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_add_persistent_group_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @out_path: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_add_persistent_group().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_add_persistent_group().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_add_persistent_group_finish (
    wpainterfaceP2PDevice *proxy,
    gchar **out_path,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_path);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_add_persistent_group_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_args: Argument to pass with the method invocation.
 * @out_path: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.AddPersistentGroup">AddPersistentGroup()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_add_persistent_group() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_add_persistent_group_sync (
    wpainterfaceP2PDevice *proxy,
    GVariant *arg_args,
    gchar **out_path,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "AddPersistentGroup",
    g_variant_new ("(@a{sv})",
                   arg_args),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(o)",
                 out_path);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_remove_persistent_group:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_path: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RemovePersistentGroup">RemovePersistentGroup()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_remove_persistent_group_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_remove_persistent_group_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_remove_persistent_group (
    wpainterfaceP2PDevice *proxy,
    const gchar *arg_path,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RemovePersistentGroup",
    g_variant_new ("(o)",
                   arg_path),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_remove_persistent_group_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_remove_persistent_group().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_remove_persistent_group().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_remove_persistent_group_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_remove_persistent_group_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @arg_path: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RemovePersistentGroup">RemovePersistentGroup()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_remove_persistent_group() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_remove_persistent_group_sync (
    wpainterfaceP2PDevice *proxy,
    const gchar *arg_path,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RemovePersistentGroup",
    g_variant_new ("(o)",
                   arg_path),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_remove_all_persistent_groups:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RemoveAllPersistentGroups">RemoveAllPersistentGroups()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_call_remove_all_persistent_groups_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_call_remove_all_persistent_groups_sync() for the synchronous, blocking version of this method.
 */
void
wpa_interface_p2_pdevice_call_remove_all_persistent_groups (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RemoveAllPersistentGroups",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * wpa_interface_p2_pdevice_call_remove_all_persistent_groups_finish:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_call_remove_all_persistent_groups().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_call_remove_all_persistent_groups().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_remove_all_persistent_groups_finish (
    wpainterfaceP2PDevice *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_call_remove_all_persistent_groups_sync:
 * @proxy: A #wpainterfaceP2PDeviceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RemoveAllPersistentGroups">RemoveAllPersistentGroups()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_call_remove_all_persistent_groups() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
wpa_interface_p2_pdevice_call_remove_all_persistent_groups_sync (
    wpainterfaceP2PDevice *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RemoveAllPersistentGroups",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * wpa_interface_p2_pdevice_complete_find:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Find">Find()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_find (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_stop_find:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.StopFind">StopFind()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_stop_find (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_listen:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Listen">Listen()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_listen (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_extended_listen:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ExtendedListen">ExtendedListen()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_extended_listen (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_presence_request:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.PresenceRequest">PresenceRequest()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_presence_request (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_provision_discovery_request:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ProvisionDiscoveryRequest">ProvisionDiscoveryRequest()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_provision_discovery_request (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_connect:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @generated_pin: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Connect">Connect()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_connect (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation,
    const gchar *generated_pin)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   generated_pin));
}

/**
 * wpa_interface_p2_pdevice_complete_group_add:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.GroupAdd">GroupAdd()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_group_add (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_cancel:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Cancel">Cancel()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_cancel (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_invite:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Invite">Invite()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_invite (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_disconnect:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Disconnect">Disconnect()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_disconnect (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_reject_peer:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RejectPeer">RejectPeer()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_reject_peer (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_remove_client:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RemoveClient">RemoveClient()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_remove_client (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_flush:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.Flush">Flush()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_flush (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_add_service:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.AddService">AddService()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_add_service (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_delete_service:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.DeleteService">DeleteService()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_delete_service (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_flush_service:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.FlushService">FlushService()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_flush_service (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_service_discovery_request:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @ref: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryRequest">ServiceDiscoveryRequest()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_service_discovery_request (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation,
    guint64 ref)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(t)",
                   ref));
}

/**
 * wpa_interface_p2_pdevice_complete_service_discovery_response:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryResponse">ServiceDiscoveryResponse()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_service_discovery_response (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_service_discovery_cancel_request:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryCancelRequest">ServiceDiscoveryCancelRequest()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_service_discovery_cancel_request (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_service_update:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceUpdate">ServiceUpdate()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_service_update (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_service_discovery_external:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.ServiceDiscoveryExternal">ServiceDiscoveryExternal()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_service_discovery_external (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_add_persistent_group:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @path: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.AddPersistentGroup">AddPersistentGroup()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_add_persistent_group (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation,
    const gchar *path)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(o)",
                   path));
}

/**
 * wpa_interface_p2_pdevice_complete_remove_persistent_group:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RemovePersistentGroup">RemovePersistentGroup()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_remove_persistent_group (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * wpa_interface_p2_pdevice_complete_remove_all_persistent_groups:
 * @object: A #wpainterfaceP2PDevice.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-fi-w1-wpa_supplicant1-Interface-P2PDevice.RemoveAllPersistentGroups">RemoveAllPersistentGroups()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
wpa_interface_p2_pdevice_complete_remove_all_persistent_groups (
    wpainterfaceP2PDevice *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * wpainterfaceP2PDeviceProxy:
 *
 * The #wpainterfaceP2PDeviceProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * wpainterfaceP2PDeviceProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #wpainterfaceP2PDeviceProxy.
 */

struct _wpainterfaceP2PDeviceProxyPrivate
{
  GData *qdata;
};

static void wpa_interface_p2_pdevice_proxy_iface_init (wpainterfaceP2PDeviceIface *iface);

#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (wpainterfaceP2PDeviceProxy, wpa_interface_p2_pdevice_proxy, G_TYPE_DBUS_PROXY,
                         G_ADD_PRIVATE (wpainterfaceP2PDeviceProxy)
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_P2_PDEVICE, wpa_interface_p2_pdevice_proxy_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (wpainterfaceP2PDeviceProxy, wpa_interface_p2_pdevice_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_P2_PDEVICE, wpa_interface_p2_pdevice_proxy_iface_init));

#endif
static void
wpa_interface_p2_pdevice_proxy_finalize (GObject *object)
{
  wpainterfaceP2PDeviceProxy *proxy = WPA_INTERFACE_P2_PDEVICE_PROXY (object);
  g_datalist_clear (&proxy->priv->qdata);
  G_OBJECT_CLASS (wpa_interface_p2_pdevice_proxy_parent_class)->finalize (object);
}

static void
wpa_interface_p2_pdevice_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 6);
  info = _wpa_interface_p2_pdevice_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
wpa_interface_p2_pdevice_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  GVariant *_ret;
  error = NULL;
  _ret = g_dbus_proxy_call_finish (proxy, res, &error);
  if (!_ret)
    {
      g_warning ("Error setting property '%s' on interface fi.w1.wpa_supplicant1.Interface.P2PDevice: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
  else
    {
      g_variant_unref (_ret);
    }
}

static void
wpa_interface_p2_pdevice_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 6);
  info = _wpa_interface_p2_pdevice_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "fi.w1.wpa_supplicant1.Interface.P2PDevice", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) wpa_interface_p2_pdevice_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);
  g_variant_unref (variant);
}

static void
wpa_interface_p2_pdevice_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name G_GNUC_UNUSED,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_wpa_interface_p2_pdevice_interface_info.parent_struct, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], WPA_INTERFACE_TYPE_P2_PDEVICE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, WPA_INTERFACE_TYPE_P2_PDEVICE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
wpa_interface_p2_pdevice_proxy_g_properties_changed (GDBusProxy *_proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  wpainterfaceP2PDeviceProxy *proxy = WPA_INTERFACE_P2_PDEVICE_PROXY (_proxy);
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_p2_pdevice_interface_info.parent_struct, key);
      g_datalist_remove_data (&proxy->priv->qdata, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_p2_pdevice_interface_info.parent_struct, invalidated_properties[n]);
      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static GVariant *
wpa_interface_p2_pdevice_proxy_get_p2_pdevice_config (wpainterfaceP2PDevice *object)
{
  wpainterfaceP2PDeviceProxy *proxy = WPA_INTERFACE_P2_PDEVICE_PROXY (object);
  GVariant *variant;
  GVariant *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "P2PDeviceConfig");
  value = variant;
  if (variant != NULL)
    g_variant_unref (variant);
  return value;
}

static const gchar *const *
wpa_interface_p2_pdevice_proxy_get_peers (wpainterfaceP2PDevice *object)
{
  wpainterfaceP2PDeviceProxy *proxy = WPA_INTERFACE_P2_PDEVICE_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Peers");
  if (variant != NULL)
    {
      value = g_variant_get_objv (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_p2_pdevice_proxy_get_role (wpainterfaceP2PDevice *object)
{
  wpainterfaceP2PDeviceProxy *proxy = WPA_INTERFACE_P2_PDEVICE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Role");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_p2_pdevice_proxy_get_group (wpainterfaceP2PDevice *object)
{
  wpainterfaceP2PDeviceProxy *proxy = WPA_INTERFACE_P2_PDEVICE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "Group");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *
wpa_interface_p2_pdevice_proxy_get_peer_go (wpainterfaceP2PDevice *object)
{
  wpainterfaceP2PDeviceProxy *proxy = WPA_INTERFACE_P2_PDEVICE_PROXY (object);
  GVariant *variant;
  const gchar *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PeerGO");
  if (variant != NULL)
    {
      value = g_variant_get_string (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static const gchar *const *
wpa_interface_p2_pdevice_proxy_get_persistent_groups (wpainterfaceP2PDevice *object)
{
  wpainterfaceP2PDeviceProxy *proxy = WPA_INTERFACE_P2_PDEVICE_PROXY (object);
  GVariant *variant;
  const gchar *const *value = NULL;
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "PersistentGroups");
  if (variant != NULL)
    {
      value = g_variant_get_objv (variant, NULL);
      g_variant_unref (variant);
    }
  return value;
}

static void
wpa_interface_p2_pdevice_proxy_init (wpainterfaceP2PDeviceProxy *proxy)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  proxy->priv = wpa_interface_p2_pdevice_proxy_get_instance_private (proxy);
#else
  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, WPA_INTERFACE_TYPE_P2_PDEVICE_PROXY, wpainterfaceP2PDeviceProxyPrivate);
#endif

  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), wpa_interface_p2_pdevice_interface_info ());
}

static void
wpa_interface_p2_pdevice_proxy_class_init (wpainterfaceP2PDeviceProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize     = wpa_interface_p2_pdevice_proxy_finalize;
  gobject_class->get_property = wpa_interface_p2_pdevice_proxy_get_property;
  gobject_class->set_property = wpa_interface_p2_pdevice_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = wpa_interface_p2_pdevice_proxy_g_signal;
  proxy_class->g_properties_changed = wpa_interface_p2_pdevice_proxy_g_properties_changed;

  wpa_interface_p2_pdevice_override_properties (gobject_class, 1);

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (wpainterfaceP2PDeviceProxyPrivate));
#endif
}

static void
wpa_interface_p2_pdevice_proxy_iface_init (wpainterfaceP2PDeviceIface *iface)
{
  iface->get_p2_pdevice_config = wpa_interface_p2_pdevice_proxy_get_p2_pdevice_config;
  iface->get_peers = wpa_interface_p2_pdevice_proxy_get_peers;
  iface->get_role = wpa_interface_p2_pdevice_proxy_get_role;
  iface->get_group = wpa_interface_p2_pdevice_proxy_get_group;
  iface->get_peer_go = wpa_interface_p2_pdevice_proxy_get_peer_go;
  iface->get_persistent_groups = wpa_interface_p2_pdevice_proxy_get_persistent_groups;
}

/**
 * wpa_interface_p2_pdevice_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-P2PDevice.top_of_page">fi.w1.wpa_supplicant1.Interface.P2PDevice</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_proxy_new_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
wpa_interface_p2_pdevice_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (WPA_INTERFACE_TYPE_P2_PDEVICE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "fi.w1.wpa_supplicant1.Interface.P2PDevice", NULL);
}

/**
 * wpa_interface_p2_pdevice_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_proxy_new().
 *
 * Returns: (transfer full) (type wpainterfaceP2PDeviceProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceP2PDevice *
wpa_interface_p2_pdevice_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return WPA_INTERFACE_P2_PDEVICE (ret);
  else
    return NULL;
}

/**
 * wpa_interface_p2_pdevice_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-P2PDevice.top_of_page">fi.w1.wpa_supplicant1.Interface.P2PDevice</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type wpainterfaceP2PDeviceProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceP2PDevice *
wpa_interface_p2_pdevice_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (WPA_INTERFACE_TYPE_P2_PDEVICE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "fi.w1.wpa_supplicant1.Interface.P2PDevice", NULL);
  if (ret != NULL)
    return WPA_INTERFACE_P2_PDEVICE (ret);
  else
    return NULL;
}


/**
 * wpa_interface_p2_pdevice_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like wpa_interface_p2_pdevice_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call wpa_interface_p2_pdevice_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See wpa_interface_p2_pdevice_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
wpa_interface_p2_pdevice_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (WPA_INTERFACE_TYPE_P2_PDEVICE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "fi.w1.wpa_supplicant1.Interface.P2PDevice", NULL);
}

/**
 * wpa_interface_p2_pdevice_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to wpa_interface_p2_pdevice_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with wpa_interface_p2_pdevice_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type wpainterfaceP2PDeviceProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceP2PDevice *
wpa_interface_p2_pdevice_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return WPA_INTERFACE_P2_PDEVICE (ret);
  else
    return NULL;
}

/**
 * wpa_interface_p2_pdevice_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like wpa_interface_p2_pdevice_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See wpa_interface_p2_pdevice_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type wpainterfaceP2PDeviceProxy): The constructed proxy object or %NULL if @error is set.
 */
wpainterfaceP2PDevice *
wpa_interface_p2_pdevice_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (WPA_INTERFACE_TYPE_P2_PDEVICE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "fi.w1.wpa_supplicant1.Interface.P2PDevice", NULL);
  if (ret != NULL)
    return WPA_INTERFACE_P2_PDEVICE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * wpainterfaceP2PDeviceSkeleton:
 *
 * The #wpainterfaceP2PDeviceSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * wpainterfaceP2PDeviceSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #wpainterfaceP2PDeviceSkeleton.
 */

struct _wpainterfaceP2PDeviceSkeletonPrivate
{
  GValue *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex lock;
};

static void
_wpa_interface_p2_pdevice_skeleton_handle_method_call (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = G_VALUE_INIT;
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], WPA_INTERFACE_TYPE_P2_PDEVICE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
    {
#ifdef G_OS_UNIX
      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
#else
      g_assert_not_reached ();
#endif
    }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, WPA_INTERFACE_TYPE_P2_PDEVICE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_wpa_interface_p2_pdevice_skeleton_handle_get_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_p2_pdevice_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_wpa_interface_p2_pdevice_skeleton_handle_set_property (
  GDBusConnection *connection G_GNUC_UNUSED,
  const gchar *sender G_GNUC_UNUSED,
  const gchar *object_path G_GNUC_UNUSED,
  const gchar *interface_name G_GNUC_UNUSED,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (user_data);
  GValue value = G_VALUE_INIT;
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_wpa_interface_p2_pdevice_interface_info.parent_struct, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _wpa_interface_p2_pdevice_skeleton_vtable =
{
  _wpa_interface_p2_pdevice_skeleton_handle_method_call,
  _wpa_interface_p2_pdevice_skeleton_handle_get_property,
  _wpa_interface_p2_pdevice_skeleton_handle_set_property,
  {NULL}
};

static GDBusInterfaceInfo *
wpa_interface_p2_pdevice_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return wpa_interface_p2_pdevice_interface_info ();
}

static GDBusInterfaceVTable *
wpa_interface_p2_pdevice_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
{
  return (GDBusInterfaceVTable *) &_wpa_interface_p2_pdevice_skeleton_vtable;
}

static GVariant *
wpa_interface_p2_pdevice_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_wpa_interface_p2_pdevice_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _wpa_interface_p2_pdevice_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _wpa_interface_p2_pdevice_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _wpa_interface_p2_pdevice_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _wpa_interface_p2_pdevice_emit_changed (gpointer user_data);

static void
wpa_interface_p2_pdevice_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (&skeleton->priv->lock);

  if (emit_changed)
    _wpa_interface_p2_pdevice_emit_changed (skeleton);
}

static void
_wpa_interface_p2_pdevice_on_signal_device_found (
    wpainterfaceP2PDevice *object,
    const gchar *arg_path)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o)",
                   arg_path));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "DeviceFound",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_device_found_properties (
    wpainterfaceP2PDevice *object,
    const gchar *arg_path,
    GVariant *arg_properties)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o@a{sv})",
                   arg_path,
                   arg_properties));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "DeviceFoundProperties",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_device_lost (
    wpainterfaceP2PDevice *object,
    const gchar *arg_path)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o)",
                   arg_path));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "DeviceLost",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_find_stopped (
    wpainterfaceP2PDevice *object)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("()"));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "FindStopped",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_provision_discovery_request_display_pin (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object,
    const gchar *arg_pin)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(os)",
                   arg_peer_object,
                   arg_pin));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "ProvisionDiscoveryRequestDisplayPin",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_provision_discovery_response_display_pin (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object,
    const gchar *arg_pin)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(os)",
                   arg_peer_object,
                   arg_pin));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "ProvisionDiscoveryResponseDisplayPin",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_provision_discovery_request_enter_pin (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o)",
                   arg_peer_object));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "ProvisionDiscoveryRequestEnterPin",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_provision_discovery_response_enter_pin (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o)",
                   arg_peer_object));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "ProvisionDiscoveryResponseEnterPin",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_provision_discovery_pbcrequest (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o)",
                   arg_peer_object));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "ProvisionDiscoveryPBCRequest",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_provision_discovery_pbcresponse (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o)",
                   arg_peer_object));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "ProvisionDiscoveryPBCResponse",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_provision_discovery_failure (
    wpainterfaceP2PDevice *object,
    const gchar *arg_peer_object,
    gint arg_status)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(oi)",
                   arg_peer_object,
                   arg_status));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "ProvisionDiscoveryFailure",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_group_started (
    wpainterfaceP2PDevice *object,
    GVariant *arg_properties)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@a{sv})",
                   arg_properties));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "GroupStarted",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_group_formation_failure (
    wpainterfaceP2PDevice *object,
    const gchar *arg_reason)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(s)",
                   arg_reason));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "GroupFormationFailure",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_gonegotiation_success (
    wpainterfaceP2PDevice *object,
    GVariant *arg_properties)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@a{sv})",
                   arg_properties));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "GONegotiationSuccess",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_gonegotiation_failure (
    wpainterfaceP2PDevice *object,
    GVariant *arg_properties)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@a{sv})",
                   arg_properties));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "GONegotiationFailure",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_gonegotiation_request (
    wpainterfaceP2PDevice *object,
    const gchar *arg_path,
    guint16 arg_dev_passwd_id,
    guchar arg_device_go_intent)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(oqy)",
                   arg_path,
                   arg_dev_passwd_id,
                   arg_device_go_intent));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "GONegotiationRequest",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_invitation_result (
    wpainterfaceP2PDevice *object,
    GVariant *arg_invite_result)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@a{sv})",
                   arg_invite_result));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "InvitationResult",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_group_finished (
    wpainterfaceP2PDevice *object,
    GVariant *arg_properties)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@a{sv})",
                   arg_properties));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "GroupFinished",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_service_discovery_request (
    wpainterfaceP2PDevice *object,
    GVariant *arg_sd_request)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@a{sv})",
                   arg_sd_request));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "ServiceDiscoveryRequest",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_service_discovery_response (
    wpainterfaceP2PDevice *object,
    GVariant *arg_sd_response)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@a{sv})",
                   arg_sd_response));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "ServiceDiscoveryResponse",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_persistent_group_added (
    wpainterfaceP2PDevice *object,
    const gchar *arg_path,
    GVariant *arg_properties)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o@a{sv})",
                   arg_path,
                   arg_properties));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "PersistentGroupAdded",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_persistent_group_removed (
    wpainterfaceP2PDevice *object,
    const gchar *arg_path)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(o)",
                   arg_path));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "PersistentGroupRemoved",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_wps_failed (
    wpainterfaceP2PDevice *object,
    const gchar *arg_name,
    GVariant *arg_args)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(s@a{sv})",
                   arg_name,
                   arg_args));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "WpsFailed",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void
_wpa_interface_p2_pdevice_on_signal_invitation_received (
    wpainterfaceP2PDevice *object,
    GVariant *arg_properties)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);

  GList      *connections, *l;
  GVariant   *signal_variant;
  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));

  signal_variant = g_variant_ref_sink (g_variant_new ("(@a{sv})",
                   arg_properties));
  for (l = connections; l != NULL; l = l->next)
    {
      GDBusConnection *connection = l->data;
      g_dbus_connection_emit_signal (connection,
        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "fi.w1.wpa_supplicant1.Interface.P2PDevice", "InvitationReceived",
        signal_variant, NULL);
    }
  g_variant_unref (signal_variant);
  g_list_free_full (connections, g_object_unref);
}

static void wpa_interface_p2_pdevice_skeleton_iface_init (wpainterfaceP2PDeviceIface *iface);
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
G_DEFINE_TYPE_WITH_CODE (wpainterfaceP2PDeviceSkeleton, wpa_interface_p2_pdevice_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_ADD_PRIVATE (wpainterfaceP2PDeviceSkeleton)
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_P2_PDEVICE, wpa_interface_p2_pdevice_skeleton_iface_init));

#else
G_DEFINE_TYPE_WITH_CODE (wpainterfaceP2PDeviceSkeleton, wpa_interface_p2_pdevice_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (WPA_INTERFACE_TYPE_P2_PDEVICE, wpa_interface_p2_pdevice_skeleton_iface_init));

#endif
static void
wpa_interface_p2_pdevice_skeleton_finalize (GObject *object)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);
  guint n;
  for (n = 0; n < 6; n++)
    g_value_unset (&skeleton->priv->properties[n]);
  g_free (skeleton->priv->properties);
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  g_main_context_unref (skeleton->priv->context);
  g_mutex_clear (&skeleton->priv->lock);
  G_OBJECT_CLASS (wpa_interface_p2_pdevice_skeleton_parent_class)->finalize (object);
}

static void
wpa_interface_p2_pdevice_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec G_GNUC_UNUSED)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 6);
  g_mutex_lock (&skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);
  g_mutex_unlock (&skeleton->priv->lock);
}

static gboolean
_wpa_interface_p2_pdevice_emit_changed (gpointer user_data)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (&skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      GList *connections, *ll;
      GVariant *signal_variant;
      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "fi.w1.wpa_supplicant1.Interface.P2PDevice",
                                           &builder, &invalidated_builder));
      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
      for (ll = connections; ll != NULL; ll = ll->next)
        {
          GDBusConnection *connection = ll->data;

          g_dbus_connection_emit_signal (connection,
                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                         "org.freedesktop.DBus.Properties",
                                         "PropertiesChanged",
                                         signal_variant,
                                         NULL);
        }
      g_variant_unref (signal_variant);
      g_list_free_full (connections, g_object_unref);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (&skeleton->priv->lock);
  return FALSE;
}

static void
_wpa_interface_p2_pdevice_schedule_emit_changed (wpainterfaceP2PDeviceSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
wpa_interface_p2_pdevice_skeleton_notify (GObject      *object,
  GParamSpec *pspec G_GNUC_UNUSED)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);
  g_mutex_lock (&skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _wpa_interface_p2_pdevice_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _wpa_interface_p2_pdevice_emit_changed");
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (&skeleton->priv->lock);
}

static void
wpa_interface_p2_pdevice_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 6);
  g_mutex_lock (&skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _wpa_interface_p2_pdevice_schedule_emit_changed (skeleton, _wpa_interface_p2_pdevice_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (&skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
wpa_interface_p2_pdevice_skeleton_init (wpainterfaceP2PDeviceSkeleton *skeleton)
{
#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
  skeleton->priv = wpa_interface_p2_pdevice_skeleton_get_instance_private (skeleton);
#else
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, WPA_INTERFACE_TYPE_P2_PDEVICE_SKELETON, wpainterfaceP2PDeviceSkeletonPrivate);
#endif

  g_mutex_init (&skeleton->priv->lock);
  skeleton->priv->context = g_main_context_ref_thread_default ();
  skeleton->priv->properties = g_new0 (GValue, 6);
  g_value_init (&skeleton->priv->properties[0], G_TYPE_VARIANT);
  g_value_init (&skeleton->priv->properties[1], G_TYPE_STRV);
  g_value_init (&skeleton->priv->properties[2], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[3], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[4], G_TYPE_STRING);
  g_value_init (&skeleton->priv->properties[5], G_TYPE_STRV);
}

static GVariant *
wpa_interface_p2_pdevice_skeleton_get_p2_pdevice_config (wpainterfaceP2PDevice *object)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);
  GVariant *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_variant (&(skeleton->priv->properties[0]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *const *
wpa_interface_p2_pdevice_skeleton_get_peers (wpainterfaceP2PDevice *object)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties[1]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_p2_pdevice_skeleton_get_role (wpainterfaceP2PDevice *object)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[2]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_p2_pdevice_skeleton_get_group (wpainterfaceP2PDevice *object)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[3]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *
wpa_interface_p2_pdevice_skeleton_get_peer_go (wpainterfaceP2PDevice *object)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);
  const gchar *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_string (&(skeleton->priv->properties[4]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static const gchar *const *
wpa_interface_p2_pdevice_skeleton_get_persistent_groups (wpainterfaceP2PDevice *object)
{
  wpainterfaceP2PDeviceSkeleton *skeleton = WPA_INTERFACE_P2_PDEVICE_SKELETON (object);
  const gchar *const *value;
  g_mutex_lock (&skeleton->priv->lock);
  value = g_value_get_boxed (&(skeleton->priv->properties[5]));
  g_mutex_unlock (&skeleton->priv->lock);
  return value;
}

static void
wpa_interface_p2_pdevice_skeleton_class_init (wpainterfaceP2PDeviceSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = wpa_interface_p2_pdevice_skeleton_finalize;
  gobject_class->get_property = wpa_interface_p2_pdevice_skeleton_get_property;
  gobject_class->set_property = wpa_interface_p2_pdevice_skeleton_set_property;
  gobject_class->notify       = wpa_interface_p2_pdevice_skeleton_notify;


  wpa_interface_p2_pdevice_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = wpa_interface_p2_pdevice_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = wpa_interface_p2_pdevice_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = wpa_interface_p2_pdevice_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = wpa_interface_p2_pdevice_skeleton_dbus_interface_get_vtable;

#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
  g_type_class_add_private (klass, sizeof (wpainterfaceP2PDeviceSkeletonPrivate));
#endif
}

static void
wpa_interface_p2_pdevice_skeleton_iface_init (wpainterfaceP2PDeviceIface *iface)
{
  iface->device_found = _wpa_interface_p2_pdevice_on_signal_device_found;
  iface->device_found_properties = _wpa_interface_p2_pdevice_on_signal_device_found_properties;
  iface->device_lost = _wpa_interface_p2_pdevice_on_signal_device_lost;
  iface->find_stopped = _wpa_interface_p2_pdevice_on_signal_find_stopped;
  iface->provision_discovery_request_display_pin = _wpa_interface_p2_pdevice_on_signal_provision_discovery_request_display_pin;
  iface->provision_discovery_response_display_pin = _wpa_interface_p2_pdevice_on_signal_provision_discovery_response_display_pin;
  iface->provision_discovery_request_enter_pin = _wpa_interface_p2_pdevice_on_signal_provision_discovery_request_enter_pin;
  iface->provision_discovery_response_enter_pin = _wpa_interface_p2_pdevice_on_signal_provision_discovery_response_enter_pin;
  iface->provision_discovery_pbcrequest = _wpa_interface_p2_pdevice_on_signal_provision_discovery_pbcrequest;
  iface->provision_discovery_pbcresponse = _wpa_interface_p2_pdevice_on_signal_provision_discovery_pbcresponse;
  iface->provision_discovery_failure = _wpa_interface_p2_pdevice_on_signal_provision_discovery_failure;
  iface->group_started = _wpa_interface_p2_pdevice_on_signal_group_started;
  iface->group_formation_failure = _wpa_interface_p2_pdevice_on_signal_group_formation_failure;
  iface->gonegotiation_success = _wpa_interface_p2_pdevice_on_signal_gonegotiation_success;
  iface->gonegotiation_failure = _wpa_interface_p2_pdevice_on_signal_gonegotiation_failure;
  iface->gonegotiation_request = _wpa_interface_p2_pdevice_on_signal_gonegotiation_request;
  iface->invitation_result = _wpa_interface_p2_pdevice_on_signal_invitation_result;
  iface->group_finished = _wpa_interface_p2_pdevice_on_signal_group_finished;
  iface->service_discovery_request = _wpa_interface_p2_pdevice_on_signal_service_discovery_request;
  iface->service_discovery_response = _wpa_interface_p2_pdevice_on_signal_service_discovery_response;
  iface->persistent_group_added = _wpa_interface_p2_pdevice_on_signal_persistent_group_added;
  iface->persistent_group_removed = _wpa_interface_p2_pdevice_on_signal_persistent_group_removed;
  iface->wps_failed = _wpa_interface_p2_pdevice_on_signal_wps_failed;
  iface->invitation_received = _wpa_interface_p2_pdevice_on_signal_invitation_received;
  iface->get_p2_pdevice_config = wpa_interface_p2_pdevice_skeleton_get_p2_pdevice_config;
  iface->get_peers = wpa_interface_p2_pdevice_skeleton_get_peers;
  iface->get_role = wpa_interface_p2_pdevice_skeleton_get_role;
  iface->get_group = wpa_interface_p2_pdevice_skeleton_get_group;
  iface->get_peer_go = wpa_interface_p2_pdevice_skeleton_get_peer_go;
  iface->get_persistent_groups = wpa_interface_p2_pdevice_skeleton_get_persistent_groups;
}

/**
 * wpa_interface_p2_pdevice_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-fi-w1-wpa_supplicant1-Interface-P2PDevice.top_of_page">fi.w1.wpa_supplicant1.Interface.P2PDevice</link>.
 *
 * Returns: (transfer full) (type wpainterfaceP2PDeviceSkeleton): The skeleton object.
 */
wpainterfaceP2PDevice *
wpa_interface_p2_pdevice_skeleton_new (void)
{
  return WPA_INTERFACE_P2_PDEVICE (g_object_new (WPA_INTERFACE_TYPE_P2_PDEVICE_SKELETON, NULL));
}

